function u3(n, e) {
  for (var t = 0; t < e.length; t++) {
    const i = e[t];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const r in i)
        if (r !== "default" && !(r in n)) {
          const s = Object.getOwnPropertyDescriptor(i, r);
          s &&
            Object.defineProperty(
              n,
              r,
              s.get ? s : { enumerable: !0, get: () => i[r] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
  new MutationObserver((r) => {
    for (const s of r)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && i(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(r) {
    const s = {};
    return (
      r.integrity && (s.integrity = r.integrity),
      r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : r.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function i(r) {
    if (r.ep) return;
    r.ep = !0;
    const s = t(r);
    fetch(r.href, s);
  }
})();
function hg(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
var Ob = { exports: {} },
  dg = {},
  kb = { exports: {} },
  wt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var gh = Symbol.for("react.element"),
  f3 = Symbol.for("react.portal"),
  h3 = Symbol.for("react.fragment"),
  d3 = Symbol.for("react.strict_mode"),
  p3 = Symbol.for("react.profiler"),
  m3 = Symbol.for("react.provider"),
  g3 = Symbol.for("react.context"),
  v3 = Symbol.for("react.forward_ref"),
  y3 = Symbol.for("react.suspense"),
  x3 = Symbol.for("react.memo"),
  _3 = Symbol.for("react.lazy"),
  lE = Symbol.iterator;
function A3(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (lE && n[lE]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var Hb = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  zb = Object.assign,
  Gb = {};
function iu(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = Gb),
    (this.updater = t || Hb);
}
iu.prototype.isReactComponent = {};
iu.prototype.setState = function (n, e) {
  if (typeof n != "object" && typeof n != "function" && n != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, n, e, "setState");
};
iu.prototype.forceUpdate = function (n) {
  this.updater.enqueueForceUpdate(this, n, "forceUpdate");
};
function Vb() {}
Vb.prototype = iu.prototype;
function hA(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = Gb),
    (this.updater = t || Hb);
}
var dA = (hA.prototype = new Vb());
dA.constructor = hA;
zb(dA, iu.prototype);
dA.isPureReactComponent = !0;
var cE = Array.isArray,
  Wb = Object.prototype.hasOwnProperty,
  pA = { current: null },
  jb = { key: !0, ref: !0, __self: !0, __source: !0 };
function Xb(n, e, t) {
  var i,
    r = {},
    s = null,
    o = null;
  if (e != null)
    for (i in (e.ref !== void 0 && (o = e.ref),
    e.key !== void 0 && (s = "" + e.key),
    e))
      Wb.call(e, i) && !jb.hasOwnProperty(i) && (r[i] = e[i]);
  var a = arguments.length - 2;
  if (a === 1) r.children = t;
  else if (1 < a) {
    for (var l = Array(a), u = 0; u < a; u++) l[u] = arguments[u + 2];
    r.children = l;
  }
  if (n && n.defaultProps)
    for (i in ((a = n.defaultProps), a)) r[i] === void 0 && (r[i] = a[i]);
  return {
    $$typeof: gh,
    type: n,
    key: s,
    ref: o,
    props: r,
    _owner: pA.current,
  };
}
function S3(n, e) {
  return {
    $$typeof: gh,
    type: n.type,
    key: e,
    ref: n.ref,
    props: n.props,
    _owner: n._owner,
  };
}
function mA(n) {
  return typeof n == "object" && n !== null && n.$$typeof === gh;
}
function M3(n) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    n.replace(/[=:]/g, function (t) {
      return e[t];
    })
  );
}
var uE = /\/+/g;
function wv(n, e) {
  return typeof n == "object" && n !== null && n.key != null
    ? M3("" + n.key)
    : e.toString(36);
}
function em(n, e, t, i, r) {
  var s = typeof n;
  (s === "undefined" || s === "boolean") && (n = null);
  var o = !1;
  if (n === null) o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (n.$$typeof) {
          case gh:
          case f3:
            o = !0;
        }
    }
  if (o)
    return (
      (o = n),
      (r = r(o)),
      (n = i === "" ? "." + wv(o, 0) : i),
      cE(r)
        ? ((t = ""),
          n != null && (t = n.replace(uE, "$&/") + "/"),
          em(r, e, t, "", function (u) {
            return u;
          }))
        : r != null &&
          (mA(r) &&
            (r = S3(
              r,
              t +
                (!r.key || (o && o.key === r.key)
                  ? ""
                  : ("" + r.key).replace(uE, "$&/") + "/") +
                n
            )),
          e.push(r)),
      1
    );
  if (((o = 0), (i = i === "" ? "." : i + ":"), cE(n)))
    for (var a = 0; a < n.length; a++) {
      s = n[a];
      var l = i + wv(s, a);
      o += em(s, e, t, l, r);
    }
  else if (((l = A3(n)), typeof l == "function"))
    for (n = l.call(n), a = 0; !(s = n.next()).done; )
      (s = s.value), (l = i + wv(s, a++)), (o += em(s, e, t, l, r));
  else if (s === "object")
    throw (
      ((e = String(n)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(n).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return o;
}
function zd(n, e, t) {
  if (n == null) return n;
  var i = [],
    r = 0;
  return (
    em(n, i, "", "", function (s) {
      return e.call(t, s, r++);
    }),
    i
  );
}
function E3(n) {
  if (n._status === -1) {
    var e = n._result;
    (e = e()),
      e.then(
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 1), (n._result = t));
        },
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 2), (n._result = t));
        }
      ),
      n._status === -1 && ((n._status = 0), (n._result = e));
  }
  if (n._status === 1) return n._result.default;
  throw n._result;
}
var _i = { current: null },
  tm = { transition: null },
  w3 = {
    ReactCurrentDispatcher: _i,
    ReactCurrentBatchConfig: tm,
    ReactCurrentOwner: pA,
  };
wt.Children = {
  map: zd,
  forEach: function (n, e, t) {
    zd(
      n,
      function () {
        e.apply(this, arguments);
      },
      t
    );
  },
  count: function (n) {
    var e = 0;
    return (
      zd(n, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (n) {
    return (
      zd(n, function (e) {
        return e;
      }) || []
    );
  },
  only: function (n) {
    if (!mA(n))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return n;
  },
};
wt.Component = iu;
wt.Fragment = h3;
wt.Profiler = p3;
wt.PureComponent = hA;
wt.StrictMode = d3;
wt.Suspense = y3;
wt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = w3;
wt.cloneElement = function (n, e, t) {
  if (n == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        n +
        "."
    );
  var i = zb({}, n.props),
    r = n.key,
    s = n.ref,
    o = n._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (o = pA.current)),
      e.key !== void 0 && (r = "" + e.key),
      n.type && n.type.defaultProps)
    )
      var a = n.type.defaultProps;
    for (l in e)
      Wb.call(e, l) &&
        !jb.hasOwnProperty(l) &&
        (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) i.children = t;
  else if (1 < l) {
    a = Array(l);
    for (var u = 0; u < l; u++) a[u] = arguments[u + 2];
    i.children = a;
  }
  return { $$typeof: gh, type: n.type, key: r, ref: s, props: i, _owner: o };
};
wt.createContext = function (n) {
  return (
    (n = {
      $$typeof: g3,
      _currentValue: n,
      _currentValue2: n,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (n.Provider = { $$typeof: m3, _context: n }),
    (n.Consumer = n)
  );
};
wt.createElement = Xb;
wt.createFactory = function (n) {
  var e = Xb.bind(null, n);
  return (e.type = n), e;
};
wt.createRef = function () {
  return { current: null };
};
wt.forwardRef = function (n) {
  return { $$typeof: v3, render: n };
};
wt.isValidElement = mA;
wt.lazy = function (n) {
  return { $$typeof: _3, _payload: { _status: -1, _result: n }, _init: E3 };
};
wt.memo = function (n, e) {
  return { $$typeof: x3, type: n, compare: e === void 0 ? null : e };
};
wt.startTransition = function (n) {
  var e = tm.transition;
  tm.transition = {};
  try {
    n();
  } finally {
    tm.transition = e;
  }
};
wt.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
wt.useCallback = function (n, e) {
  return _i.current.useCallback(n, e);
};
wt.useContext = function (n) {
  return _i.current.useContext(n);
};
wt.useDebugValue = function () {};
wt.useDeferredValue = function (n) {
  return _i.current.useDeferredValue(n);
};
wt.useEffect = function (n, e) {
  return _i.current.useEffect(n, e);
};
wt.useId = function () {
  return _i.current.useId();
};
wt.useImperativeHandle = function (n, e, t) {
  return _i.current.useImperativeHandle(n, e, t);
};
wt.useInsertionEffect = function (n, e) {
  return _i.current.useInsertionEffect(n, e);
};
wt.useLayoutEffect = function (n, e) {
  return _i.current.useLayoutEffect(n, e);
};
wt.useMemo = function (n, e) {
  return _i.current.useMemo(n, e);
};
wt.useReducer = function (n, e, t) {
  return _i.current.useReducer(n, e, t);
};
wt.useRef = function (n) {
  return _i.current.useRef(n);
};
wt.useState = function (n) {
  return _i.current.useState(n);
};
wt.useSyncExternalStore = function (n, e, t) {
  return _i.current.useSyncExternalStore(n, e, t);
};
wt.useTransition = function () {
  return _i.current.useTransition();
};
wt.version = "18.2.0";
kb.exports = wt;
var W = kb.exports;
const Et = hg(W),
  T3 = u3({ __proto__: null, default: Et }, [W]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var C3 = W,
  b3 = Symbol.for("react.element"),
  R3 = Symbol.for("react.fragment"),
  P3 = Object.prototype.hasOwnProperty,
  B3 = C3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  L3 = { key: !0, ref: !0, __self: !0, __source: !0 };
function Jb(n, e, t) {
  var i,
    r = {},
    s = null,
    o = null;
  t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
  for (i in e) P3.call(e, i) && !L3.hasOwnProperty(i) && (r[i] = e[i]);
  if (n && n.defaultProps)
    for (i in ((e = n.defaultProps), e)) r[i] === void 0 && (r[i] = e[i]);
  return {
    $$typeof: b3,
    type: n,
    key: s,
    ref: o,
    props: r,
    _owner: B3.current,
  };
}
dg.Fragment = R3;
dg.jsx = Jb;
dg.jsxs = Jb;
Ob.exports = dg;
var q = Ob.exports,
  sx = {},
  Kb = { exports: {} },
  nr = {},
  Yb = { exports: {} },
  Qb = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(I, G) {
    var k = I.length;
    I.push(G);
    e: for (; 0 < k; ) {
      var U = (k - 1) >>> 1,
        j = I[U];
      if (0 < r(j, G)) (I[U] = G), (I[k] = j), (k = U);
      else break e;
    }
  }
  function t(I) {
    return I.length === 0 ? null : I[0];
  }
  function i(I) {
    if (I.length === 0) return null;
    var G = I[0],
      k = I.pop();
    if (k !== G) {
      I[0] = k;
      e: for (var U = 0, j = I.length, he = j >>> 1; U < he; ) {
        var ae = 2 * (U + 1) - 1,
          xe = I[ae],
          Ae = ae + 1,
          Le = I[Ae];
        if (0 > r(xe, k))
          Ae < j && 0 > r(Le, xe)
            ? ((I[U] = Le), (I[Ae] = k), (U = Ae))
            : ((I[U] = xe), (I[ae] = k), (U = ae));
        else if (Ae < j && 0 > r(Le, k)) (I[U] = Le), (I[Ae] = k), (U = Ae);
        else break e;
      }
    }
    return G;
  }
  function r(I, G) {
    var k = I.sortIndex - G.sortIndex;
    return k !== 0 ? k : I.id - G.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    u = [],
    h = 1,
    d = null,
    p = 3,
    m = !1,
    y = !1,
    M = !1,
    A = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    x = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function _(I) {
    for (var G = t(u); G !== null; ) {
      if (G.callback === null) i(u);
      else if (G.startTime <= I)
        i(u), (G.sortIndex = G.expirationTime), e(l, G);
      else break;
      G = t(u);
    }
  }
  function E(I) {
    if (((M = !1), _(I), !y))
      if (t(l) !== null) (y = !0), ie(T);
      else {
        var G = t(u);
        G !== null && ee(E, G.startTime - I);
      }
  }
  function T(I, G) {
    (y = !1), M && ((M = !1), g(B), (B = -1)), (m = !0);
    var k = p;
    try {
      for (
        _(G), d = t(l);
        d !== null && (!(d.expirationTime > G) || (I && !z()));

      ) {
        var U = d.callback;
        if (typeof U == "function") {
          (d.callback = null), (p = d.priorityLevel);
          var j = U(d.expirationTime <= G);
          (G = n.unstable_now()),
            typeof j == "function" ? (d.callback = j) : d === t(l) && i(l),
            _(G);
        } else i(l);
        d = t(l);
      }
      if (d !== null) var he = !0;
      else {
        var ae = t(u);
        ae !== null && ee(E, ae.startTime - G), (he = !1);
      }
      return he;
    } finally {
      (d = null), (p = k), (m = !1);
    }
  }
  var R = !1,
    P = null,
    B = -1,
    b = 5,
    L = -1;
  function z() {
    return !(n.unstable_now() - L < b);
  }
  function $() {
    if (P !== null) {
      var I = n.unstable_now();
      L = I;
      var G = !0;
      try {
        G = P(!0, I);
      } finally {
        G ? X() : ((R = !1), (P = null));
      }
    } else R = !1;
  }
  var X;
  if (typeof x == "function")
    X = function () {
      x($);
    };
  else if (typeof MessageChannel < "u") {
    var Y = new MessageChannel(),
      K = Y.port2;
    (Y.port1.onmessage = $),
      (X = function () {
        K.postMessage(null);
      });
  } else
    X = function () {
      A($, 0);
    };
  function ie(I) {
    (P = I), R || ((R = !0), X());
  }
  function ee(I, G) {
    B = A(function () {
      I(n.unstable_now());
    }, G);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (I) {
      I.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      y || m || ((y = !0), ie(T));
    }),
    (n.unstable_forceFrameRate = function (I) {
      0 > I || 125 < I
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (b = 0 < I ? Math.floor(1e3 / I) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (I) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var G = 3;
          break;
        default:
          G = p;
      }
      var k = p;
      p = G;
      try {
        return I();
      } finally {
        p = k;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (I, G) {
      switch (I) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          I = 3;
      }
      var k = p;
      p = I;
      try {
        return G();
      } finally {
        p = k;
      }
    }),
    (n.unstable_scheduleCallback = function (I, G, k) {
      var U = n.unstable_now();
      switch (
        (typeof k == "object" && k !== null
          ? ((k = k.delay), (k = typeof k == "number" && 0 < k ? U + k : U))
          : (k = U),
        I)
      ) {
        case 1:
          var j = -1;
          break;
        case 2:
          j = 250;
          break;
        case 5:
          j = 1073741823;
          break;
        case 4:
          j = 1e4;
          break;
        default:
          j = 5e3;
      }
      return (
        (j = k + j),
        (I = {
          id: h++,
          callback: G,
          priorityLevel: I,
          startTime: k,
          expirationTime: j,
          sortIndex: -1,
        }),
        k > U
          ? ((I.sortIndex = k),
            e(u, I),
            t(l) === null &&
              I === t(u) &&
              (M ? (g(B), (B = -1)) : (M = !0), ee(E, k - U)))
          : ((I.sortIndex = j), e(l, I), y || m || ((y = !0), ie(T))),
        I
      );
    }),
    (n.unstable_shouldYield = z),
    (n.unstable_wrapCallback = function (I) {
      var G = p;
      return function () {
        var k = p;
        p = G;
        try {
          return I.apply(this, arguments);
        } finally {
          p = k;
        }
      };
    });
})(Qb);
Yb.exports = Qb;
var I3 = Yb.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var qb = W,
  Zi = I3;
function Ce(n) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1;
    t < arguments.length;
    t++
  )
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return (
    "Minified React error #" +
    n +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var Zb = new Set(),
  If = {};
function ul(n, e) {
  Oc(n, e), Oc(n + "Capture", e);
}
function Oc(n, e) {
  for (If[n] = e, n = 0; n < e.length; n++) Zb.add(e[n]);
}
var Ys = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  ox = Object.prototype.hasOwnProperty,
  D3 =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  fE = {},
  hE = {};
function F3(n) {
  return ox.call(hE, n)
    ? !0
    : ox.call(fE, n)
    ? !1
    : D3.test(n)
    ? (hE[n] = !0)
    : ((fE[n] = !0), !1);
}
function N3(n, e, t, i) {
  if (t !== null && t.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return i
        ? !1
        : t !== null
        ? !t.acceptsBooleans
        : ((n = n.toLowerCase().slice(0, 5)), n !== "data-" && n !== "aria-");
    default:
      return !1;
  }
}
function U3(n, e, t, i) {
  if (e === null || typeof e > "u" || N3(n, e, t, i)) return !0;
  if (i) return !1;
  if (t !== null)
    switch (t.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function Ai(n, e, t, i, r, s, o) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = i),
    (this.attributeNamespace = r),
    (this.mustUseProperty = t),
    (this.propertyName = n),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o);
}
var Qn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (n) {
    Qn[n] = new Ai(n, 0, !1, n, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (n) {
  var e = n[0];
  Qn[e] = new Ai(e, 1, !1, n[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) {
  Qn[n] = new Ai(n, 2, !1, n.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (n) {
  Qn[n] = new Ai(n, 2, !1, n, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (n) {
    Qn[n] = new Ai(n, 3, !1, n.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (n) {
  Qn[n] = new Ai(n, 3, !0, n, null, !1, !1);
});
["capture", "download"].forEach(function (n) {
  Qn[n] = new Ai(n, 4, !1, n, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (n) {
  Qn[n] = new Ai(n, 6, !1, n, null, !1, !1);
});
["rowSpan", "start"].forEach(function (n) {
  Qn[n] = new Ai(n, 5, !1, n.toLowerCase(), null, !1, !1);
});
var gA = /[\-:]([a-z])/g;
function vA(n) {
  return n[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(gA, vA);
    Qn[e] = new Ai(e, 1, !1, n, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(gA, vA);
    Qn[e] = new Ai(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (n) {
  var e = n.replace(gA, vA);
  Qn[e] = new Ai(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (n) {
  Qn[n] = new Ai(n, 1, !1, n.toLowerCase(), null, !1, !1);
});
Qn.xlinkHref = new Ai(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (n) {
  Qn[n] = new Ai(n, 1, !1, n.toLowerCase(), null, !0, !0);
});
function yA(n, e, t, i) {
  var r = Qn.hasOwnProperty(e) ? Qn[e] : null;
  (r !== null
    ? r.type !== 0
    : i ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (U3(e, t, r, i) && (t = null),
    i || r === null
      ? F3(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t))
      : r.mustUseProperty
      ? (n[r.propertyName] = t === null ? (r.type === 3 ? !1 : "") : t)
      : ((e = r.attributeName),
        (i = r.attributeNamespace),
        t === null
          ? n.removeAttribute(e)
          : ((r = r.type),
            (t = r === 3 || (r === 4 && t === !0) ? "" : "" + t),
            i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))));
}
var to = qb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  Gd = Symbol.for("react.element"),
  sc = Symbol.for("react.portal"),
  oc = Symbol.for("react.fragment"),
  xA = Symbol.for("react.strict_mode"),
  ax = Symbol.for("react.profiler"),
  $b = Symbol.for("react.provider"),
  eR = Symbol.for("react.context"),
  _A = Symbol.for("react.forward_ref"),
  lx = Symbol.for("react.suspense"),
  cx = Symbol.for("react.suspense_list"),
  AA = Symbol.for("react.memo"),
  Ao = Symbol.for("react.lazy"),
  tR = Symbol.for("react.offscreen"),
  dE = Symbol.iterator;
function Lu(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (dE && n[dE]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var un = Object.assign,
  Tv;
function af(n) {
  if (Tv === void 0)
    try {
      throw Error();
    } catch (t) {
      var e = t.stack.trim().match(/\n( *(at )?)/);
      Tv = (e && e[1]) || "";
    }
  return (
    `
` +
    Tv +
    n
  );
}
var Cv = !1;
function bv(n, e) {
  if (!n || Cv) return "";
  Cv = !0;
  var t = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (u) {
          var i = u;
        }
        Reflect.construct(n, [], e);
      } else {
        try {
          e.call();
        } catch (u) {
          i = u;
        }
        n.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (u) {
        i = u;
      }
      n();
    }
  } catch (u) {
    if (u && i && typeof u.stack == "string") {
      for (
        var r = u.stack.split(`
`),
          s = i.stack.split(`
`),
          o = r.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && r[o] !== s[a];

      )
        a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (r[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || r[o] !== s[a])) {
                var l =
                  `
` + r[o].replace(" at new ", " at ");
                return (
                  n.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", n.displayName)),
                  l
                );
              }
            while (1 <= o && 0 <= a);
          break;
        }
    }
  } finally {
    (Cv = !1), (Error.prepareStackTrace = t);
  }
  return (n = n ? n.displayName || n.name : "") ? af(n) : "";
}
function O3(n) {
  switch (n.tag) {
    case 5:
      return af(n.type);
    case 16:
      return af("Lazy");
    case 13:
      return af("Suspense");
    case 19:
      return af("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (n = bv(n.type, !1)), n;
    case 11:
      return (n = bv(n.type.render, !1)), n;
    case 1:
      return (n = bv(n.type, !0)), n;
    default:
      return "";
  }
}
function ux(n) {
  if (n == null) return null;
  if (typeof n == "function") return n.displayName || n.name || null;
  if (typeof n == "string") return n;
  switch (n) {
    case oc:
      return "Fragment";
    case sc:
      return "Portal";
    case ax:
      return "Profiler";
    case xA:
      return "StrictMode";
    case lx:
      return "Suspense";
    case cx:
      return "SuspenseList";
  }
  if (typeof n == "object")
    switch (n.$$typeof) {
      case eR:
        return (n.displayName || "Context") + ".Consumer";
      case $b:
        return (n._context.displayName || "Context") + ".Provider";
      case _A:
        var e = n.render;
        return (
          (n = n.displayName),
          n ||
            ((n = e.displayName || e.name || ""),
            (n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")),
          n
        );
      case AA:
        return (
          (e = n.displayName || null), e !== null ? e : ux(n.type) || "Memo"
        );
      case Ao:
        (e = n._payload), (n = n._init);
        try {
          return ux(n(e));
        } catch {}
    }
  return null;
}
function k3(n) {
  var e = n.type;
  switch (n.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (n = e.render),
        (n = n.displayName || n.name || ""),
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return ux(e);
    case 8:
      return e === xA ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function jo(n) {
  switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return n;
    case "object":
      return n;
    default:
      return "";
  }
}
function nR(n) {
  var e = n.type;
  return (
    (n = n.nodeName) &&
    n.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function H3(n) {
  var e = nR(n) ? "checked" : "value",
    t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e),
    i = "" + n[e];
  if (
    !n.hasOwnProperty(e) &&
    typeof t < "u" &&
    typeof t.get == "function" &&
    typeof t.set == "function"
  ) {
    var r = t.get,
      s = t.set;
    return (
      Object.defineProperty(n, e, {
        configurable: !0,
        get: function () {
          return r.call(this);
        },
        set: function (o) {
          (i = "" + o), s.call(this, o);
        },
      }),
      Object.defineProperty(n, e, { enumerable: t.enumerable }),
      {
        getValue: function () {
          return i;
        },
        setValue: function (o) {
          i = "" + o;
        },
        stopTracking: function () {
          (n._valueTracker = null), delete n[e];
        },
      }
    );
  }
}
function Vd(n) {
  n._valueTracker || (n._valueTracker = H3(n));
}
function iR(n) {
  if (!n) return !1;
  var e = n._valueTracker;
  if (!e) return !0;
  var t = e.getValue(),
    i = "";
  return (
    n && (i = nR(n) ? (n.checked ? "true" : "false") : n.value),
    (n = i),
    n !== t ? (e.setValue(n), !0) : !1
  );
}
function Em(n) {
  if (((n = n || (typeof document < "u" ? document : void 0)), typeof n > "u"))
    return null;
  try {
    return n.activeElement || n.body;
  } catch {
    return n.body;
  }
}
function fx(n, e) {
  var t = e.checked;
  return un({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: t ?? n._wrapperState.initialChecked,
  });
}
function pE(n, e) {
  var t = e.defaultValue == null ? "" : e.defaultValue,
    i = e.checked != null ? e.checked : e.defaultChecked;
  (t = jo(e.value != null ? e.value : t)),
    (n._wrapperState = {
      initialChecked: i,
      initialValue: t,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function rR(n, e) {
  (e = e.checked), e != null && yA(n, "checked", e, !1);
}
function hx(n, e) {
  rR(n, e);
  var t = jo(e.value),
    i = e.type;
  if (t != null)
    i === "number"
      ? ((t === 0 && n.value === "") || n.value != t) && (n.value = "" + t)
      : n.value !== "" + t && (n.value = "" + t);
  else if (i === "submit" || i === "reset") {
    n.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? dx(n, e.type, t)
    : e.hasOwnProperty("defaultValue") && dx(n, e.type, jo(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (n.defaultChecked = !!e.defaultChecked);
}
function mE(n, e, t) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var i = e.type;
    if (
      !(
        (i !== "submit" && i !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + n._wrapperState.initialValue),
      t || e === n.value || (n.value = e),
      (n.defaultValue = e);
  }
  (t = n.name),
    t !== "" && (n.name = ""),
    (n.defaultChecked = !!n._wrapperState.initialChecked),
    t !== "" && (n.name = t);
}
function dx(n, e, t) {
  (e !== "number" || Em(n.ownerDocument) !== n) &&
    (t == null
      ? (n.defaultValue = "" + n._wrapperState.initialValue)
      : n.defaultValue !== "" + t && (n.defaultValue = "" + t));
}
var lf = Array.isArray;
function Tc(n, e, t, i) {
  if (((n = n.options), e)) {
    e = {};
    for (var r = 0; r < t.length; r++) e["$" + t[r]] = !0;
    for (t = 0; t < n.length; t++)
      (r = e.hasOwnProperty("$" + n[t].value)),
        n[t].selected !== r && (n[t].selected = r),
        r && i && (n[t].defaultSelected = !0);
  } else {
    for (t = "" + jo(t), e = null, r = 0; r < n.length; r++) {
      if (n[r].value === t) {
        (n[r].selected = !0), i && (n[r].defaultSelected = !0);
        return;
      }
      e !== null || n[r].disabled || (e = n[r]);
    }
    e !== null && (e.selected = !0);
  }
}
function px(n, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(Ce(91));
  return un({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + n._wrapperState.initialValue,
  });
}
function gE(n, e) {
  var t = e.value;
  if (t == null) {
    if (((t = e.children), (e = e.defaultValue), t != null)) {
      if (e != null) throw Error(Ce(92));
      if (lf(t)) {
        if (1 < t.length) throw Error(Ce(93));
        t = t[0];
      }
      e = t;
    }
    e == null && (e = ""), (t = e);
  }
  n._wrapperState = { initialValue: jo(t) };
}
function sR(n, e) {
  var t = jo(e.value),
    i = jo(e.defaultValue);
  t != null &&
    ((t = "" + t),
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    i != null && (n.defaultValue = "" + i);
}
function vE(n) {
  var e = n.textContent;
  e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e);
}
function oR(n) {
  switch (n) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function mx(n, e) {
  return n == null || n === "http://www.w3.org/1999/xhtml"
    ? oR(e)
    : n === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : n;
}
var Wd,
  aR = (function (n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, t, i, r) {
          MSApp.execUnsafeLocalFunction(function () {
            return n(e, t, i, r);
          });
        }
      : n;
  })(function (n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n)
      n.innerHTML = e;
    else {
      for (
        Wd = Wd || document.createElement("div"),
          Wd.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = Wd.firstChild;
        n.firstChild;

      )
        n.removeChild(n.firstChild);
      for (; e.firstChild; ) n.appendChild(e.firstChild);
    }
  });
function Df(n, e) {
  if (e) {
    var t = n.firstChild;
    if (t && t === n.lastChild && t.nodeType === 3) {
      t.nodeValue = e;
      return;
    }
  }
  n.textContent = e;
}
var pf = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  z3 = ["Webkit", "ms", "Moz", "O"];
Object.keys(pf).forEach(function (n) {
  z3.forEach(function (e) {
    (e = e + n.charAt(0).toUpperCase() + n.substring(1)), (pf[e] = pf[n]);
  });
});
function lR(n, e, t) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : t || typeof e != "number" || e === 0 || (pf.hasOwnProperty(n) && pf[n])
    ? ("" + e).trim()
    : e + "px";
}
function cR(n, e) {
  n = n.style;
  for (var t in e)
    if (e.hasOwnProperty(t)) {
      var i = t.indexOf("--") === 0,
        r = lR(t, e[t], i);
      t === "float" && (t = "cssFloat"), i ? n.setProperty(t, r) : (n[t] = r);
    }
}
var G3 = un(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function gx(n, e) {
  if (e) {
    if (G3[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(Ce(137, n));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(Ce(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(Ce(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(Ce(62));
  }
}
function vx(n, e) {
  if (n.indexOf("-") === -1) return typeof e.is == "string";
  switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var yx = null;
function SA(n) {
  return (
    (n = n.target || n.srcElement || window),
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
  );
}
var xx = null,
  Cc = null,
  bc = null;
function yE(n) {
  if ((n = xh(n))) {
    if (typeof xx != "function") throw Error(Ce(280));
    var e = n.stateNode;
    e && ((e = yg(e)), xx(n.stateNode, n.type, e));
  }
}
function uR(n) {
  Cc ? (bc ? bc.push(n) : (bc = [n])) : (Cc = n);
}
function fR() {
  if (Cc) {
    var n = Cc,
      e = bc;
    if (((bc = Cc = null), yE(n), e)) for (n = 0; n < e.length; n++) yE(e[n]);
  }
}
function hR(n, e) {
  return n(e);
}
function dR() {}
var Rv = !1;
function pR(n, e, t) {
  if (Rv) return n(e, t);
  Rv = !0;
  try {
    return hR(n, e, t);
  } finally {
    (Rv = !1), (Cc !== null || bc !== null) && (dR(), fR());
  }
}
function Ff(n, e) {
  var t = n.stateNode;
  if (t === null) return null;
  var i = yg(t);
  if (i === null) return null;
  t = i[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (i = !i.disabled) ||
        ((n = n.type),
        (i = !(
          n === "button" ||
          n === "input" ||
          n === "select" ||
          n === "textarea"
        ))),
        (n = !i);
      break e;
    default:
      n = !1;
  }
  if (n) return null;
  if (t && typeof t != "function") throw Error(Ce(231, e, typeof t));
  return t;
}
var _x = !1;
if (Ys)
  try {
    var Iu = {};
    Object.defineProperty(Iu, "passive", {
      get: function () {
        _x = !0;
      },
    }),
      window.addEventListener("test", Iu, Iu),
      window.removeEventListener("test", Iu, Iu);
  } catch {
    _x = !1;
  }
function V3(n, e, t, i, r, s, o, a, l) {
  var u = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(t, u);
  } catch (h) {
    this.onError(h);
  }
}
var mf = !1,
  wm = null,
  Tm = !1,
  Ax = null,
  W3 = {
    onError: function (n) {
      (mf = !0), (wm = n);
    },
  };
function j3(n, e, t, i, r, s, o, a, l) {
  (mf = !1), (wm = null), V3.apply(W3, arguments);
}
function X3(n, e, t, i, r, s, o, a, l) {
  if ((j3.apply(this, arguments), mf)) {
    if (mf) {
      var u = wm;
      (mf = !1), (wm = null);
    } else throw Error(Ce(198));
    Tm || ((Tm = !0), (Ax = u));
  }
}
function fl(n) {
  var e = n,
    t = n;
  if (n.alternate) for (; e.return; ) e = e.return;
  else {
    n = e;
    do (e = n), e.flags & 4098 && (t = e.return), (n = e.return);
    while (n);
  }
  return e.tag === 3 ? t : null;
}
function mR(n) {
  if (n.tag === 13) {
    var e = n.memoizedState;
    if (
      (e === null && ((n = n.alternate), n !== null && (e = n.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function xE(n) {
  if (fl(n) !== n) throw Error(Ce(188));
}
function J3(n) {
  var e = n.alternate;
  if (!e) {
    if (((e = fl(n)), e === null)) throw Error(Ce(188));
    return e !== n ? null : n;
  }
  for (var t = n, i = e; ; ) {
    var r = t.return;
    if (r === null) break;
    var s = r.alternate;
    if (s === null) {
      if (((i = r.return), i !== null)) {
        t = i;
        continue;
      }
      break;
    }
    if (r.child === s.child) {
      for (s = r.child; s; ) {
        if (s === t) return xE(r), n;
        if (s === i) return xE(r), e;
        s = s.sibling;
      }
      throw Error(Ce(188));
    }
    if (t.return !== i.return) (t = r), (i = s);
    else {
      for (var o = !1, a = r.child; a; ) {
        if (a === t) {
          (o = !0), (t = r), (i = s);
          break;
        }
        if (a === i) {
          (o = !0), (i = r), (t = s);
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === t) {
            (o = !0), (t = s), (i = r);
            break;
          }
          if (a === i) {
            (o = !0), (i = s), (t = r);
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(Ce(189));
      }
    }
    if (t.alternate !== i) throw Error(Ce(190));
  }
  if (t.tag !== 3) throw Error(Ce(188));
  return t.stateNode.current === t ? n : e;
}
function gR(n) {
  return (n = J3(n)), n !== null ? vR(n) : null;
}
function vR(n) {
  if (n.tag === 5 || n.tag === 6) return n;
  for (n = n.child; n !== null; ) {
    var e = vR(n);
    if (e !== null) return e;
    n = n.sibling;
  }
  return null;
}
var yR = Zi.unstable_scheduleCallback,
  _E = Zi.unstable_cancelCallback,
  K3 = Zi.unstable_shouldYield,
  Y3 = Zi.unstable_requestPaint,
  _n = Zi.unstable_now,
  Q3 = Zi.unstable_getCurrentPriorityLevel,
  MA = Zi.unstable_ImmediatePriority,
  xR = Zi.unstable_UserBlockingPriority,
  Cm = Zi.unstable_NormalPriority,
  q3 = Zi.unstable_LowPriority,
  _R = Zi.unstable_IdlePriority,
  pg = null,
  ds = null;
function Z3(n) {
  if (ds && typeof ds.onCommitFiberRoot == "function")
    try {
      ds.onCommitFiberRoot(pg, n, void 0, (n.current.flags & 128) === 128);
    } catch {}
}
var Hr = Math.clz32 ? Math.clz32 : tF,
  $3 = Math.log,
  eF = Math.LN2;
function tF(n) {
  return (n >>>= 0), n === 0 ? 32 : (31 - (($3(n) / eF) | 0)) | 0;
}
var jd = 64,
  Xd = 4194304;
function cf(n) {
  switch (n & -n) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return n & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return n;
  }
}
function bm(n, e) {
  var t = n.pendingLanes;
  if (t === 0) return 0;
  var i = 0,
    r = n.suspendedLanes,
    s = n.pingedLanes,
    o = t & 268435455;
  if (o !== 0) {
    var a = o & ~r;
    a !== 0 ? (i = cf(a)) : ((s &= o), s !== 0 && (i = cf(s)));
  } else (o = t & ~r), o !== 0 ? (i = cf(o)) : s !== 0 && (i = cf(s));
  if (i === 0) return 0;
  if (
    e !== 0 &&
    e !== i &&
    !(e & r) &&
    ((r = i & -i), (s = e & -e), r >= s || (r === 16 && (s & 4194240) !== 0))
  )
    return e;
  if ((i & 4 && (i |= t & 16), (e = n.entangledLanes), e !== 0))
    for (n = n.entanglements, e &= i; 0 < e; )
      (t = 31 - Hr(e)), (r = 1 << t), (i |= n[t]), (e &= ~r);
  return i;
}
function nF(n, e) {
  switch (n) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function iF(n, e) {
  for (
    var t = n.suspendedLanes,
      i = n.pingedLanes,
      r = n.expirationTimes,
      s = n.pendingLanes;
    0 < s;

  ) {
    var o = 31 - Hr(s),
      a = 1 << o,
      l = r[o];
    l === -1
      ? (!(a & t) || a & i) && (r[o] = nF(a, e))
      : l <= e && (n.expiredLanes |= a),
      (s &= ~a);
  }
}
function Sx(n) {
  return (
    (n = n.pendingLanes & -1073741825),
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
  );
}
function AR() {
  var n = jd;
  return (jd <<= 1), !(jd & 4194240) && (jd = 64), n;
}
function Pv(n) {
  for (var e = [], t = 0; 31 > t; t++) e.push(n);
  return e;
}
function vh(n, e, t) {
  (n.pendingLanes |= e),
    e !== 536870912 && ((n.suspendedLanes = 0), (n.pingedLanes = 0)),
    (n = n.eventTimes),
    (e = 31 - Hr(e)),
    (n[e] = t);
}
function rF(n, e) {
  var t = n.pendingLanes & ~e;
  (n.pendingLanes = e),
    (n.suspendedLanes = 0),
    (n.pingedLanes = 0),
    (n.expiredLanes &= e),
    (n.mutableReadLanes &= e),
    (n.entangledLanes &= e),
    (e = n.entanglements);
  var i = n.eventTimes;
  for (n = n.expirationTimes; 0 < t; ) {
    var r = 31 - Hr(t),
      s = 1 << r;
    (e[r] = 0), (i[r] = -1), (n[r] = -1), (t &= ~s);
  }
}
function EA(n, e) {
  var t = (n.entangledLanes |= e);
  for (n = n.entanglements; t; ) {
    var i = 31 - Hr(t),
      r = 1 << i;
    (r & e) | (n[i] & e) && (n[i] |= e), (t &= ~r);
  }
}
var Ot = 0;
function SR(n) {
  return (n &= -n), 1 < n ? (4 < n ? (n & 268435455 ? 16 : 536870912) : 4) : 1;
}
var MR,
  wA,
  ER,
  wR,
  TR,
  Mx = !1,
  Jd = [],
  Bo = null,
  Lo = null,
  Io = null,
  Nf = new Map(),
  Uf = new Map(),
  To = [],
  sF =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function AE(n, e) {
  switch (n) {
    case "focusin":
    case "focusout":
      Bo = null;
      break;
    case "dragenter":
    case "dragleave":
      Lo = null;
      break;
    case "mouseover":
    case "mouseout":
      Io = null;
      break;
    case "pointerover":
    case "pointerout":
      Nf.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Uf.delete(e.pointerId);
  }
}
function Du(n, e, t, i, r, s) {
  return n === null || n.nativeEvent !== s
    ? ((n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r],
      }),
      e !== null && ((e = xh(e)), e !== null && wA(e)),
      n)
    : ((n.eventSystemFlags |= i),
      (e = n.targetContainers),
      r !== null && e.indexOf(r) === -1 && e.push(r),
      n);
}
function oF(n, e, t, i, r) {
  switch (e) {
    case "focusin":
      return (Bo = Du(Bo, n, e, t, i, r)), !0;
    case "dragenter":
      return (Lo = Du(Lo, n, e, t, i, r)), !0;
    case "mouseover":
      return (Io = Du(Io, n, e, t, i, r)), !0;
    case "pointerover":
      var s = r.pointerId;
      return Nf.set(s, Du(Nf.get(s) || null, n, e, t, i, r)), !0;
    case "gotpointercapture":
      return (
        (s = r.pointerId), Uf.set(s, Du(Uf.get(s) || null, n, e, t, i, r)), !0
      );
  }
  return !1;
}
function CR(n) {
  var e = Ua(n.target);
  if (e !== null) {
    var t = fl(e);
    if (t !== null) {
      if (((e = t.tag), e === 13)) {
        if (((e = mR(t)), e !== null)) {
          (n.blockedOn = e),
            TR(n.priority, function () {
              ER(t);
            });
          return;
        }
      } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
        n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
        return;
      }
    }
  }
  n.blockedOn = null;
}
function nm(n) {
  if (n.blockedOn !== null) return !1;
  for (var e = n.targetContainers; 0 < e.length; ) {
    var t = Ex(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
    if (t === null) {
      t = n.nativeEvent;
      var i = new t.constructor(t.type, t);
      (yx = i), t.target.dispatchEvent(i), (yx = null);
    } else return (e = xh(t)), e !== null && wA(e), (n.blockedOn = t), !1;
    e.shift();
  }
  return !0;
}
function SE(n, e, t) {
  nm(n) && t.delete(e);
}
function aF() {
  (Mx = !1),
    Bo !== null && nm(Bo) && (Bo = null),
    Lo !== null && nm(Lo) && (Lo = null),
    Io !== null && nm(Io) && (Io = null),
    Nf.forEach(SE),
    Uf.forEach(SE);
}
function Fu(n, e) {
  n.blockedOn === e &&
    ((n.blockedOn = null),
    Mx ||
      ((Mx = !0),
      Zi.unstable_scheduleCallback(Zi.unstable_NormalPriority, aF)));
}
function Of(n) {
  function e(r) {
    return Fu(r, n);
  }
  if (0 < Jd.length) {
    Fu(Jd[0], n);
    for (var t = 1; t < Jd.length; t++) {
      var i = Jd[t];
      i.blockedOn === n && (i.blockedOn = null);
    }
  }
  for (
    Bo !== null && Fu(Bo, n),
      Lo !== null && Fu(Lo, n),
      Io !== null && Fu(Io, n),
      Nf.forEach(e),
      Uf.forEach(e),
      t = 0;
    t < To.length;
    t++
  )
    (i = To[t]), i.blockedOn === n && (i.blockedOn = null);
  for (; 0 < To.length && ((t = To[0]), t.blockedOn === null); )
    CR(t), t.blockedOn === null && To.shift();
}
var Rc = to.ReactCurrentBatchConfig,
  Rm = !0;
function lF(n, e, t, i) {
  var r = Ot,
    s = Rc.transition;
  Rc.transition = null;
  try {
    (Ot = 1), TA(n, e, t, i);
  } finally {
    (Ot = r), (Rc.transition = s);
  }
}
function cF(n, e, t, i) {
  var r = Ot,
    s = Rc.transition;
  Rc.transition = null;
  try {
    (Ot = 4), TA(n, e, t, i);
  } finally {
    (Ot = r), (Rc.transition = s);
  }
}
function TA(n, e, t, i) {
  if (Rm) {
    var r = Ex(n, e, t, i);
    if (r === null) Hv(n, e, i, Pm, t), AE(n, i);
    else if (oF(r, n, e, t, i)) i.stopPropagation();
    else if ((AE(n, i), e & 4 && -1 < sF.indexOf(n))) {
      for (; r !== null; ) {
        var s = xh(r);
        if (
          (s !== null && MR(s),
          (s = Ex(n, e, t, i)),
          s === null && Hv(n, e, i, Pm, t),
          s === r)
        )
          break;
        r = s;
      }
      r !== null && i.stopPropagation();
    } else Hv(n, e, i, null, t);
  }
}
var Pm = null;
function Ex(n, e, t, i) {
  if (((Pm = null), (n = SA(i)), (n = Ua(n)), n !== null))
    if (((e = fl(n)), e === null)) n = null;
    else if (((t = e.tag), t === 13)) {
      if (((n = mR(e)), n !== null)) return n;
      n = null;
    } else if (t === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      n = null;
    } else e !== n && (n = null);
  return (Pm = n), null;
}
function bR(n) {
  switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (Q3()) {
        case MA:
          return 1;
        case xR:
          return 4;
        case Cm:
        case q3:
          return 16;
        case _R:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var bo = null,
  CA = null,
  im = null;
function RR() {
  if (im) return im;
  var n,
    e = CA,
    t = e.length,
    i,
    r = "value" in bo ? bo.value : bo.textContent,
    s = r.length;
  for (n = 0; n < t && e[n] === r[n]; n++);
  var o = t - n;
  for (i = 1; i <= o && e[t - i] === r[s - i]; i++);
  return (im = r.slice(n, 1 < i ? 1 - i : void 0));
}
function rm(n) {
  var e = n.keyCode;
  return (
    "charCode" in n
      ? ((n = n.charCode), n === 0 && e === 13 && (n = 13))
      : (n = e),
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
  );
}
function Kd() {
  return !0;
}
function ME() {
  return !1;
}
function ir(n) {
  function e(t, i, r, s, o) {
    (this._reactName = t),
      (this._targetInst = r),
      (this.type = i),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null);
    for (var a in n)
      n.hasOwnProperty(a) && ((t = n[a]), (this[a] = t ? t(s) : s[a]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? Kd
        : ME),
      (this.isPropagationStopped = ME),
      this
    );
  }
  return (
    un(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var t = this.nativeEvent;
        t &&
          (t.preventDefault
            ? t.preventDefault()
            : typeof t.returnValue != "unknown" && (t.returnValue = !1),
          (this.isDefaultPrevented = Kd));
      },
      stopPropagation: function () {
        var t = this.nativeEvent;
        t &&
          (t.stopPropagation
            ? t.stopPropagation()
            : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
          (this.isPropagationStopped = Kd));
      },
      persist: function () {},
      isPersistent: Kd,
    }),
    e
  );
}
var ru = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  bA = ir(ru),
  yh = un({}, ru, { view: 0, detail: 0 }),
  uF = ir(yh),
  Bv,
  Lv,
  Nu,
  mg = un({}, yh, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: RA,
    button: 0,
    buttons: 0,
    relatedTarget: function (n) {
      return n.relatedTarget === void 0
        ? n.fromElement === n.srcElement
          ? n.toElement
          : n.fromElement
        : n.relatedTarget;
    },
    movementX: function (n) {
      return "movementX" in n
        ? n.movementX
        : (n !== Nu &&
            (Nu && n.type === "mousemove"
              ? ((Bv = n.screenX - Nu.screenX), (Lv = n.screenY - Nu.screenY))
              : (Lv = Bv = 0),
            (Nu = n)),
          Bv);
    },
    movementY: function (n) {
      return "movementY" in n ? n.movementY : Lv;
    },
  }),
  EE = ir(mg),
  fF = un({}, mg, { dataTransfer: 0 }),
  hF = ir(fF),
  dF = un({}, yh, { relatedTarget: 0 }),
  Iv = ir(dF),
  pF = un({}, ru, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  mF = ir(pF),
  gF = un({}, ru, {
    clipboardData: function (n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    },
  }),
  vF = ir(gF),
  yF = un({}, ru, { data: 0 }),
  wE = ir(yF),
  xF = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  _F = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  AF = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function SF(n) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(n) : (n = AF[n]) ? !!e[n] : !1;
}
function RA() {
  return SF;
}
var MF = un({}, yh, {
    key: function (n) {
      if (n.key) {
        var e = xF[n.key] || n.key;
        if (e !== "Unidentified") return e;
      }
      return n.type === "keypress"
        ? ((n = rm(n)), n === 13 ? "Enter" : String.fromCharCode(n))
        : n.type === "keydown" || n.type === "keyup"
        ? _F[n.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: RA,
    charCode: function (n) {
      return n.type === "keypress" ? rm(n) : 0;
    },
    keyCode: function (n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function (n) {
      return n.type === "keypress"
        ? rm(n)
        : n.type === "keydown" || n.type === "keyup"
        ? n.keyCode
        : 0;
    },
  }),
  EF = ir(MF),
  wF = un({}, mg, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  TE = ir(wF),
  TF = un({}, yh, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: RA,
  }),
  CF = ir(TF),
  bF = un({}, ru, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  RF = ir(bF),
  PF = un({}, mg, {
    deltaX: function (n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function (n) {
      return "deltaY" in n
        ? n.deltaY
        : "wheelDeltaY" in n
        ? -n.wheelDeltaY
        : "wheelDelta" in n
        ? -n.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  BF = ir(PF),
  LF = [9, 13, 27, 32],
  PA = Ys && "CompositionEvent" in window,
  gf = null;
Ys && "documentMode" in document && (gf = document.documentMode);
var IF = Ys && "TextEvent" in window && !gf,
  PR = Ys && (!PA || (gf && 8 < gf && 11 >= gf)),
  CE = String.fromCharCode(32),
  bE = !1;
function BR(n, e) {
  switch (n) {
    case "keyup":
      return LF.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function LR(n) {
  return (n = n.detail), typeof n == "object" && "data" in n ? n.data : null;
}
var ac = !1;
function DF(n, e) {
  switch (n) {
    case "compositionend":
      return LR(e);
    case "keypress":
      return e.which !== 32 ? null : ((bE = !0), CE);
    case "textInput":
      return (n = e.data), n === CE && bE ? null : n;
    default:
      return null;
  }
}
function FF(n, e) {
  if (ac)
    return n === "compositionend" || (!PA && BR(n, e))
      ? ((n = RR()), (im = CA = bo = null), (ac = !1), n)
      : null;
  switch (n) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return PR && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var NF = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function RE(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return e === "input" ? !!NF[n.type] : e === "textarea";
}
function IR(n, e, t, i) {
  uR(i),
    (e = Bm(e, "onChange")),
    0 < e.length &&
      ((t = new bA("onChange", "change", null, t, i)),
      n.push({ event: t, listeners: e }));
}
var vf = null,
  kf = null;
function UF(n) {
  WR(n, 0);
}
function gg(n) {
  var e = uc(n);
  if (iR(e)) return n;
}
function OF(n, e) {
  if (n === "change") return e;
}
var DR = !1;
if (Ys) {
  var Dv;
  if (Ys) {
    var Fv = "oninput" in document;
    if (!Fv) {
      var PE = document.createElement("div");
      PE.setAttribute("oninput", "return;"),
        (Fv = typeof PE.oninput == "function");
    }
    Dv = Fv;
  } else Dv = !1;
  DR = Dv && (!document.documentMode || 9 < document.documentMode);
}
function BE() {
  vf && (vf.detachEvent("onpropertychange", FR), (kf = vf = null));
}
function FR(n) {
  if (n.propertyName === "value" && gg(kf)) {
    var e = [];
    IR(e, kf, n, SA(n)), pR(UF, e);
  }
}
function kF(n, e, t) {
  n === "focusin"
    ? (BE(), (vf = e), (kf = t), vf.attachEvent("onpropertychange", FR))
    : n === "focusout" && BE();
}
function HF(n) {
  if (n === "selectionchange" || n === "keyup" || n === "keydown")
    return gg(kf);
}
function zF(n, e) {
  if (n === "click") return gg(e);
}
function GF(n, e) {
  if (n === "input" || n === "change") return gg(e);
}
function VF(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var jr = typeof Object.is == "function" ? Object.is : VF;
function Hf(n, e) {
  if (jr(n, e)) return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  var t = Object.keys(n),
    i = Object.keys(e);
  if (t.length !== i.length) return !1;
  for (i = 0; i < t.length; i++) {
    var r = t[i];
    if (!ox.call(e, r) || !jr(n[r], e[r])) return !1;
  }
  return !0;
}
function LE(n) {
  for (; n && n.firstChild; ) n = n.firstChild;
  return n;
}
function IE(n, e) {
  var t = LE(n);
  n = 0;
  for (var i; t; ) {
    if (t.nodeType === 3) {
      if (((i = n + t.textContent.length), n <= e && i >= e))
        return { node: t, offset: e - n };
      n = i;
    }
    e: {
      for (; t; ) {
        if (t.nextSibling) {
          t = t.nextSibling;
          break e;
        }
        t = t.parentNode;
      }
      t = void 0;
    }
    t = LE(t);
  }
}
function NR(n, e) {
  return n && e
    ? n === e
      ? !0
      : n && n.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? NR(n, e.parentNode)
      : "contains" in n
      ? n.contains(e)
      : n.compareDocumentPosition
      ? !!(n.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function UR() {
  for (var n = window, e = Em(); e instanceof n.HTMLIFrameElement; ) {
    try {
      var t = typeof e.contentWindow.location.href == "string";
    } catch {
      t = !1;
    }
    if (t) n = e.contentWindow;
    else break;
    e = Em(n.document);
  }
  return e;
}
function BA(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (n.type === "text" ||
        n.type === "search" ||
        n.type === "tel" ||
        n.type === "url" ||
        n.type === "password")) ||
      e === "textarea" ||
      n.contentEditable === "true")
  );
}
function WF(n) {
  var e = UR(),
    t = n.focusedElem,
    i = n.selectionRange;
  if (
    e !== t &&
    t &&
    t.ownerDocument &&
    NR(t.ownerDocument.documentElement, t)
  ) {
    if (i !== null && BA(t)) {
      if (
        ((e = i.start),
        (n = i.end),
        n === void 0 && (n = e),
        "selectionStart" in t)
      )
        (t.selectionStart = e), (t.selectionEnd = Math.min(n, t.value.length));
      else if (
        ((n = ((e = t.ownerDocument || document) && e.defaultView) || window),
        n.getSelection)
      ) {
        n = n.getSelection();
        var r = t.textContent.length,
          s = Math.min(i.start, r);
        (i = i.end === void 0 ? s : Math.min(i.end, r)),
          !n.extend && s > i && ((r = i), (i = s), (s = r)),
          (r = IE(t, s));
        var o = IE(t, i);
        r &&
          o &&
          (n.rangeCount !== 1 ||
            n.anchorNode !== r.node ||
            n.anchorOffset !== r.offset ||
            n.focusNode !== o.node ||
            n.focusOffset !== o.offset) &&
          ((e = e.createRange()),
          e.setStart(r.node, r.offset),
          n.removeAllRanges(),
          s > i
            ? (n.addRange(e), n.extend(o.node, o.offset))
            : (e.setEnd(o.node, o.offset), n.addRange(e)));
      }
    }
    for (e = [], n = t; (n = n.parentNode); )
      n.nodeType === 1 &&
        e.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
    for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)
      (n = e[t]),
        (n.element.scrollLeft = n.left),
        (n.element.scrollTop = n.top);
  }
}
var jF = Ys && "documentMode" in document && 11 >= document.documentMode,
  lc = null,
  wx = null,
  yf = null,
  Tx = !1;
function DE(n, e, t) {
  var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
  Tx ||
    lc == null ||
    lc !== Em(i) ||
    ((i = lc),
    "selectionStart" in i && BA(i)
      ? (i = { start: i.selectionStart, end: i.selectionEnd })
      : ((i = (
          (i.ownerDocument && i.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (i = {
          anchorNode: i.anchorNode,
          anchorOffset: i.anchorOffset,
          focusNode: i.focusNode,
          focusOffset: i.focusOffset,
        })),
    (yf && Hf(yf, i)) ||
      ((yf = i),
      (i = Bm(wx, "onSelect")),
      0 < i.length &&
        ((e = new bA("onSelect", "select", null, e, t)),
        n.push({ event: e, listeners: i }),
        (e.target = lc))));
}
function Yd(n, e) {
  var t = {};
  return (
    (t[n.toLowerCase()] = e.toLowerCase()),
    (t["Webkit" + n] = "webkit" + e),
    (t["Moz" + n] = "moz" + e),
    t
  );
}
var cc = {
    animationend: Yd("Animation", "AnimationEnd"),
    animationiteration: Yd("Animation", "AnimationIteration"),
    animationstart: Yd("Animation", "AnimationStart"),
    transitionend: Yd("Transition", "TransitionEnd"),
  },
  Nv = {},
  OR = {};
Ys &&
  ((OR = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete cc.animationend.animation,
    delete cc.animationiteration.animation,
    delete cc.animationstart.animation),
  "TransitionEvent" in window || delete cc.transitionend.transition);
function vg(n) {
  if (Nv[n]) return Nv[n];
  if (!cc[n]) return n;
  var e = cc[n],
    t;
  for (t in e) if (e.hasOwnProperty(t) && t in OR) return (Nv[n] = e[t]);
  return n;
}
var kR = vg("animationend"),
  HR = vg("animationiteration"),
  zR = vg("animationstart"),
  GR = vg("transitionend"),
  VR = new Map(),
  FE =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function ea(n, e) {
  VR.set(n, e), ul(e, [n]);
}
for (var Uv = 0; Uv < FE.length; Uv++) {
  var Ov = FE[Uv],
    XF = Ov.toLowerCase(),
    JF = Ov[0].toUpperCase() + Ov.slice(1);
  ea(XF, "on" + JF);
}
ea(kR, "onAnimationEnd");
ea(HR, "onAnimationIteration");
ea(zR, "onAnimationStart");
ea("dblclick", "onDoubleClick");
ea("focusin", "onFocus");
ea("focusout", "onBlur");
ea(GR, "onTransitionEnd");
Oc("onMouseEnter", ["mouseout", "mouseover"]);
Oc("onMouseLeave", ["mouseout", "mouseover"]);
Oc("onPointerEnter", ["pointerout", "pointerover"]);
Oc("onPointerLeave", ["pointerout", "pointerover"]);
ul(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
ul(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
ul("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
ul(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
ul(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
ul(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var uf =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  KF = new Set("cancel close invalid load scroll toggle".split(" ").concat(uf));
function NE(n, e, t) {
  var i = n.type || "unknown-event";
  (n.currentTarget = t), X3(i, e, void 0, n), (n.currentTarget = null);
}
function WR(n, e) {
  e = (e & 4) !== 0;
  for (var t = 0; t < n.length; t++) {
    var i = n[t],
      r = i.event;
    i = i.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var o = i.length - 1; 0 <= o; o--) {
          var a = i[o],
            l = a.instance,
            u = a.currentTarget;
          if (((a = a.listener), l !== s && r.isPropagationStopped())) break e;
          NE(r, a, u), (s = l);
        }
      else
        for (o = 0; o < i.length; o++) {
          if (
            ((a = i[o]),
            (l = a.instance),
            (u = a.currentTarget),
            (a = a.listener),
            l !== s && r.isPropagationStopped())
          )
            break e;
          NE(r, a, u), (s = l);
        }
    }
  }
  if (Tm) throw ((n = Ax), (Tm = !1), (Ax = null), n);
}
function Kt(n, e) {
  var t = e[Bx];
  t === void 0 && (t = e[Bx] = new Set());
  var i = n + "__bubble";
  t.has(i) || (jR(e, n, 2, !1), t.add(i));
}
function kv(n, e, t) {
  var i = 0;
  e && (i |= 4), jR(t, n, i, e);
}
var Qd = "_reactListening" + Math.random().toString(36).slice(2);
function zf(n) {
  if (!n[Qd]) {
    (n[Qd] = !0),
      Zb.forEach(function (t) {
        t !== "selectionchange" && (KF.has(t) || kv(t, !1, n), kv(t, !0, n));
      });
    var e = n.nodeType === 9 ? n : n.ownerDocument;
    e === null || e[Qd] || ((e[Qd] = !0), kv("selectionchange", !1, e));
  }
}
function jR(n, e, t, i) {
  switch (bR(e)) {
    case 1:
      var r = lF;
      break;
    case 4:
      r = cF;
      break;
    default:
      r = TA;
  }
  (t = r.bind(null, e, t, n)),
    (r = void 0),
    !_x ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (r = !0),
    i
      ? r !== void 0
        ? n.addEventListener(e, t, { capture: !0, passive: r })
        : n.addEventListener(e, t, !0)
      : r !== void 0
      ? n.addEventListener(e, t, { passive: r })
      : n.addEventListener(e, t, !1);
}
function Hv(n, e, t, i, r) {
  var s = i;
  if (!(e & 1) && !(e & 2) && i !== null)
    e: for (;;) {
      if (i === null) return;
      var o = i.tag;
      if (o === 3 || o === 4) {
        var a = i.stateNode.containerInfo;
        if (a === r || (a.nodeType === 8 && a.parentNode === r)) break;
        if (o === 4)
          for (o = i.return; o !== null; ) {
            var l = o.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = o.stateNode.containerInfo),
              l === r || (l.nodeType === 8 && l.parentNode === r))
            )
              return;
            o = o.return;
          }
        for (; a !== null; ) {
          if (((o = Ua(a)), o === null)) return;
          if (((l = o.tag), l === 5 || l === 6)) {
            i = s = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      i = i.return;
    }
  pR(function () {
    var u = s,
      h = SA(t),
      d = [];
    e: {
      var p = VR.get(n);
      if (p !== void 0) {
        var m = bA,
          y = n;
        switch (n) {
          case "keypress":
            if (rm(t) === 0) break e;
          case "keydown":
          case "keyup":
            m = EF;
            break;
          case "focusin":
            (y = "focus"), (m = Iv);
            break;
          case "focusout":
            (y = "blur"), (m = Iv);
            break;
          case "beforeblur":
          case "afterblur":
            m = Iv;
            break;
          case "click":
            if (t.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            m = EE;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            m = hF;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            m = CF;
            break;
          case kR:
          case HR:
          case zR:
            m = mF;
            break;
          case GR:
            m = RF;
            break;
          case "scroll":
            m = uF;
            break;
          case "wheel":
            m = BF;
            break;
          case "copy":
          case "cut":
          case "paste":
            m = vF;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            m = TE;
        }
        var M = (e & 4) !== 0,
          A = !M && n === "scroll",
          g = M ? (p !== null ? p + "Capture" : null) : p;
        M = [];
        for (var x = u, _; x !== null; ) {
          _ = x;
          var E = _.stateNode;
          if (
            (_.tag === 5 &&
              E !== null &&
              ((_ = E),
              g !== null && ((E = Ff(x, g)), E != null && M.push(Gf(x, E, _)))),
            A)
          )
            break;
          x = x.return;
        }
        0 < M.length &&
          ((p = new m(p, y, null, t, h)), d.push({ event: p, listeners: M }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((p = n === "mouseover" || n === "pointerover"),
          (m = n === "mouseout" || n === "pointerout"),
          p &&
            t !== yx &&
            (y = t.relatedTarget || t.fromElement) &&
            (Ua(y) || y[Qs]))
        )
          break e;
        if (
          (m || p) &&
          ((p =
            h.window === h
              ? h
              : (p = h.ownerDocument)
              ? p.defaultView || p.parentWindow
              : window),
          m
            ? ((y = t.relatedTarget || t.toElement),
              (m = u),
              (y = y ? Ua(y) : null),
              y !== null &&
                ((A = fl(y)), y !== A || (y.tag !== 5 && y.tag !== 6)) &&
                (y = null))
            : ((m = null), (y = u)),
          m !== y)
        ) {
          if (
            ((M = EE),
            (E = "onMouseLeave"),
            (g = "onMouseEnter"),
            (x = "mouse"),
            (n === "pointerout" || n === "pointerover") &&
              ((M = TE),
              (E = "onPointerLeave"),
              (g = "onPointerEnter"),
              (x = "pointer")),
            (A = m == null ? p : uc(m)),
            (_ = y == null ? p : uc(y)),
            (p = new M(E, x + "leave", m, t, h)),
            (p.target = A),
            (p.relatedTarget = _),
            (E = null),
            Ua(h) === u &&
              ((M = new M(g, x + "enter", y, t, h)),
              (M.target = _),
              (M.relatedTarget = A),
              (E = M)),
            (A = E),
            m && y)
          )
            t: {
              for (M = m, g = y, x = 0, _ = M; _; _ = Ll(_)) x++;
              for (_ = 0, E = g; E; E = Ll(E)) _++;
              for (; 0 < x - _; ) (M = Ll(M)), x--;
              for (; 0 < _ - x; ) (g = Ll(g)), _--;
              for (; x--; ) {
                if (M === g || (g !== null && M === g.alternate)) break t;
                (M = Ll(M)), (g = Ll(g));
              }
              M = null;
            }
          else M = null;
          m !== null && UE(d, p, m, M, !1),
            y !== null && A !== null && UE(d, A, y, M, !0);
        }
      }
      e: {
        if (
          ((p = u ? uc(u) : window),
          (m = p.nodeName && p.nodeName.toLowerCase()),
          m === "select" || (m === "input" && p.type === "file"))
        )
          var T = OF;
        else if (RE(p))
          if (DR) T = GF;
          else {
            T = HF;
            var R = kF;
          }
        else
          (m = p.nodeName) &&
            m.toLowerCase() === "input" &&
            (p.type === "checkbox" || p.type === "radio") &&
            (T = zF);
        if (T && (T = T(n, u))) {
          IR(d, T, t, h);
          break e;
        }
        R && R(n, p, u),
          n === "focusout" &&
            (R = p._wrapperState) &&
            R.controlled &&
            p.type === "number" &&
            dx(p, "number", p.value);
      }
      switch (((R = u ? uc(u) : window), n)) {
        case "focusin":
          (RE(R) || R.contentEditable === "true") &&
            ((lc = R), (wx = u), (yf = null));
          break;
        case "focusout":
          yf = wx = lc = null;
          break;
        case "mousedown":
          Tx = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (Tx = !1), DE(d, t, h);
          break;
        case "selectionchange":
          if (jF) break;
        case "keydown":
        case "keyup":
          DE(d, t, h);
      }
      var P;
      if (PA)
        e: {
          switch (n) {
            case "compositionstart":
              var B = "onCompositionStart";
              break e;
            case "compositionend":
              B = "onCompositionEnd";
              break e;
            case "compositionupdate":
              B = "onCompositionUpdate";
              break e;
          }
          B = void 0;
        }
      else
        ac
          ? BR(n, t) && (B = "onCompositionEnd")
          : n === "keydown" && t.keyCode === 229 && (B = "onCompositionStart");
      B &&
        (PR &&
          t.locale !== "ko" &&
          (ac || B !== "onCompositionStart"
            ? B === "onCompositionEnd" && ac && (P = RR())
            : ((bo = h),
              (CA = "value" in bo ? bo.value : bo.textContent),
              (ac = !0))),
        (R = Bm(u, B)),
        0 < R.length &&
          ((B = new wE(B, n, null, t, h)),
          d.push({ event: B, listeners: R }),
          P ? (B.data = P) : ((P = LR(t)), P !== null && (B.data = P)))),
        (P = IF ? DF(n, t) : FF(n, t)) &&
          ((u = Bm(u, "onBeforeInput")),
          0 < u.length &&
            ((h = new wE("onBeforeInput", "beforeinput", null, t, h)),
            d.push({ event: h, listeners: u }),
            (h.data = P)));
    }
    WR(d, e);
  });
}
function Gf(n, e, t) {
  return { instance: n, listener: e, currentTarget: t };
}
function Bm(n, e) {
  for (var t = e + "Capture", i = []; n !== null; ) {
    var r = n,
      s = r.stateNode;
    r.tag === 5 &&
      s !== null &&
      ((r = s),
      (s = Ff(n, t)),
      s != null && i.unshift(Gf(n, s, r)),
      (s = Ff(n, e)),
      s != null && i.push(Gf(n, s, r))),
      (n = n.return);
  }
  return i;
}
function Ll(n) {
  if (n === null) return null;
  do n = n.return;
  while (n && n.tag !== 5);
  return n || null;
}
function UE(n, e, t, i, r) {
  for (var s = e._reactName, o = []; t !== null && t !== i; ) {
    var a = t,
      l = a.alternate,
      u = a.stateNode;
    if (l !== null && l === i) break;
    a.tag === 5 &&
      u !== null &&
      ((a = u),
      r
        ? ((l = Ff(t, s)), l != null && o.unshift(Gf(t, l, a)))
        : r || ((l = Ff(t, s)), l != null && o.push(Gf(t, l, a)))),
      (t = t.return);
  }
  o.length !== 0 && n.push({ event: e, listeners: o });
}
var YF = /\r\n?/g,
  QF = /\u0000|\uFFFD/g;
function OE(n) {
  return (typeof n == "string" ? n : "" + n)
    .replace(
      YF,
      `
`
    )
    .replace(QF, "");
}
function qd(n, e, t) {
  if (((e = OE(e)), OE(n) !== e && t)) throw Error(Ce(425));
}
function Lm() {}
var Cx = null,
  bx = null;
function Rx(n, e) {
  return (
    n === "textarea" ||
    n === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var Px = typeof setTimeout == "function" ? setTimeout : void 0,
  qF = typeof clearTimeout == "function" ? clearTimeout : void 0,
  kE = typeof Promise == "function" ? Promise : void 0,
  ZF =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof kE < "u"
      ? function (n) {
          return kE.resolve(null).then(n).catch($F);
        }
      : Px;
function $F(n) {
  setTimeout(function () {
    throw n;
  });
}
function zv(n, e) {
  var t = e,
    i = 0;
  do {
    var r = t.nextSibling;
    if ((n.removeChild(t), r && r.nodeType === 8))
      if (((t = r.data), t === "/$")) {
        if (i === 0) {
          n.removeChild(r), Of(e);
          return;
        }
        i--;
      } else (t !== "$" && t !== "$?" && t !== "$!") || i++;
    t = r;
  } while (t);
  Of(e);
}
function Do(n) {
  for (; n != null; n = n.nextSibling) {
    var e = n.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = n.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return n;
}
function HE(n) {
  n = n.previousSibling;
  for (var e = 0; n; ) {
    if (n.nodeType === 8) {
      var t = n.data;
      if (t === "$" || t === "$!" || t === "$?") {
        if (e === 0) return n;
        e--;
      } else t === "/$" && e++;
    }
    n = n.previousSibling;
  }
  return null;
}
var su = Math.random().toString(36).slice(2),
  us = "__reactFiber$" + su,
  Vf = "__reactProps$" + su,
  Qs = "__reactContainer$" + su,
  Bx = "__reactEvents$" + su,
  eN = "__reactListeners$" + su,
  tN = "__reactHandles$" + su;
function Ua(n) {
  var e = n[us];
  if (e) return e;
  for (var t = n.parentNode; t; ) {
    if ((e = t[Qs] || t[us])) {
      if (
        ((t = e.alternate),
        e.child !== null || (t !== null && t.child !== null))
      )
        for (n = HE(n); n !== null; ) {
          if ((t = n[us])) return t;
          n = HE(n);
        }
      return e;
    }
    (n = t), (t = n.parentNode);
  }
  return null;
}
function xh(n) {
  return (
    (n = n[us] || n[Qs]),
    !n || (n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3) ? null : n
  );
}
function uc(n) {
  if (n.tag === 5 || n.tag === 6) return n.stateNode;
  throw Error(Ce(33));
}
function yg(n) {
  return n[Vf] || null;
}
var Lx = [],
  fc = -1;
function ta(n) {
  return { current: n };
}
function Qt(n) {
  0 > fc || ((n.current = Lx[fc]), (Lx[fc] = null), fc--);
}
function jt(n, e) {
  fc++, (Lx[fc] = n.current), (n.current = e);
}
var Xo = {},
  li = ta(Xo),
  Pi = ta(!1),
  tl = Xo;
function kc(n, e) {
  var t = n.type.contextTypes;
  if (!t) return Xo;
  var i = n.stateNode;
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
    return i.__reactInternalMemoizedMaskedChildContext;
  var r = {},
    s;
  for (s in t) r[s] = e[s];
  return (
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = e),
      (n.__reactInternalMemoizedMaskedChildContext = r)),
    r
  );
}
function Bi(n) {
  return (n = n.childContextTypes), n != null;
}
function Im() {
  Qt(Pi), Qt(li);
}
function zE(n, e, t) {
  if (li.current !== Xo) throw Error(Ce(168));
  jt(li, e), jt(Pi, t);
}
function XR(n, e, t) {
  var i = n.stateNode;
  if (((e = e.childContextTypes), typeof i.getChildContext != "function"))
    return t;
  i = i.getChildContext();
  for (var r in i) if (!(r in e)) throw Error(Ce(108, k3(n) || "Unknown", r));
  return un({}, t, i);
}
function Dm(n) {
  return (
    (n =
      ((n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext) || Xo),
    (tl = li.current),
    jt(li, n),
    jt(Pi, Pi.current),
    !0
  );
}
function GE(n, e, t) {
  var i = n.stateNode;
  if (!i) throw Error(Ce(169));
  t
    ? ((n = XR(n, e, tl)),
      (i.__reactInternalMemoizedMergedChildContext = n),
      Qt(Pi),
      Qt(li),
      jt(li, n))
    : Qt(Pi),
    jt(Pi, t);
}
var Os = null,
  xg = !1,
  Gv = !1;
function JR(n) {
  Os === null ? (Os = [n]) : Os.push(n);
}
function nN(n) {
  (xg = !0), JR(n);
}
function na() {
  if (!Gv && Os !== null) {
    Gv = !0;
    var n = 0,
      e = Ot;
    try {
      var t = Os;
      for (Ot = 1; n < t.length; n++) {
        var i = t[n];
        do i = i(!0);
        while (i !== null);
      }
      (Os = null), (xg = !1);
    } catch (r) {
      throw (Os !== null && (Os = Os.slice(n + 1)), yR(MA, na), r);
    } finally {
      (Ot = e), (Gv = !1);
    }
  }
  return null;
}
var hc = [],
  dc = 0,
  Fm = null,
  Nm = 0,
  xr = [],
  _r = 0,
  nl = null,
  Hs = 1,
  zs = "";
function ba(n, e) {
  (hc[dc++] = Nm), (hc[dc++] = Fm), (Fm = n), (Nm = e);
}
function KR(n, e, t) {
  (xr[_r++] = Hs), (xr[_r++] = zs), (xr[_r++] = nl), (nl = n);
  var i = Hs;
  n = zs;
  var r = 32 - Hr(i) - 1;
  (i &= ~(1 << r)), (t += 1);
  var s = 32 - Hr(e) + r;
  if (30 < s) {
    var o = r - (r % 5);
    (s = (i & ((1 << o) - 1)).toString(32)),
      (i >>= o),
      (r -= o),
      (Hs = (1 << (32 - Hr(e) + r)) | (t << r) | i),
      (zs = s + n);
  } else (Hs = (1 << s) | (t << r) | i), (zs = n);
}
function LA(n) {
  n.return !== null && (ba(n, 1), KR(n, 1, 0));
}
function IA(n) {
  for (; n === Fm; )
    (Fm = hc[--dc]), (hc[dc] = null), (Nm = hc[--dc]), (hc[dc] = null);
  for (; n === nl; )
    (nl = xr[--_r]),
      (xr[_r] = null),
      (zs = xr[--_r]),
      (xr[_r] = null),
      (Hs = xr[--_r]),
      (xr[_r] = null);
}
var Qi = null,
  ji = null,
  Zt = !1,
  Or = null;
function YR(n, e) {
  var t = Sr(5, null, null, 0);
  (t.elementType = "DELETED"),
    (t.stateNode = e),
    (t.return = n),
    (e = n.deletions),
    e === null ? ((n.deletions = [t]), (n.flags |= 16)) : e.push(t);
}
function VE(n, e) {
  switch (n.tag) {
    case 5:
      var t = n.type;
      return (
        (e =
          e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((n.stateNode = e), (Qi = n), (ji = Do(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = n.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((n.stateNode = e), (Qi = n), (ji = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((t = nl !== null ? { id: Hs, overflow: zs } : null),
            (n.memoizedState = {
              dehydrated: e,
              treeContext: t,
              retryLane: 1073741824,
            }),
            (t = Sr(18, null, null, 0)),
            (t.stateNode = e),
            (t.return = n),
            (n.child = t),
            (Qi = n),
            (ji = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function Ix(n) {
  return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
}
function Dx(n) {
  if (Zt) {
    var e = ji;
    if (e) {
      var t = e;
      if (!VE(n, e)) {
        if (Ix(n)) throw Error(Ce(418));
        e = Do(t.nextSibling);
        var i = Qi;
        e && VE(n, e)
          ? YR(i, t)
          : ((n.flags = (n.flags & -4097) | 2), (Zt = !1), (Qi = n));
      }
    } else {
      if (Ix(n)) throw Error(Ce(418));
      (n.flags = (n.flags & -4097) | 2), (Zt = !1), (Qi = n);
    }
  }
}
function WE(n) {
  for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
    n = n.return;
  Qi = n;
}
function Zd(n) {
  if (n !== Qi) return !1;
  if (!Zt) return WE(n), (Zt = !0), !1;
  var e;
  if (
    ((e = n.tag !== 3) &&
      !(e = n.tag !== 5) &&
      ((e = n.type),
      (e = e !== "head" && e !== "body" && !Rx(n.type, n.memoizedProps))),
    e && (e = ji))
  ) {
    if (Ix(n)) throw (QR(), Error(Ce(418)));
    for (; e; ) YR(n, e), (e = Do(e.nextSibling));
  }
  if ((WE(n), n.tag === 13)) {
    if (((n = n.memoizedState), (n = n !== null ? n.dehydrated : null), !n))
      throw Error(Ce(317));
    e: {
      for (n = n.nextSibling, e = 0; n; ) {
        if (n.nodeType === 8) {
          var t = n.data;
          if (t === "/$") {
            if (e === 0) {
              ji = Do(n.nextSibling);
              break e;
            }
            e--;
          } else (t !== "$" && t !== "$!" && t !== "$?") || e++;
        }
        n = n.nextSibling;
      }
      ji = null;
    }
  } else ji = Qi ? Do(n.stateNode.nextSibling) : null;
  return !0;
}
function QR() {
  for (var n = ji; n; ) n = Do(n.nextSibling);
}
function Hc() {
  (ji = Qi = null), (Zt = !1);
}
function DA(n) {
  Or === null ? (Or = [n]) : Or.push(n);
}
var iN = to.ReactCurrentBatchConfig;
function Fr(n, e) {
  if (n && n.defaultProps) {
    (e = un({}, e)), (n = n.defaultProps);
    for (var t in n) e[t] === void 0 && (e[t] = n[t]);
    return e;
  }
  return e;
}
var Um = ta(null),
  Om = null,
  pc = null,
  FA = null;
function NA() {
  FA = pc = Om = null;
}
function UA(n) {
  var e = Um.current;
  Qt(Um), (n._currentValue = e);
}
function Fx(n, e, t) {
  for (; n !== null; ) {
    var i = n.alternate;
    if (
      ((n.childLanes & e) !== e
        ? ((n.childLanes |= e), i !== null && (i.childLanes |= e))
        : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
      n === t)
    )
      break;
    n = n.return;
  }
}
function Pc(n, e) {
  (Om = n),
    (FA = pc = null),
    (n = n.dependencies),
    n !== null &&
      n.firstContext !== null &&
      (n.lanes & e && (Ri = !0), (n.firstContext = null));
}
function Er(n) {
  var e = n._currentValue;
  if (FA !== n)
    if (((n = { context: n, memoizedValue: e, next: null }), pc === null)) {
      if (Om === null) throw Error(Ce(308));
      (pc = n), (Om.dependencies = { lanes: 0, firstContext: n });
    } else pc = pc.next = n;
  return e;
}
var Oa = null;
function OA(n) {
  Oa === null ? (Oa = [n]) : Oa.push(n);
}
function qR(n, e, t, i) {
  var r = e.interleaved;
  return (
    r === null ? ((t.next = t), OA(e)) : ((t.next = r.next), (r.next = t)),
    (e.interleaved = t),
    qs(n, i)
  );
}
function qs(n, e) {
  n.lanes |= e;
  var t = n.alternate;
  for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null; )
    (n.childLanes |= e),
      (t = n.alternate),
      t !== null && (t.childLanes |= e),
      (t = n),
      (n = n.return);
  return t.tag === 3 ? t.stateNode : null;
}
var So = !1;
function kA(n) {
  n.updateQueue = {
    baseState: n.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function ZR(n, e) {
  (n = n.updateQueue),
    e.updateQueue === n &&
      (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects,
      });
}
function js(n, e) {
  return {
    eventTime: n,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function Fo(n, e, t) {
  var i = n.updateQueue;
  if (i === null) return null;
  if (((i = i.shared), Bt & 2)) {
    var r = i.pending;
    return (
      r === null ? (e.next = e) : ((e.next = r.next), (r.next = e)),
      (i.pending = e),
      qs(n, t)
    );
  }
  return (
    (r = i.interleaved),
    r === null ? ((e.next = e), OA(i)) : ((e.next = r.next), (r.next = e)),
    (i.interleaved = e),
    qs(n, t)
  );
}
function sm(n, e, t) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (t & 4194240) !== 0))
  ) {
    var i = e.lanes;
    (i &= n.pendingLanes), (t |= i), (e.lanes = t), EA(n, t);
  }
}
function jE(n, e) {
  var t = n.updateQueue,
    i = n.alternate;
  if (i !== null && ((i = i.updateQueue), t === i)) {
    var r = null,
      s = null;
    if (((t = t.firstBaseUpdate), t !== null)) {
      do {
        var o = {
          eventTime: t.eventTime,
          lane: t.lane,
          tag: t.tag,
          payload: t.payload,
          callback: t.callback,
          next: null,
        };
        s === null ? (r = s = o) : (s = s.next = o), (t = t.next);
      } while (t !== null);
      s === null ? (r = s = e) : (s = s.next = e);
    } else r = s = e;
    (t = {
      baseState: i.baseState,
      firstBaseUpdate: r,
      lastBaseUpdate: s,
      shared: i.shared,
      effects: i.effects,
    }),
      (n.updateQueue = t);
    return;
  }
  (n = t.lastBaseUpdate),
    n === null ? (t.firstBaseUpdate = e) : (n.next = e),
    (t.lastBaseUpdate = e);
}
function km(n, e, t, i) {
  var r = n.updateQueue;
  So = !1;
  var s = r.firstBaseUpdate,
    o = r.lastBaseUpdate,
    a = r.shared.pending;
  if (a !== null) {
    r.shared.pending = null;
    var l = a,
      u = l.next;
    (l.next = null), o === null ? (s = u) : (o.next = u), (o = l);
    var h = n.alternate;
    h !== null &&
      ((h = h.updateQueue),
      (a = h.lastBaseUpdate),
      a !== o &&
        (a === null ? (h.firstBaseUpdate = u) : (a.next = u),
        (h.lastBaseUpdate = l)));
  }
  if (s !== null) {
    var d = r.baseState;
    (o = 0), (h = u = l = null), (a = s);
    do {
      var p = a.lane,
        m = a.eventTime;
      if ((i & p) === p) {
        h !== null &&
          (h = h.next =
            {
              eventTime: m,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var y = n,
            M = a;
          switch (((p = e), (m = t), M.tag)) {
            case 1:
              if (((y = M.payload), typeof y == "function")) {
                d = y.call(m, d, p);
                break e;
              }
              d = y;
              break e;
            case 3:
              y.flags = (y.flags & -65537) | 128;
            case 0:
              if (
                ((y = M.payload),
                (p = typeof y == "function" ? y.call(m, d, p) : y),
                p == null)
              )
                break e;
              d = un({}, d, p);
              break e;
            case 2:
              So = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((n.flags |= 64),
          (p = r.effects),
          p === null ? (r.effects = [a]) : p.push(a));
      } else
        (m = {
          eventTime: m,
          lane: p,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          h === null ? ((u = h = m), (l = d)) : (h = h.next = m),
          (o |= p);
      if (((a = a.next), a === null)) {
        if (((a = r.shared.pending), a === null)) break;
        (p = a),
          (a = p.next),
          (p.next = null),
          (r.lastBaseUpdate = p),
          (r.shared.pending = null);
      }
    } while (1);
    if (
      (h === null && (l = d),
      (r.baseState = l),
      (r.firstBaseUpdate = u),
      (r.lastBaseUpdate = h),
      (e = r.shared.interleaved),
      e !== null)
    ) {
      r = e;
      do (o |= r.lane), (r = r.next);
      while (r !== e);
    } else s === null && (r.shared.lanes = 0);
    (rl |= o), (n.lanes = o), (n.memoizedState = d);
  }
}
function XE(n, e, t) {
  if (((n = e.effects), (e.effects = null), n !== null))
    for (e = 0; e < n.length; e++) {
      var i = n[e],
        r = i.callback;
      if (r !== null) {
        if (((i.callback = null), (i = t), typeof r != "function"))
          throw Error(Ce(191, r));
        r.call(i);
      }
    }
}
var $R = new qb.Component().refs;
function Nx(n, e, t, i) {
  (e = n.memoizedState),
    (t = t(i, e)),
    (t = t == null ? e : un({}, e, t)),
    (n.memoizedState = t),
    n.lanes === 0 && (n.updateQueue.baseState = t);
}
var _g = {
  isMounted: function (n) {
    return (n = n._reactInternals) ? fl(n) === n : !1;
  },
  enqueueSetState: function (n, e, t) {
    n = n._reactInternals;
    var i = yi(),
      r = Uo(n),
      s = js(i, r);
    (s.payload = e),
      t != null && (s.callback = t),
      (e = Fo(n, s, r)),
      e !== null && (zr(e, n, r, i), sm(e, n, r));
  },
  enqueueReplaceState: function (n, e, t) {
    n = n._reactInternals;
    var i = yi(),
      r = Uo(n),
      s = js(i, r);
    (s.tag = 1),
      (s.payload = e),
      t != null && (s.callback = t),
      (e = Fo(n, s, r)),
      e !== null && (zr(e, n, r, i), sm(e, n, r));
  },
  enqueueForceUpdate: function (n, e) {
    n = n._reactInternals;
    var t = yi(),
      i = Uo(n),
      r = js(t, i);
    (r.tag = 2),
      e != null && (r.callback = e),
      (e = Fo(n, r, i)),
      e !== null && (zr(e, n, i, t), sm(e, n, i));
  },
};
function JE(n, e, t, i, r, s, o) {
  return (
    (n = n.stateNode),
    typeof n.shouldComponentUpdate == "function"
      ? n.shouldComponentUpdate(i, s, o)
      : e.prototype && e.prototype.isPureReactComponent
      ? !Hf(t, i) || !Hf(r, s)
      : !0
  );
}
function eP(n, e, t) {
  var i = !1,
    r = Xo,
    s = e.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = Er(s))
      : ((r = Bi(e) ? tl : li.current),
        (i = e.contextTypes),
        (s = (i = i != null) ? kc(n, r) : Xo)),
    (e = new e(t, s)),
    (n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = _g),
    (n.stateNode = e),
    (e._reactInternals = n),
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = r),
      (n.__reactInternalMemoizedMaskedChildContext = s)),
    e
  );
}
function KE(n, e, t, i) {
  (n = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(t, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(t, i),
    e.state !== n && _g.enqueueReplaceState(e, e.state, null);
}
function Ux(n, e, t, i) {
  var r = n.stateNode;
  (r.props = t), (r.state = n.memoizedState), (r.refs = $R), kA(n);
  var s = e.contextType;
  typeof s == "object" && s !== null
    ? (r.context = Er(s))
    : ((s = Bi(e) ? tl : li.current), (r.context = kc(n, s))),
    (r.state = n.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == "function" && (Nx(n, e, s, t), (r.state = n.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof r.getSnapshotBeforeUpdate == "function" ||
      (typeof r.UNSAFE_componentWillMount != "function" &&
        typeof r.componentWillMount != "function") ||
      ((e = r.state),
      typeof r.componentWillMount == "function" && r.componentWillMount(),
      typeof r.UNSAFE_componentWillMount == "function" &&
        r.UNSAFE_componentWillMount(),
      e !== r.state && _g.enqueueReplaceState(r, r.state, null),
      km(n, t, r, i),
      (r.state = n.memoizedState)),
    typeof r.componentDidMount == "function" && (n.flags |= 4194308);
}
function Uu(n, e, t) {
  if (
    ((n = t.ref), n !== null && typeof n != "function" && typeof n != "object")
  ) {
    if (t._owner) {
      if (((t = t._owner), t)) {
        if (t.tag !== 1) throw Error(Ce(309));
        var i = t.stateNode;
      }
      if (!i) throw Error(Ce(147, n));
      var r = i,
        s = "" + n;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === s
        ? e.ref
        : ((e = function (o) {
            var a = r.refs;
            a === $R && (a = r.refs = {}),
              o === null ? delete a[s] : (a[s] = o);
          }),
          (e._stringRef = s),
          e);
    }
    if (typeof n != "string") throw Error(Ce(284));
    if (!t._owner) throw Error(Ce(290, n));
  }
  return n;
}
function $d(n, e) {
  throw (
    ((n = Object.prototype.toString.call(e)),
    Error(
      Ce(
        31,
        n === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : n
      )
    ))
  );
}
function YE(n) {
  var e = n._init;
  return e(n._payload);
}
function tP(n) {
  function e(g, x) {
    if (n) {
      var _ = g.deletions;
      _ === null ? ((g.deletions = [x]), (g.flags |= 16)) : _.push(x);
    }
  }
  function t(g, x) {
    if (!n) return null;
    for (; x !== null; ) e(g, x), (x = x.sibling);
    return null;
  }
  function i(g, x) {
    for (g = new Map(); x !== null; )
      x.key !== null ? g.set(x.key, x) : g.set(x.index, x), (x = x.sibling);
    return g;
  }
  function r(g, x) {
    return (g = Oo(g, x)), (g.index = 0), (g.sibling = null), g;
  }
  function s(g, x, _) {
    return (
      (g.index = _),
      n
        ? ((_ = g.alternate),
          _ !== null
            ? ((_ = _.index), _ < x ? ((g.flags |= 2), x) : _)
            : ((g.flags |= 2), x))
        : ((g.flags |= 1048576), x)
    );
  }
  function o(g) {
    return n && g.alternate === null && (g.flags |= 2), g;
  }
  function a(g, x, _, E) {
    return x === null || x.tag !== 6
      ? ((x = Yv(_, g.mode, E)), (x.return = g), x)
      : ((x = r(x, _)), (x.return = g), x);
  }
  function l(g, x, _, E) {
    var T = _.type;
    return T === oc
      ? h(g, x, _.props.children, E, _.key)
      : x !== null &&
        (x.elementType === T ||
          (typeof T == "object" &&
            T !== null &&
            T.$$typeof === Ao &&
            YE(T) === x.type))
      ? ((E = r(x, _.props)), (E.ref = Uu(g, x, _)), (E.return = g), E)
      : ((E = fm(_.type, _.key, _.props, null, g.mode, E)),
        (E.ref = Uu(g, x, _)),
        (E.return = g),
        E);
  }
  function u(g, x, _, E) {
    return x === null ||
      x.tag !== 4 ||
      x.stateNode.containerInfo !== _.containerInfo ||
      x.stateNode.implementation !== _.implementation
      ? ((x = Qv(_, g.mode, E)), (x.return = g), x)
      : ((x = r(x, _.children || [])), (x.return = g), x);
  }
  function h(g, x, _, E, T) {
    return x === null || x.tag !== 7
      ? ((x = Ka(_, g.mode, E, T)), (x.return = g), x)
      : ((x = r(x, _)), (x.return = g), x);
  }
  function d(g, x, _) {
    if ((typeof x == "string" && x !== "") || typeof x == "number")
      return (x = Yv("" + x, g.mode, _)), (x.return = g), x;
    if (typeof x == "object" && x !== null) {
      switch (x.$$typeof) {
        case Gd:
          return (
            (_ = fm(x.type, x.key, x.props, null, g.mode, _)),
            (_.ref = Uu(g, null, x)),
            (_.return = g),
            _
          );
        case sc:
          return (x = Qv(x, g.mode, _)), (x.return = g), x;
        case Ao:
          var E = x._init;
          return d(g, E(x._payload), _);
      }
      if (lf(x) || Lu(x))
        return (x = Ka(x, g.mode, _, null)), (x.return = g), x;
      $d(g, x);
    }
    return null;
  }
  function p(g, x, _, E) {
    var T = x !== null ? x.key : null;
    if ((typeof _ == "string" && _ !== "") || typeof _ == "number")
      return T !== null ? null : a(g, x, "" + _, E);
    if (typeof _ == "object" && _ !== null) {
      switch (_.$$typeof) {
        case Gd:
          return _.key === T ? l(g, x, _, E) : null;
        case sc:
          return _.key === T ? u(g, x, _, E) : null;
        case Ao:
          return (T = _._init), p(g, x, T(_._payload), E);
      }
      if (lf(_) || Lu(_)) return T !== null ? null : h(g, x, _, E, null);
      $d(g, _);
    }
    return null;
  }
  function m(g, x, _, E, T) {
    if ((typeof E == "string" && E !== "") || typeof E == "number")
      return (g = g.get(_) || null), a(x, g, "" + E, T);
    if (typeof E == "object" && E !== null) {
      switch (E.$$typeof) {
        case Gd:
          return (g = g.get(E.key === null ? _ : E.key) || null), l(x, g, E, T);
        case sc:
          return (g = g.get(E.key === null ? _ : E.key) || null), u(x, g, E, T);
        case Ao:
          var R = E._init;
          return m(g, x, _, R(E._payload), T);
      }
      if (lf(E) || Lu(E)) return (g = g.get(_) || null), h(x, g, E, T, null);
      $d(x, E);
    }
    return null;
  }
  function y(g, x, _, E) {
    for (
      var T = null, R = null, P = x, B = (x = 0), b = null;
      P !== null && B < _.length;
      B++
    ) {
      P.index > B ? ((b = P), (P = null)) : (b = P.sibling);
      var L = p(g, P, _[B], E);
      if (L === null) {
        P === null && (P = b);
        break;
      }
      n && P && L.alternate === null && e(g, P),
        (x = s(L, x, B)),
        R === null ? (T = L) : (R.sibling = L),
        (R = L),
        (P = b);
    }
    if (B === _.length) return t(g, P), Zt && ba(g, B), T;
    if (P === null) {
      for (; B < _.length; B++)
        (P = d(g, _[B], E)),
          P !== null &&
            ((x = s(P, x, B)), R === null ? (T = P) : (R.sibling = P), (R = P));
      return Zt && ba(g, B), T;
    }
    for (P = i(g, P); B < _.length; B++)
      (b = m(P, g, B, _[B], E)),
        b !== null &&
          (n && b.alternate !== null && P.delete(b.key === null ? B : b.key),
          (x = s(b, x, B)),
          R === null ? (T = b) : (R.sibling = b),
          (R = b));
    return (
      n &&
        P.forEach(function (z) {
          return e(g, z);
        }),
      Zt && ba(g, B),
      T
    );
  }
  function M(g, x, _, E) {
    var T = Lu(_);
    if (typeof T != "function") throw Error(Ce(150));
    if (((_ = T.call(_)), _ == null)) throw Error(Ce(151));
    for (
      var R = (T = null), P = x, B = (x = 0), b = null, L = _.next();
      P !== null && !L.done;
      B++, L = _.next()
    ) {
      P.index > B ? ((b = P), (P = null)) : (b = P.sibling);
      var z = p(g, P, L.value, E);
      if (z === null) {
        P === null && (P = b);
        break;
      }
      n && P && z.alternate === null && e(g, P),
        (x = s(z, x, B)),
        R === null ? (T = z) : (R.sibling = z),
        (R = z),
        (P = b);
    }
    if (L.done) return t(g, P), Zt && ba(g, B), T;
    if (P === null) {
      for (; !L.done; B++, L = _.next())
        (L = d(g, L.value, E)),
          L !== null &&
            ((x = s(L, x, B)), R === null ? (T = L) : (R.sibling = L), (R = L));
      return Zt && ba(g, B), T;
    }
    for (P = i(g, P); !L.done; B++, L = _.next())
      (L = m(P, g, B, L.value, E)),
        L !== null &&
          (n && L.alternate !== null && P.delete(L.key === null ? B : L.key),
          (x = s(L, x, B)),
          R === null ? (T = L) : (R.sibling = L),
          (R = L));
    return (
      n &&
        P.forEach(function ($) {
          return e(g, $);
        }),
      Zt && ba(g, B),
      T
    );
  }
  function A(g, x, _, E) {
    if (
      (typeof _ == "object" &&
        _ !== null &&
        _.type === oc &&
        _.key === null &&
        (_ = _.props.children),
      typeof _ == "object" && _ !== null)
    ) {
      switch (_.$$typeof) {
        case Gd:
          e: {
            for (var T = _.key, R = x; R !== null; ) {
              if (R.key === T) {
                if (((T = _.type), T === oc)) {
                  if (R.tag === 7) {
                    t(g, R.sibling),
                      (x = r(R, _.props.children)),
                      (x.return = g),
                      (g = x);
                    break e;
                  }
                } else if (
                  R.elementType === T ||
                  (typeof T == "object" &&
                    T !== null &&
                    T.$$typeof === Ao &&
                    YE(T) === R.type)
                ) {
                  t(g, R.sibling),
                    (x = r(R, _.props)),
                    (x.ref = Uu(g, R, _)),
                    (x.return = g),
                    (g = x);
                  break e;
                }
                t(g, R);
                break;
              } else e(g, R);
              R = R.sibling;
            }
            _.type === oc
              ? ((x = Ka(_.props.children, g.mode, E, _.key)),
                (x.return = g),
                (g = x))
              : ((E = fm(_.type, _.key, _.props, null, g.mode, E)),
                (E.ref = Uu(g, x, _)),
                (E.return = g),
                (g = E));
          }
          return o(g);
        case sc:
          e: {
            for (R = _.key; x !== null; ) {
              if (x.key === R)
                if (
                  x.tag === 4 &&
                  x.stateNode.containerInfo === _.containerInfo &&
                  x.stateNode.implementation === _.implementation
                ) {
                  t(g, x.sibling),
                    (x = r(x, _.children || [])),
                    (x.return = g),
                    (g = x);
                  break e;
                } else {
                  t(g, x);
                  break;
                }
              else e(g, x);
              x = x.sibling;
            }
            (x = Qv(_, g.mode, E)), (x.return = g), (g = x);
          }
          return o(g);
        case Ao:
          return (R = _._init), A(g, x, R(_._payload), E);
      }
      if (lf(_)) return y(g, x, _, E);
      if (Lu(_)) return M(g, x, _, E);
      $d(g, _);
    }
    return (typeof _ == "string" && _ !== "") || typeof _ == "number"
      ? ((_ = "" + _),
        x !== null && x.tag === 6
          ? (t(g, x.sibling), (x = r(x, _)), (x.return = g), (g = x))
          : (t(g, x), (x = Yv(_, g.mode, E)), (x.return = g), (g = x)),
        o(g))
      : t(g, x);
  }
  return A;
}
var zc = tP(!0),
  nP = tP(!1),
  _h = {},
  ps = ta(_h),
  Wf = ta(_h),
  jf = ta(_h);
function ka(n) {
  if (n === _h) throw Error(Ce(174));
  return n;
}
function HA(n, e) {
  switch ((jt(jf, e), jt(Wf, n), jt(ps, _h), (n = e.nodeType), n)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : mx(null, "");
      break;
    default:
      (n = n === 8 ? e.parentNode : e),
        (e = n.namespaceURI || null),
        (n = n.tagName),
        (e = mx(e, n));
  }
  Qt(ps), jt(ps, e);
}
function Gc() {
  Qt(ps), Qt(Wf), Qt(jf);
}
function iP(n) {
  ka(jf.current);
  var e = ka(ps.current),
    t = mx(e, n.type);
  e !== t && (jt(Wf, n), jt(ps, t));
}
function zA(n) {
  Wf.current === n && (Qt(ps), Qt(Wf));
}
var rn = ta(0);
function Hm(n) {
  for (var e = n; e !== null; ) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (
        t !== null &&
        ((t = t.dehydrated), t === null || t.data === "$?" || t.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === n) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === n) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var Vv = [];
function GA() {
  for (var n = 0; n < Vv.length; n++)
    Vv[n]._workInProgressVersionPrimary = null;
  Vv.length = 0;
}
var om = to.ReactCurrentDispatcher,
  Wv = to.ReactCurrentBatchConfig,
  il = 0,
  cn = null,
  Bn = null,
  zn = null,
  zm = !1,
  xf = !1,
  Xf = 0,
  rN = 0;
function ii() {
  throw Error(Ce(321));
}
function VA(n, e) {
  if (e === null) return !1;
  for (var t = 0; t < e.length && t < n.length; t++)
    if (!jr(n[t], e[t])) return !1;
  return !0;
}
function WA(n, e, t, i, r, s) {
  if (
    ((il = s),
    (cn = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (om.current = n === null || n.memoizedState === null ? lN : cN),
    (n = t(i, r)),
    xf)
  ) {
    s = 0;
    do {
      if (((xf = !1), (Xf = 0), 25 <= s)) throw Error(Ce(301));
      (s += 1),
        (zn = Bn = null),
        (e.updateQueue = null),
        (om.current = uN),
        (n = t(i, r));
    } while (xf);
  }
  if (
    ((om.current = Gm),
    (e = Bn !== null && Bn.next !== null),
    (il = 0),
    (zn = Bn = cn = null),
    (zm = !1),
    e)
  )
    throw Error(Ce(300));
  return n;
}
function jA() {
  var n = Xf !== 0;
  return (Xf = 0), n;
}
function ls() {
  var n = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return zn === null ? (cn.memoizedState = zn = n) : (zn = zn.next = n), zn;
}
function wr() {
  if (Bn === null) {
    var n = cn.alternate;
    n = n !== null ? n.memoizedState : null;
  } else n = Bn.next;
  var e = zn === null ? cn.memoizedState : zn.next;
  if (e !== null) (zn = e), (Bn = n);
  else {
    if (n === null) throw Error(Ce(310));
    (Bn = n),
      (n = {
        memoizedState: Bn.memoizedState,
        baseState: Bn.baseState,
        baseQueue: Bn.baseQueue,
        queue: Bn.queue,
        next: null,
      }),
      zn === null ? (cn.memoizedState = zn = n) : (zn = zn.next = n);
  }
  return zn;
}
function Jf(n, e) {
  return typeof e == "function" ? e(n) : e;
}
function jv(n) {
  var e = wr(),
    t = e.queue;
  if (t === null) throw Error(Ce(311));
  t.lastRenderedReducer = n;
  var i = Bn,
    r = i.baseQueue,
    s = t.pending;
  if (s !== null) {
    if (r !== null) {
      var o = r.next;
      (r.next = s.next), (s.next = o);
    }
    (i.baseQueue = r = s), (t.pending = null);
  }
  if (r !== null) {
    (s = r.next), (i = i.baseState);
    var a = (o = null),
      l = null,
      u = s;
    do {
      var h = u.lane;
      if ((il & h) === h)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: u.action,
              hasEagerState: u.hasEagerState,
              eagerState: u.eagerState,
              next: null,
            }),
          (i = u.hasEagerState ? u.eagerState : n(i, u.action));
      else {
        var d = {
          lane: h,
          action: u.action,
          hasEagerState: u.hasEagerState,
          eagerState: u.eagerState,
          next: null,
        };
        l === null ? ((a = l = d), (o = i)) : (l = l.next = d),
          (cn.lanes |= h),
          (rl |= h);
      }
      u = u.next;
    } while (u !== null && u !== s);
    l === null ? (o = i) : (l.next = a),
      jr(i, e.memoizedState) || (Ri = !0),
      (e.memoizedState = i),
      (e.baseState = o),
      (e.baseQueue = l),
      (t.lastRenderedState = i);
  }
  if (((n = t.interleaved), n !== null)) {
    r = n;
    do (s = r.lane), (cn.lanes |= s), (rl |= s), (r = r.next);
    while (r !== n);
  } else r === null && (t.lanes = 0);
  return [e.memoizedState, t.dispatch];
}
function Xv(n) {
  var e = wr(),
    t = e.queue;
  if (t === null) throw Error(Ce(311));
  t.lastRenderedReducer = n;
  var i = t.dispatch,
    r = t.pending,
    s = e.memoizedState;
  if (r !== null) {
    t.pending = null;
    var o = (r = r.next);
    do (s = n(s, o.action)), (o = o.next);
    while (o !== r);
    jr(s, e.memoizedState) || (Ri = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (t.lastRenderedState = s);
  }
  return [s, i];
}
function rP() {}
function sP(n, e) {
  var t = cn,
    i = wr(),
    r = e(),
    s = !jr(i.memoizedState, r);
  if (
    (s && ((i.memoizedState = r), (Ri = !0)),
    (i = i.queue),
    XA(lP.bind(null, t, i, n), [n]),
    i.getSnapshot !== e || s || (zn !== null && zn.memoizedState.tag & 1))
  ) {
    if (
      ((t.flags |= 2048),
      Kf(9, aP.bind(null, t, i, r, e), void 0, null),
      Vn === null)
    )
      throw Error(Ce(349));
    il & 30 || oP(t, e, r);
  }
  return r;
}
function oP(n, e, t) {
  (n.flags |= 16384),
    (n = { getSnapshot: e, value: t }),
    (e = cn.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (cn.updateQueue = e),
        (e.stores = [n]))
      : ((t = e.stores), t === null ? (e.stores = [n]) : t.push(n));
}
function aP(n, e, t, i) {
  (e.value = t), (e.getSnapshot = i), cP(e) && uP(n);
}
function lP(n, e, t) {
  return t(function () {
    cP(e) && uP(n);
  });
}
function cP(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !jr(n, t);
  } catch {
    return !0;
  }
}
function uP(n) {
  var e = qs(n, 1);
  e !== null && zr(e, n, 1, -1);
}
function QE(n) {
  var e = ls();
  return (
    typeof n == "function" && (n = n()),
    (e.memoizedState = e.baseState = n),
    (n = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Jf,
      lastRenderedState: n,
    }),
    (e.queue = n),
    (n = n.dispatch = aN.bind(null, cn, n)),
    [e.memoizedState, n]
  );
}
function Kf(n, e, t, i) {
  return (
    (n = { tag: n, create: e, destroy: t, deps: i, next: null }),
    (e = cn.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (cn.updateQueue = e),
        (e.lastEffect = n.next = n))
      : ((t = e.lastEffect),
        t === null
          ? (e.lastEffect = n.next = n)
          : ((i = t.next), (t.next = n), (n.next = i), (e.lastEffect = n))),
    n
  );
}
function fP() {
  return wr().memoizedState;
}
function am(n, e, t, i) {
  var r = ls();
  (cn.flags |= n),
    (r.memoizedState = Kf(1 | e, t, void 0, i === void 0 ? null : i));
}
function Ag(n, e, t, i) {
  var r = wr();
  i = i === void 0 ? null : i;
  var s = void 0;
  if (Bn !== null) {
    var o = Bn.memoizedState;
    if (((s = o.destroy), i !== null && VA(i, o.deps))) {
      r.memoizedState = Kf(e, t, s, i);
      return;
    }
  }
  (cn.flags |= n), (r.memoizedState = Kf(1 | e, t, s, i));
}
function qE(n, e) {
  return am(8390656, 8, n, e);
}
function XA(n, e) {
  return Ag(2048, 8, n, e);
}
function hP(n, e) {
  return Ag(4, 2, n, e);
}
function dP(n, e) {
  return Ag(4, 4, n, e);
}
function pP(n, e) {
  if (typeof e == "function")
    return (
      (n = n()),
      e(n),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (n = n()),
      (e.current = n),
      function () {
        e.current = null;
      }
    );
}
function mP(n, e, t) {
  return (
    (t = t != null ? t.concat([n]) : null), Ag(4, 4, pP.bind(null, e, n), t)
  );
}
function JA() {}
function gP(n, e) {
  var t = wr();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && VA(e, i[1])
    ? i[0]
    : ((t.memoizedState = [n, e]), n);
}
function vP(n, e) {
  var t = wr();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && VA(e, i[1])
    ? i[0]
    : ((n = n()), (t.memoizedState = [n, e]), n);
}
function yP(n, e, t) {
  return il & 21
    ? (jr(t, e) || ((t = AR()), (cn.lanes |= t), (rl |= t), (n.baseState = !0)),
      e)
    : (n.baseState && ((n.baseState = !1), (Ri = !0)), (n.memoizedState = t));
}
function sN(n, e) {
  var t = Ot;
  (Ot = t !== 0 && 4 > t ? t : 4), n(!0);
  var i = Wv.transition;
  Wv.transition = {};
  try {
    n(!1), e();
  } finally {
    (Ot = t), (Wv.transition = i);
  }
}
function xP() {
  return wr().memoizedState;
}
function oN(n, e, t) {
  var i = Uo(n);
  if (
    ((t = {
      lane: i,
      action: t,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    _P(n))
  )
    AP(e, t);
  else if (((t = qR(n, e, t, i)), t !== null)) {
    var r = yi();
    zr(t, n, i, r), SP(t, e, i);
  }
}
function aN(n, e, t) {
  var i = Uo(n),
    r = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null };
  if (_P(n)) AP(e, r);
  else {
    var s = n.alternate;
    if (
      n.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = e.lastRenderedReducer), s !== null)
    )
      try {
        var o = e.lastRenderedState,
          a = s(o, t);
        if (((r.hasEagerState = !0), (r.eagerState = a), jr(a, o))) {
          var l = e.interleaved;
          l === null
            ? ((r.next = r), OA(e))
            : ((r.next = l.next), (l.next = r)),
            (e.interleaved = r);
          return;
        }
      } catch {
      } finally {
      }
    (t = qR(n, e, r, i)),
      t !== null && ((r = yi()), zr(t, n, i, r), SP(t, e, i));
  }
}
function _P(n) {
  var e = n.alternate;
  return n === cn || (e !== null && e === cn);
}
function AP(n, e) {
  xf = zm = !0;
  var t = n.pending;
  t === null ? (e.next = e) : ((e.next = t.next), (t.next = e)),
    (n.pending = e);
}
function SP(n, e, t) {
  if (t & 4194240) {
    var i = e.lanes;
    (i &= n.pendingLanes), (t |= i), (e.lanes = t), EA(n, t);
  }
}
var Gm = {
    readContext: Er,
    useCallback: ii,
    useContext: ii,
    useEffect: ii,
    useImperativeHandle: ii,
    useInsertionEffect: ii,
    useLayoutEffect: ii,
    useMemo: ii,
    useReducer: ii,
    useRef: ii,
    useState: ii,
    useDebugValue: ii,
    useDeferredValue: ii,
    useTransition: ii,
    useMutableSource: ii,
    useSyncExternalStore: ii,
    useId: ii,
    unstable_isNewReconciler: !1,
  },
  lN = {
    readContext: Er,
    useCallback: function (n, e) {
      return (ls().memoizedState = [n, e === void 0 ? null : e]), n;
    },
    useContext: Er,
    useEffect: qE,
    useImperativeHandle: function (n, e, t) {
      return (
        (t = t != null ? t.concat([n]) : null),
        am(4194308, 4, pP.bind(null, e, n), t)
      );
    },
    useLayoutEffect: function (n, e) {
      return am(4194308, 4, n, e);
    },
    useInsertionEffect: function (n, e) {
      return am(4, 2, n, e);
    },
    useMemo: function (n, e) {
      var t = ls();
      return (
        (e = e === void 0 ? null : e), (n = n()), (t.memoizedState = [n, e]), n
      );
    },
    useReducer: function (n, e, t) {
      var i = ls();
      return (
        (e = t !== void 0 ? t(e) : e),
        (i.memoizedState = i.baseState = e),
        (n = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: n,
          lastRenderedState: e,
        }),
        (i.queue = n),
        (n = n.dispatch = oN.bind(null, cn, n)),
        [i.memoizedState, n]
      );
    },
    useRef: function (n) {
      var e = ls();
      return (n = { current: n }), (e.memoizedState = n);
    },
    useState: QE,
    useDebugValue: JA,
    useDeferredValue: function (n) {
      return (ls().memoizedState = n);
    },
    useTransition: function () {
      var n = QE(!1),
        e = n[0];
      return (n = sN.bind(null, n[1])), (ls().memoizedState = n), [e, n];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (n, e, t) {
      var i = cn,
        r = ls();
      if (Zt) {
        if (t === void 0) throw Error(Ce(407));
        t = t();
      } else {
        if (((t = e()), Vn === null)) throw Error(Ce(349));
        il & 30 || oP(i, e, t);
      }
      r.memoizedState = t;
      var s = { value: t, getSnapshot: e };
      return (
        (r.queue = s),
        qE(lP.bind(null, i, s, n), [n]),
        (i.flags |= 2048),
        Kf(9, aP.bind(null, i, s, t, e), void 0, null),
        t
      );
    },
    useId: function () {
      var n = ls(),
        e = Vn.identifierPrefix;
      if (Zt) {
        var t = zs,
          i = Hs;
        (t = (i & ~(1 << (32 - Hr(i) - 1))).toString(32) + t),
          (e = ":" + e + "R" + t),
          (t = Xf++),
          0 < t && (e += "H" + t.toString(32)),
          (e += ":");
      } else (t = rN++), (e = ":" + e + "r" + t.toString(32) + ":");
      return (n.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  cN = {
    readContext: Er,
    useCallback: gP,
    useContext: Er,
    useEffect: XA,
    useImperativeHandle: mP,
    useInsertionEffect: hP,
    useLayoutEffect: dP,
    useMemo: vP,
    useReducer: jv,
    useRef: fP,
    useState: function () {
      return jv(Jf);
    },
    useDebugValue: JA,
    useDeferredValue: function (n) {
      var e = wr();
      return yP(e, Bn.memoizedState, n);
    },
    useTransition: function () {
      var n = jv(Jf)[0],
        e = wr().memoizedState;
      return [n, e];
    },
    useMutableSource: rP,
    useSyncExternalStore: sP,
    useId: xP,
    unstable_isNewReconciler: !1,
  },
  uN = {
    readContext: Er,
    useCallback: gP,
    useContext: Er,
    useEffect: XA,
    useImperativeHandle: mP,
    useInsertionEffect: hP,
    useLayoutEffect: dP,
    useMemo: vP,
    useReducer: Xv,
    useRef: fP,
    useState: function () {
      return Xv(Jf);
    },
    useDebugValue: JA,
    useDeferredValue: function (n) {
      var e = wr();
      return Bn === null ? (e.memoizedState = n) : yP(e, Bn.memoizedState, n);
    },
    useTransition: function () {
      var n = Xv(Jf)[0],
        e = wr().memoizedState;
      return [n, e];
    },
    useMutableSource: rP,
    useSyncExternalStore: sP,
    useId: xP,
    unstable_isNewReconciler: !1,
  };
function Vc(n, e) {
  try {
    var t = "",
      i = e;
    do (t += O3(i)), (i = i.return);
    while (i);
    var r = t;
  } catch (s) {
    r =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: n, source: e, stack: r, digest: null };
}
function Jv(n, e, t) {
  return { value: n, source: null, stack: t ?? null, digest: e ?? null };
}
function Ox(n, e) {
  try {
    console.error(e.value);
  } catch (t) {
    setTimeout(function () {
      throw t;
    });
  }
}
var fN = typeof WeakMap == "function" ? WeakMap : Map;
function MP(n, e, t) {
  (t = js(-1, t)), (t.tag = 3), (t.payload = { element: null });
  var i = e.value;
  return (
    (t.callback = function () {
      Wm || ((Wm = !0), (Kx = i)), Ox(n, e);
    }),
    t
  );
}
function EP(n, e, t) {
  (t = js(-1, t)), (t.tag = 3);
  var i = n.type.getDerivedStateFromError;
  if (typeof i == "function") {
    var r = e.value;
    (t.payload = function () {
      return i(r);
    }),
      (t.callback = function () {
        Ox(n, e);
      });
  }
  var s = n.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (t.callback = function () {
        Ox(n, e),
          typeof i != "function" &&
            (No === null ? (No = new Set([this])) : No.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: o !== null ? o : "",
        });
      }),
    t
  );
}
function ZE(n, e, t) {
  var i = n.pingCache;
  if (i === null) {
    i = n.pingCache = new fN();
    var r = new Set();
    i.set(e, r);
  } else (r = i.get(e)), r === void 0 && ((r = new Set()), i.set(e, r));
  r.has(t) || (r.add(t), (n = wN.bind(null, n, e, t)), e.then(n, n));
}
function $E(n) {
  do {
    var e;
    if (
      ((e = n.tag === 13) &&
        ((e = n.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return n;
    n = n.return;
  } while (n !== null);
  return null;
}
function ew(n, e, t, i, r) {
  return n.mode & 1
    ? ((n.flags |= 65536), (n.lanes = r), n)
    : (n === e
        ? (n.flags |= 65536)
        : ((n.flags |= 128),
          (t.flags |= 131072),
          (t.flags &= -52805),
          t.tag === 1 &&
            (t.alternate === null
              ? (t.tag = 17)
              : ((e = js(-1, 1)), (e.tag = 2), Fo(t, e, 1))),
          (t.lanes |= 1)),
      n);
}
var hN = to.ReactCurrentOwner,
  Ri = !1;
function gi(n, e, t, i) {
  e.child = n === null ? nP(e, null, t, i) : zc(e, n.child, t, i);
}
function tw(n, e, t, i, r) {
  t = t.render;
  var s = e.ref;
  return (
    Pc(e, r),
    (i = WA(n, e, t, i, s, r)),
    (t = jA()),
    n !== null && !Ri
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        Zs(n, e, r))
      : (Zt && t && LA(e), (e.flags |= 1), gi(n, e, i, r), e.child)
  );
}
function nw(n, e, t, i, r) {
  if (n === null) {
    var s = t.type;
    return typeof s == "function" &&
      !t1(s) &&
      s.defaultProps === void 0 &&
      t.compare === null &&
      t.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), wP(n, e, s, i, r))
      : ((n = fm(t.type, null, i, e, e.mode, r)),
        (n.ref = e.ref),
        (n.return = e),
        (e.child = n));
  }
  if (((s = n.child), !(n.lanes & r))) {
    var o = s.memoizedProps;
    if (
      ((t = t.compare), (t = t !== null ? t : Hf), t(o, i) && n.ref === e.ref)
    )
      return Zs(n, e, r);
  }
  return (
    (e.flags |= 1),
    (n = Oo(s, i)),
    (n.ref = e.ref),
    (n.return = e),
    (e.child = n)
  );
}
function wP(n, e, t, i, r) {
  if (n !== null) {
    var s = n.memoizedProps;
    if (Hf(s, i) && n.ref === e.ref)
      if (((Ri = !1), (e.pendingProps = i = s), (n.lanes & r) !== 0))
        n.flags & 131072 && (Ri = !0);
      else return (e.lanes = n.lanes), Zs(n, e, r);
  }
  return kx(n, e, t, i, r);
}
function TP(n, e, t) {
  var i = e.pendingProps,
    r = i.children,
    s = n !== null ? n.memoizedState : null;
  if (i.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        jt(gc, Wi),
        (Wi |= t);
    else {
      if (!(t & 1073741824))
        return (
          (n = s !== null ? s.baseLanes | t : t),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: n,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          jt(gc, Wi),
          (Wi |= n),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (i = s !== null ? s.baseLanes : t),
        jt(gc, Wi),
        (Wi |= i);
    }
  else
    s !== null ? ((i = s.baseLanes | t), (e.memoizedState = null)) : (i = t),
      jt(gc, Wi),
      (Wi |= i);
  return gi(n, e, r, t), e.child;
}
function CP(n, e) {
  var t = e.ref;
  ((n === null && t !== null) || (n !== null && n.ref !== t)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function kx(n, e, t, i, r) {
  var s = Bi(t) ? tl : li.current;
  return (
    (s = kc(e, s)),
    Pc(e, r),
    (t = WA(n, e, t, i, s, r)),
    (i = jA()),
    n !== null && !Ri
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        Zs(n, e, r))
      : (Zt && i && LA(e), (e.flags |= 1), gi(n, e, t, r), e.child)
  );
}
function iw(n, e, t, i, r) {
  if (Bi(t)) {
    var s = !0;
    Dm(e);
  } else s = !1;
  if ((Pc(e, r), e.stateNode === null))
    lm(n, e), eP(e, t, i), Ux(e, t, i, r), (i = !0);
  else if (n === null) {
    var o = e.stateNode,
      a = e.memoizedProps;
    o.props = a;
    var l = o.context,
      u = t.contextType;
    typeof u == "object" && u !== null
      ? (u = Er(u))
      : ((u = Bi(t) ? tl : li.current), (u = kc(e, u)));
    var h = t.getDerivedStateFromProps,
      d =
        typeof h == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function";
    d ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== i || l !== u) && KE(e, o, i, u)),
      (So = !1);
    var p = e.memoizedState;
    (o.state = p),
      km(e, i, o, r),
      (l = e.memoizedState),
      a !== i || p !== l || Pi.current || So
        ? (typeof h == "function" && (Nx(e, t, h, i), (l = e.memoizedState)),
          (a = So || JE(e, t, a, i, p, l, u))
            ? (d ||
                (typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function") ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = i),
              (e.memoizedState = l)),
          (o.props = i),
          (o.state = l),
          (o.context = u),
          (i = a))
        : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
          (i = !1));
  } else {
    (o = e.stateNode),
      ZR(n, e),
      (a = e.memoizedProps),
      (u = e.type === e.elementType ? a : Fr(e.type, a)),
      (o.props = u),
      (d = e.pendingProps),
      (p = o.context),
      (l = t.contextType),
      typeof l == "object" && l !== null
        ? (l = Er(l))
        : ((l = Bi(t) ? tl : li.current), (l = kc(e, l)));
    var m = t.getDerivedStateFromProps;
    (h =
      typeof m == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function") ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== d || p !== l) && KE(e, o, i, l)),
      (So = !1),
      (p = e.memoizedState),
      (o.state = p),
      km(e, i, o, r);
    var y = e.memoizedState;
    a !== d || p !== y || Pi.current || So
      ? (typeof m == "function" && (Nx(e, t, m, i), (y = e.memoizedState)),
        (u = So || JE(e, t, u, i, p, y, l) || !1)
          ? (h ||
              (typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function") ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(i, y, l),
              typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(i, y, l)),
            typeof o.componentDidUpdate == "function" && (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof o.componentDidUpdate != "function" ||
              (a === n.memoizedProps && p === n.memoizedState) ||
              (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != "function" ||
              (a === n.memoizedProps && p === n.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = i),
            (e.memoizedState = y)),
        (o.props = i),
        (o.state = y),
        (o.context = l),
        (i = u))
      : (typeof o.componentDidUpdate != "function" ||
          (a === n.memoizedProps && p === n.memoizedState) ||
          (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" ||
          (a === n.memoizedProps && p === n.memoizedState) ||
          (e.flags |= 1024),
        (i = !1));
  }
  return Hx(n, e, t, i, s, r);
}
function Hx(n, e, t, i, r, s) {
  CP(n, e);
  var o = (e.flags & 128) !== 0;
  if (!i && !o) return r && GE(e, t, !1), Zs(n, e, s);
  (i = e.stateNode), (hN.current = e);
  var a =
    o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
  return (
    (e.flags |= 1),
    n !== null && o
      ? ((e.child = zc(e, n.child, null, s)), (e.child = zc(e, null, a, s)))
      : gi(n, e, a, s),
    (e.memoizedState = i.state),
    r && GE(e, t, !0),
    e.child
  );
}
function bP(n) {
  var e = n.stateNode;
  e.pendingContext
    ? zE(n, e.pendingContext, e.pendingContext !== e.context)
    : e.context && zE(n, e.context, !1),
    HA(n, e.containerInfo);
}
function rw(n, e, t, i, r) {
  return Hc(), DA(r), (e.flags |= 256), gi(n, e, t, i), e.child;
}
var zx = { dehydrated: null, treeContext: null, retryLane: 0 };
function Gx(n) {
  return { baseLanes: n, cachePool: null, transitions: null };
}
function RP(n, e, t) {
  var i = e.pendingProps,
    r = rn.current,
    s = !1,
    o = (e.flags & 128) !== 0,
    a;
  if (
    ((a = o) ||
      (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0),
    a
      ? ((s = !0), (e.flags &= -129))
      : (n === null || n.memoizedState !== null) && (r |= 1),
    jt(rn, r & 1),
    n === null)
  )
    return (
      Dx(e),
      (n = e.memoizedState),
      n !== null && ((n = n.dehydrated), n !== null)
        ? (e.mode & 1
            ? n.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((o = i.children),
          (n = i.fallback),
          s
            ? ((i = e.mode),
              (s = e.child),
              (o = { mode: "hidden", children: o }),
              !(i & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = Eg(o, i, 0, null)),
              (n = Ka(n, i, t, null)),
              (s.return = e),
              (n.return = e),
              (s.sibling = n),
              (e.child = s),
              (e.child.memoizedState = Gx(t)),
              (e.memoizedState = zx),
              n)
            : KA(e, o))
    );
  if (((r = n.memoizedState), r !== null && ((a = r.dehydrated), a !== null)))
    return dN(n, e, o, i, a, r, t);
  if (s) {
    (s = i.fallback), (o = e.mode), (r = n.child), (a = r.sibling);
    var l = { mode: "hidden", children: i.children };
    return (
      !(o & 1) && e.child !== r
        ? ((i = e.child),
          (i.childLanes = 0),
          (i.pendingProps = l),
          (e.deletions = null))
        : ((i = Oo(r, l)), (i.subtreeFlags = r.subtreeFlags & 14680064)),
      a !== null ? (s = Oo(a, s)) : ((s = Ka(s, o, t, null)), (s.flags |= 2)),
      (s.return = e),
      (i.return = e),
      (i.sibling = s),
      (e.child = i),
      (i = s),
      (s = e.child),
      (o = n.child.memoizedState),
      (o =
        o === null
          ? Gx(t)
          : {
              baseLanes: o.baseLanes | t,
              cachePool: null,
              transitions: o.transitions,
            }),
      (s.memoizedState = o),
      (s.childLanes = n.childLanes & ~t),
      (e.memoizedState = zx),
      i
    );
  }
  return (
    (s = n.child),
    (n = s.sibling),
    (i = Oo(s, { mode: "visible", children: i.children })),
    !(e.mode & 1) && (i.lanes = t),
    (i.return = e),
    (i.sibling = null),
    n !== null &&
      ((t = e.deletions),
      t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)),
    (e.child = i),
    (e.memoizedState = null),
    i
  );
}
function KA(n, e) {
  return (
    (e = Eg({ mode: "visible", children: e }, n.mode, 0, null)),
    (e.return = n),
    (n.child = e)
  );
}
function ep(n, e, t, i) {
  return (
    i !== null && DA(i),
    zc(e, n.child, null, t),
    (n = KA(e, e.pendingProps.children)),
    (n.flags |= 2),
    (e.memoizedState = null),
    n
  );
}
function dN(n, e, t, i, r, s, o) {
  if (t)
    return e.flags & 256
      ? ((e.flags &= -257), (i = Jv(Error(Ce(422)))), ep(n, e, o, i))
      : e.memoizedState !== null
      ? ((e.child = n.child), (e.flags |= 128), null)
      : ((s = i.fallback),
        (r = e.mode),
        (i = Eg({ mode: "visible", children: i.children }, r, 0, null)),
        (s = Ka(s, r, o, null)),
        (s.flags |= 2),
        (i.return = e),
        (s.return = e),
        (i.sibling = s),
        (e.child = i),
        e.mode & 1 && zc(e, n.child, null, o),
        (e.child.memoizedState = Gx(o)),
        (e.memoizedState = zx),
        s);
  if (!(e.mode & 1)) return ep(n, e, o, null);
  if (r.data === "$!") {
    if (((i = r.nextSibling && r.nextSibling.dataset), i)) var a = i.dgst;
    return (
      (i = a), (s = Error(Ce(419))), (i = Jv(s, i, void 0)), ep(n, e, o, i)
    );
  }
  if (((a = (o & n.childLanes) !== 0), Ri || a)) {
    if (((i = Vn), i !== null)) {
      switch (o & -o) {
        case 4:
          r = 2;
          break;
        case 16:
          r = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          r = 32;
          break;
        case 536870912:
          r = 268435456;
          break;
        default:
          r = 0;
      }
      (r = r & (i.suspendedLanes | o) ? 0 : r),
        r !== 0 &&
          r !== s.retryLane &&
          ((s.retryLane = r), qs(n, r), zr(i, n, r, -1));
    }
    return e1(), (i = Jv(Error(Ce(421)))), ep(n, e, o, i);
  }
  return r.data === "$?"
    ? ((e.flags |= 128),
      (e.child = n.child),
      (e = TN.bind(null, n)),
      (r._reactRetry = e),
      null)
    : ((n = s.treeContext),
      (ji = Do(r.nextSibling)),
      (Qi = e),
      (Zt = !0),
      (Or = null),
      n !== null &&
        ((xr[_r++] = Hs),
        (xr[_r++] = zs),
        (xr[_r++] = nl),
        (Hs = n.id),
        (zs = n.overflow),
        (nl = e)),
      (e = KA(e, i.children)),
      (e.flags |= 4096),
      e);
}
function sw(n, e, t) {
  n.lanes |= e;
  var i = n.alternate;
  i !== null && (i.lanes |= e), Fx(n.return, e, t);
}
function Kv(n, e, t, i, r) {
  var s = n.memoizedState;
  s === null
    ? (n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: t,
        tailMode: r,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = i),
      (s.tail = t),
      (s.tailMode = r));
}
function PP(n, e, t) {
  var i = e.pendingProps,
    r = i.revealOrder,
    s = i.tail;
  if ((gi(n, e, i.children, t), (i = rn.current), i & 2))
    (i = (i & 1) | 2), (e.flags |= 128);
  else {
    if (n !== null && n.flags & 128)
      e: for (n = e.child; n !== null; ) {
        if (n.tag === 13) n.memoizedState !== null && sw(n, t, e);
        else if (n.tag === 19) sw(n, t, e);
        else if (n.child !== null) {
          (n.child.return = n), (n = n.child);
          continue;
        }
        if (n === e) break e;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === e) break e;
          n = n.return;
        }
        (n.sibling.return = n.return), (n = n.sibling);
      }
    i &= 1;
  }
  if ((jt(rn, i), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (r) {
      case "forwards":
        for (t = e.child, r = null; t !== null; )
          (n = t.alternate),
            n !== null && Hm(n) === null && (r = t),
            (t = t.sibling);
        (t = r),
          t === null
            ? ((r = e.child), (e.child = null))
            : ((r = t.sibling), (t.sibling = null)),
          Kv(e, !1, r, t, s);
        break;
      case "backwards":
        for (t = null, r = e.child, e.child = null; r !== null; ) {
          if (((n = r.alternate), n !== null && Hm(n) === null)) {
            e.child = r;
            break;
          }
          (n = r.sibling), (r.sibling = t), (t = r), (r = n);
        }
        Kv(e, !0, t, null, s);
        break;
      case "together":
        Kv(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function lm(n, e) {
  !(e.mode & 1) &&
    n !== null &&
    ((n.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function Zs(n, e, t) {
  if (
    (n !== null && (e.dependencies = n.dependencies),
    (rl |= e.lanes),
    !(t & e.childLanes))
  )
    return null;
  if (n !== null && e.child !== n.child) throw Error(Ce(153));
  if (e.child !== null) {
    for (
      n = e.child, t = Oo(n, n.pendingProps), e.child = t, t.return = e;
      n.sibling !== null;

    )
      (n = n.sibling), (t = t.sibling = Oo(n, n.pendingProps)), (t.return = e);
    t.sibling = null;
  }
  return e.child;
}
function pN(n, e, t) {
  switch (e.tag) {
    case 3:
      bP(e), Hc();
      break;
    case 5:
      iP(e);
      break;
    case 1:
      Bi(e.type) && Dm(e);
      break;
    case 4:
      HA(e, e.stateNode.containerInfo);
      break;
    case 10:
      var i = e.type._context,
        r = e.memoizedProps.value;
      jt(Um, i._currentValue), (i._currentValue = r);
      break;
    case 13:
      if (((i = e.memoizedState), i !== null))
        return i.dehydrated !== null
          ? (jt(rn, rn.current & 1), (e.flags |= 128), null)
          : t & e.child.childLanes
          ? RP(n, e, t)
          : (jt(rn, rn.current & 1),
            (n = Zs(n, e, t)),
            n !== null ? n.sibling : null);
      jt(rn, rn.current & 1);
      break;
    case 19:
      if (((i = (t & e.childLanes) !== 0), n.flags & 128)) {
        if (i) return PP(n, e, t);
        e.flags |= 128;
      }
      if (
        ((r = e.memoizedState),
        r !== null &&
          ((r.rendering = null), (r.tail = null), (r.lastEffect = null)),
        jt(rn, rn.current),
        i)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), TP(n, e, t);
  }
  return Zs(n, e, t);
}
var BP, Vx, LP, IP;
BP = function (n, e) {
  for (var t = e.child; t !== null; ) {
    if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode);
    else if (t.tag !== 4 && t.child !== null) {
      (t.child.return = t), (t = t.child);
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return;
      t = t.return;
    }
    (t.sibling.return = t.return), (t = t.sibling);
  }
};
Vx = function () {};
LP = function (n, e, t, i) {
  var r = n.memoizedProps;
  if (r !== i) {
    (n = e.stateNode), ka(ps.current);
    var s = null;
    switch (t) {
      case "input":
        (r = fx(n, r)), (i = fx(n, i)), (s = []);
        break;
      case "select":
        (r = un({}, r, { value: void 0 })),
          (i = un({}, i, { value: void 0 })),
          (s = []);
        break;
      case "textarea":
        (r = px(n, r)), (i = px(n, i)), (s = []);
        break;
      default:
        typeof r.onClick != "function" &&
          typeof i.onClick == "function" &&
          (n.onclick = Lm);
    }
    gx(t, i);
    var o;
    t = null;
    for (u in r)
      if (!i.hasOwnProperty(u) && r.hasOwnProperty(u) && r[u] != null)
        if (u === "style") {
          var a = r[u];
          for (o in a) a.hasOwnProperty(o) && (t || (t = {}), (t[o] = ""));
        } else
          u !== "dangerouslySetInnerHTML" &&
            u !== "children" &&
            u !== "suppressContentEditableWarning" &&
            u !== "suppressHydrationWarning" &&
            u !== "autoFocus" &&
            (If.hasOwnProperty(u)
              ? s || (s = [])
              : (s = s || []).push(u, null));
    for (u in i) {
      var l = i[u];
      if (
        ((a = r != null ? r[u] : void 0),
        i.hasOwnProperty(u) && l !== a && (l != null || a != null))
      )
        if (u === "style")
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) ||
                (l && l.hasOwnProperty(o)) ||
                (t || (t = {}), (t[o] = ""));
            for (o in l)
              l.hasOwnProperty(o) &&
                a[o] !== l[o] &&
                (t || (t = {}), (t[o] = l[o]));
          } else t || (s || (s = []), s.push(u, t)), (t = l);
        else
          u === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (a = a ? a.__html : void 0),
              l != null && a !== l && (s = s || []).push(u, l))
            : u === "children"
            ? (typeof l != "string" && typeof l != "number") ||
              (s = s || []).push(u, "" + l)
            : u !== "suppressContentEditableWarning" &&
              u !== "suppressHydrationWarning" &&
              (If.hasOwnProperty(u)
                ? (l != null && u === "onScroll" && Kt("scroll", n),
                  s || a === l || (s = []))
                : (s = s || []).push(u, l));
    }
    t && (s = s || []).push("style", t);
    var u = s;
    (e.updateQueue = u) && (e.flags |= 4);
  }
};
IP = function (n, e, t, i) {
  t !== i && (e.flags |= 4);
};
function Ou(n, e) {
  if (!Zt)
    switch (n.tailMode) {
      case "hidden":
        e = n.tail;
        for (var t = null; e !== null; )
          e.alternate !== null && (t = e), (e = e.sibling);
        t === null ? (n.tail = null) : (t.sibling = null);
        break;
      case "collapsed":
        t = n.tail;
        for (var i = null; t !== null; )
          t.alternate !== null && (i = t), (t = t.sibling);
        i === null
          ? e || n.tail === null
            ? (n.tail = null)
            : (n.tail.sibling = null)
          : (i.sibling = null);
    }
}
function ri(n) {
  var e = n.alternate !== null && n.alternate.child === n.child,
    t = 0,
    i = 0;
  if (e)
    for (var r = n.child; r !== null; )
      (t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags & 14680064),
        (i |= r.flags & 14680064),
        (r.return = n),
        (r = r.sibling);
  else
    for (r = n.child; r !== null; )
      (t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags),
        (i |= r.flags),
        (r.return = n),
        (r = r.sibling);
  return (n.subtreeFlags |= i), (n.childLanes = t), e;
}
function mN(n, e, t) {
  var i = e.pendingProps;
  switch ((IA(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return ri(e), null;
    case 1:
      return Bi(e.type) && Im(), ri(e), null;
    case 3:
      return (
        (i = e.stateNode),
        Gc(),
        Qt(Pi),
        Qt(li),
        GA(),
        i.pendingContext &&
          ((i.context = i.pendingContext), (i.pendingContext = null)),
        (n === null || n.child === null) &&
          (Zd(e)
            ? (e.flags |= 4)
            : n === null ||
              (n.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), Or !== null && (qx(Or), (Or = null)))),
        Vx(n, e),
        ri(e),
        null
      );
    case 5:
      zA(e);
      var r = ka(jf.current);
      if (((t = e.type), n !== null && e.stateNode != null))
        LP(n, e, t, i, r),
          n.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!i) {
          if (e.stateNode === null) throw Error(Ce(166));
          return ri(e), null;
        }
        if (((n = ka(ps.current)), Zd(e))) {
          (i = e.stateNode), (t = e.type);
          var s = e.memoizedProps;
          switch (((i[us] = e), (i[Vf] = s), (n = (e.mode & 1) !== 0), t)) {
            case "dialog":
              Kt("cancel", i), Kt("close", i);
              break;
            case "iframe":
            case "object":
            case "embed":
              Kt("load", i);
              break;
            case "video":
            case "audio":
              for (r = 0; r < uf.length; r++) Kt(uf[r], i);
              break;
            case "source":
              Kt("error", i);
              break;
            case "img":
            case "image":
            case "link":
              Kt("error", i), Kt("load", i);
              break;
            case "details":
              Kt("toggle", i);
              break;
            case "input":
              pE(i, s), Kt("invalid", i);
              break;
            case "select":
              (i._wrapperState = { wasMultiple: !!s.multiple }),
                Kt("invalid", i);
              break;
            case "textarea":
              gE(i, s), Kt("invalid", i);
          }
          gx(t, s), (r = null);
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children"
                ? typeof a == "string"
                  ? i.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 &&
                      qd(i.textContent, a, n),
                    (r = ["children", a]))
                  : typeof a == "number" &&
                    i.textContent !== "" + a &&
                    (s.suppressHydrationWarning !== !0 &&
                      qd(i.textContent, a, n),
                    (r = ["children", "" + a]))
                : If.hasOwnProperty(o) &&
                  a != null &&
                  o === "onScroll" &&
                  Kt("scroll", i);
            }
          switch (t) {
            case "input":
              Vd(i), mE(i, s, !0);
              break;
            case "textarea":
              Vd(i), vE(i);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (i.onclick = Lm);
          }
          (i = r), (e.updateQueue = i), i !== null && (e.flags |= 4);
        } else {
          (o = r.nodeType === 9 ? r : r.ownerDocument),
            n === "http://www.w3.org/1999/xhtml" && (n = oR(t)),
            n === "http://www.w3.org/1999/xhtml"
              ? t === "script"
                ? ((n = o.createElement("div")),
                  (n.innerHTML = "<script></script>"),
                  (n = n.removeChild(n.firstChild)))
                : typeof i.is == "string"
                ? (n = o.createElement(t, { is: i.is }))
                : ((n = o.createElement(t)),
                  t === "select" &&
                    ((o = n),
                    i.multiple
                      ? (o.multiple = !0)
                      : i.size && (o.size = i.size)))
              : (n = o.createElementNS(n, t)),
            (n[us] = e),
            (n[Vf] = i),
            BP(n, e, !1, !1),
            (e.stateNode = n);
          e: {
            switch (((o = vx(t, i)), t)) {
              case "dialog":
                Kt("cancel", n), Kt("close", n), (r = i);
                break;
              case "iframe":
              case "object":
              case "embed":
                Kt("load", n), (r = i);
                break;
              case "video":
              case "audio":
                for (r = 0; r < uf.length; r++) Kt(uf[r], n);
                r = i;
                break;
              case "source":
                Kt("error", n), (r = i);
                break;
              case "img":
              case "image":
              case "link":
                Kt("error", n), Kt("load", n), (r = i);
                break;
              case "details":
                Kt("toggle", n), (r = i);
                break;
              case "input":
                pE(n, i), (r = fx(n, i)), Kt("invalid", n);
                break;
              case "option":
                r = i;
                break;
              case "select":
                (n._wrapperState = { wasMultiple: !!i.multiple }),
                  (r = un({}, i, { value: void 0 })),
                  Kt("invalid", n);
                break;
              case "textarea":
                gE(n, i), (r = px(n, i)), Kt("invalid", n);
                break;
              default:
                r = i;
            }
            gx(t, r), (a = r);
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var l = a[s];
                s === "style"
                  ? cR(n, l)
                  : s === "dangerouslySetInnerHTML"
                  ? ((l = l ? l.__html : void 0), l != null && aR(n, l))
                  : s === "children"
                  ? typeof l == "string"
                    ? (t !== "textarea" || l !== "") && Df(n, l)
                    : typeof l == "number" && Df(n, "" + l)
                  : s !== "suppressContentEditableWarning" &&
                    s !== "suppressHydrationWarning" &&
                    s !== "autoFocus" &&
                    (If.hasOwnProperty(s)
                      ? l != null && s === "onScroll" && Kt("scroll", n)
                      : l != null && yA(n, s, l, o));
              }
            switch (t) {
              case "input":
                Vd(n), mE(n, i, !1);
                break;
              case "textarea":
                Vd(n), vE(n);
                break;
              case "option":
                i.value != null && n.setAttribute("value", "" + jo(i.value));
                break;
              case "select":
                (n.multiple = !!i.multiple),
                  (s = i.value),
                  s != null
                    ? Tc(n, !!i.multiple, s, !1)
                    : i.defaultValue != null &&
                      Tc(n, !!i.multiple, i.defaultValue, !0);
                break;
              default:
                typeof r.onClick == "function" && (n.onclick = Lm);
            }
            switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!i.autoFocus;
                break e;
              case "img":
                i = !0;
                break e;
              default:
                i = !1;
            }
          }
          i && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return ri(e), null;
    case 6:
      if (n && e.stateNode != null) IP(n, e, n.memoizedProps, i);
      else {
        if (typeof i != "string" && e.stateNode === null) throw Error(Ce(166));
        if (((t = ka(jf.current)), ka(ps.current), Zd(e))) {
          if (
            ((i = e.stateNode),
            (t = e.memoizedProps),
            (i[us] = e),
            (s = i.nodeValue !== t) && ((n = Qi), n !== null))
          )
            switch (n.tag) {
              case 3:
                qd(i.nodeValue, t, (n.mode & 1) !== 0);
                break;
              case 5:
                n.memoizedProps.suppressHydrationWarning !== !0 &&
                  qd(i.nodeValue, t, (n.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          (i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i)),
            (i[us] = e),
            (e.stateNode = i);
      }
      return ri(e), null;
    case 13:
      if (
        (Qt(rn),
        (i = e.memoizedState),
        n === null ||
          (n.memoizedState !== null && n.memoizedState.dehydrated !== null))
      ) {
        if (Zt && ji !== null && e.mode & 1 && !(e.flags & 128))
          QR(), Hc(), (e.flags |= 98560), (s = !1);
        else if (((s = Zd(e)), i !== null && i.dehydrated !== null)) {
          if (n === null) {
            if (!s) throw Error(Ce(318));
            if (
              ((s = e.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(Ce(317));
            s[us] = e;
          } else
            Hc(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          ri(e), (s = !1);
        } else Or !== null && (qx(Or), (Or = null)), (s = !0);
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = t), e)
        : ((i = i !== null),
          i !== (n !== null && n.memoizedState !== null) &&
            i &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (n === null || rn.current & 1 ? In === 0 && (In = 3) : e1())),
          e.updateQueue !== null && (e.flags |= 4),
          ri(e),
          null);
    case 4:
      return (
        Gc(), Vx(n, e), n === null && zf(e.stateNode.containerInfo), ri(e), null
      );
    case 10:
      return UA(e.type._context), ri(e), null;
    case 17:
      return Bi(e.type) && Im(), ri(e), null;
    case 19:
      if ((Qt(rn), (s = e.memoizedState), s === null)) return ri(e), null;
      if (((i = (e.flags & 128) !== 0), (o = s.rendering), o === null))
        if (i) Ou(s, !1);
        else {
          if (In !== 0 || (n !== null && n.flags & 128))
            for (n = e.child; n !== null; ) {
              if (((o = Hm(n)), o !== null)) {
                for (
                  e.flags |= 128,
                    Ou(s, !1),
                    i = o.updateQueue,
                    i !== null && ((e.updateQueue = i), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    i = t,
                    t = e.child;
                  t !== null;

                )
                  (s = t),
                    (n = i),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = n),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (n = o.dependencies),
                        (s.dependencies =
                          n === null
                            ? null
                            : {
                                lanes: n.lanes,
                                firstContext: n.firstContext,
                              })),
                    (t = t.sibling);
                return jt(rn, (rn.current & 1) | 2), e.child;
              }
              n = n.sibling;
            }
          s.tail !== null &&
            _n() > Wc &&
            ((e.flags |= 128), (i = !0), Ou(s, !1), (e.lanes = 4194304));
        }
      else {
        if (!i)
          if (((n = Hm(o)), n !== null)) {
            if (
              ((e.flags |= 128),
              (i = !0),
              (t = n.updateQueue),
              t !== null && ((e.updateQueue = t), (e.flags |= 4)),
              Ou(s, !0),
              s.tail === null && s.tailMode === "hidden" && !o.alternate && !Zt)
            )
              return ri(e), null;
          } else
            2 * _n() - s.renderingStartTime > Wc &&
              t !== 1073741824 &&
              ((e.flags |= 128), (i = !0), Ou(s, !1), (e.lanes = 4194304));
        s.isBackwards
          ? ((o.sibling = e.child), (e.child = o))
          : ((t = s.last),
            t !== null ? (t.sibling = o) : (e.child = o),
            (s.last = o));
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = _n()),
          (e.sibling = null),
          (t = rn.current),
          jt(rn, i ? (t & 1) | 2 : t & 1),
          e)
        : (ri(e), null);
    case 22:
    case 23:
      return (
        $A(),
        (i = e.memoizedState !== null),
        n !== null && (n.memoizedState !== null) !== i && (e.flags |= 8192),
        i && e.mode & 1
          ? Wi & 1073741824 && (ri(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : ri(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(Ce(156, e.tag));
}
function gN(n, e) {
  switch ((IA(e), e.tag)) {
    case 1:
      return (
        Bi(e.type) && Im(),
        (n = e.flags),
        n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 3:
      return (
        Gc(),
        Qt(Pi),
        Qt(li),
        GA(),
        (n = e.flags),
        n & 65536 && !(n & 128) ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 5:
      return zA(e), null;
    case 13:
      if (
        (Qt(rn), (n = e.memoizedState), n !== null && n.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(Ce(340));
        Hc();
      }
      return (
        (n = e.flags), n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 19:
      return Qt(rn), null;
    case 4:
      return Gc(), null;
    case 10:
      return UA(e.type._context), null;
    case 22:
    case 23:
      return $A(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var tp = !1,
  ai = !1,
  vN = typeof WeakSet == "function" ? WeakSet : Set,
  je = null;
function mc(n, e) {
  var t = n.ref;
  if (t !== null)
    if (typeof t == "function")
      try {
        t(null);
      } catch (i) {
        mn(n, e, i);
      }
    else t.current = null;
}
function Wx(n, e, t) {
  try {
    t();
  } catch (i) {
    mn(n, e, i);
  }
}
var ow = !1;
function yN(n, e) {
  if (((Cx = Rm), (n = UR()), BA(n))) {
    if ("selectionStart" in n)
      var t = { start: n.selectionStart, end: n.selectionEnd };
    else
      e: {
        t = ((t = n.ownerDocument) && t.defaultView) || window;
        var i = t.getSelection && t.getSelection();
        if (i && i.rangeCount !== 0) {
          t = i.anchorNode;
          var r = i.anchorOffset,
            s = i.focusNode;
          i = i.focusOffset;
          try {
            t.nodeType, s.nodeType;
          } catch {
            t = null;
            break e;
          }
          var o = 0,
            a = -1,
            l = -1,
            u = 0,
            h = 0,
            d = n,
            p = null;
          t: for (;;) {
            for (
              var m;
              d !== t || (r !== 0 && d.nodeType !== 3) || (a = o + r),
                d !== s || (i !== 0 && d.nodeType !== 3) || (l = o + i),
                d.nodeType === 3 && (o += d.nodeValue.length),
                (m = d.firstChild) !== null;

            )
              (p = d), (d = m);
            for (;;) {
              if (d === n) break t;
              if (
                (p === t && ++u === r && (a = o),
                p === s && ++h === i && (l = o),
                (m = d.nextSibling) !== null)
              )
                break;
              (d = p), (p = d.parentNode);
            }
            d = m;
          }
          t = a === -1 || l === -1 ? null : { start: a, end: l };
        } else t = null;
      }
    t = t || { start: 0, end: 0 };
  } else t = null;
  for (
    bx = { focusedElem: n, selectionRange: t }, Rm = !1, je = e;
    je !== null;

  )
    if (((e = je), (n = e.child), (e.subtreeFlags & 1028) !== 0 && n !== null))
      (n.return = e), (je = n);
    else
      for (; je !== null; ) {
        e = je;
        try {
          var y = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (y !== null) {
                  var M = y.memoizedProps,
                    A = y.memoizedState,
                    g = e.stateNode,
                    x = g.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? M : Fr(e.type, M),
                      A
                    );
                  g.__reactInternalSnapshotBeforeUpdate = x;
                }
                break;
              case 3:
                var _ = e.stateNode.containerInfo;
                _.nodeType === 1
                  ? (_.textContent = "")
                  : _.nodeType === 9 &&
                    _.documentElement &&
                    _.removeChild(_.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(Ce(163));
            }
        } catch (E) {
          mn(e, e.return, E);
        }
        if (((n = e.sibling), n !== null)) {
          (n.return = e.return), (je = n);
          break;
        }
        je = e.return;
      }
  return (y = ow), (ow = !1), y;
}
function _f(n, e, t) {
  var i = e.updateQueue;
  if (((i = i !== null ? i.lastEffect : null), i !== null)) {
    var r = (i = i.next);
    do {
      if ((r.tag & n) === n) {
        var s = r.destroy;
        (r.destroy = void 0), s !== void 0 && Wx(e, t, s);
      }
      r = r.next;
    } while (r !== i);
  }
}
function Sg(n, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var t = (e = e.next);
    do {
      if ((t.tag & n) === n) {
        var i = t.create;
        t.destroy = i();
      }
      t = t.next;
    } while (t !== e);
  }
}
function jx(n) {
  var e = n.ref;
  if (e !== null) {
    var t = n.stateNode;
    switch (n.tag) {
      case 5:
        n = t;
        break;
      default:
        n = t;
    }
    typeof e == "function" ? e(n) : (e.current = n);
  }
}
function DP(n) {
  var e = n.alternate;
  e !== null && ((n.alternate = null), DP(e)),
    (n.child = null),
    (n.deletions = null),
    (n.sibling = null),
    n.tag === 5 &&
      ((e = n.stateNode),
      e !== null &&
        (delete e[us], delete e[Vf], delete e[Bx], delete e[eN], delete e[tN])),
    (n.stateNode = null),
    (n.return = null),
    (n.dependencies = null),
    (n.memoizedProps = null),
    (n.memoizedState = null),
    (n.pendingProps = null),
    (n.stateNode = null),
    (n.updateQueue = null);
}
function FP(n) {
  return n.tag === 5 || n.tag === 3 || n.tag === 4;
}
function aw(n) {
  e: for (;;) {
    for (; n.sibling === null; ) {
      if (n.return === null || FP(n.return)) return null;
      n = n.return;
    }
    for (
      n.sibling.return = n.return, n = n.sibling;
      n.tag !== 5 && n.tag !== 6 && n.tag !== 18;

    ) {
      if (n.flags & 2 || n.child === null || n.tag === 4) continue e;
      (n.child.return = n), (n = n.child);
    }
    if (!(n.flags & 2)) return n.stateNode;
  }
}
function Xx(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    (n = n.stateNode),
      e
        ? t.nodeType === 8
          ? t.parentNode.insertBefore(n, e)
          : t.insertBefore(n, e)
        : (t.nodeType === 8
            ? ((e = t.parentNode), e.insertBefore(n, t))
            : ((e = t), e.appendChild(n)),
          (t = t._reactRootContainer),
          t != null || e.onclick !== null || (e.onclick = Lm));
  else if (i !== 4 && ((n = n.child), n !== null))
    for (Xx(n, e, t), n = n.sibling; n !== null; ) Xx(n, e, t), (n = n.sibling);
}
function Jx(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    (n = n.stateNode), e ? t.insertBefore(n, e) : t.appendChild(n);
  else if (i !== 4 && ((n = n.child), n !== null))
    for (Jx(n, e, t), n = n.sibling; n !== null; ) Jx(n, e, t), (n = n.sibling);
}
var Jn = null,
  Ur = !1;
function ho(n, e, t) {
  for (t = t.child; t !== null; ) NP(n, e, t), (t = t.sibling);
}
function NP(n, e, t) {
  if (ds && typeof ds.onCommitFiberUnmount == "function")
    try {
      ds.onCommitFiberUnmount(pg, t);
    } catch {}
  switch (t.tag) {
    case 5:
      ai || mc(t, e);
    case 6:
      var i = Jn,
        r = Ur;
      (Jn = null),
        ho(n, e, t),
        (Jn = i),
        (Ur = r),
        Jn !== null &&
          (Ur
            ? ((n = Jn),
              (t = t.stateNode),
              n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t))
            : Jn.removeChild(t.stateNode));
      break;
    case 18:
      Jn !== null &&
        (Ur
          ? ((n = Jn),
            (t = t.stateNode),
            n.nodeType === 8
              ? zv(n.parentNode, t)
              : n.nodeType === 1 && zv(n, t),
            Of(n))
          : zv(Jn, t.stateNode));
      break;
    case 4:
      (i = Jn),
        (r = Ur),
        (Jn = t.stateNode.containerInfo),
        (Ur = !0),
        ho(n, e, t),
        (Jn = i),
        (Ur = r);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !ai &&
        ((i = t.updateQueue), i !== null && ((i = i.lastEffect), i !== null))
      ) {
        r = i = i.next;
        do {
          var s = r,
            o = s.destroy;
          (s = s.tag),
            o !== void 0 && (s & 2 || s & 4) && Wx(t, e, o),
            (r = r.next);
        } while (r !== i);
      }
      ho(n, e, t);
      break;
    case 1:
      if (
        !ai &&
        (mc(t, e),
        (i = t.stateNode),
        typeof i.componentWillUnmount == "function")
      )
        try {
          (i.props = t.memoizedProps),
            (i.state = t.memoizedState),
            i.componentWillUnmount();
        } catch (a) {
          mn(t, e, a);
        }
      ho(n, e, t);
      break;
    case 21:
      ho(n, e, t);
      break;
    case 22:
      t.mode & 1
        ? ((ai = (i = ai) || t.memoizedState !== null), ho(n, e, t), (ai = i))
        : ho(n, e, t);
      break;
    default:
      ho(n, e, t);
  }
}
function lw(n) {
  var e = n.updateQueue;
  if (e !== null) {
    n.updateQueue = null;
    var t = n.stateNode;
    t === null && (t = n.stateNode = new vN()),
      e.forEach(function (i) {
        var r = CN.bind(null, n, i);
        t.has(i) || (t.add(i), i.then(r, r));
      });
  }
}
function Br(n, e) {
  var t = e.deletions;
  if (t !== null)
    for (var i = 0; i < t.length; i++) {
      var r = t[i];
      try {
        var s = n,
          o = e,
          a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (Jn = a.stateNode), (Ur = !1);
              break e;
            case 3:
              (Jn = a.stateNode.containerInfo), (Ur = !0);
              break e;
            case 4:
              (Jn = a.stateNode.containerInfo), (Ur = !0);
              break e;
          }
          a = a.return;
        }
        if (Jn === null) throw Error(Ce(160));
        NP(s, o, r), (Jn = null), (Ur = !1);
        var l = r.alternate;
        l !== null && (l.return = null), (r.return = null);
      } catch (u) {
        mn(r, e, u);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) UP(e, n), (e = e.sibling);
}
function UP(n, e) {
  var t = n.alternate,
    i = n.flags;
  switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((Br(e, n), as(n), i & 4)) {
        try {
          _f(3, n, n.return), Sg(3, n);
        } catch (M) {
          mn(n, n.return, M);
        }
        try {
          _f(5, n, n.return);
        } catch (M) {
          mn(n, n.return, M);
        }
      }
      break;
    case 1:
      Br(e, n), as(n), i & 512 && t !== null && mc(t, t.return);
      break;
    case 5:
      if (
        (Br(e, n),
        as(n),
        i & 512 && t !== null && mc(t, t.return),
        n.flags & 32)
      ) {
        var r = n.stateNode;
        try {
          Df(r, "");
        } catch (M) {
          mn(n, n.return, M);
        }
      }
      if (i & 4 && ((r = n.stateNode), r != null)) {
        var s = n.memoizedProps,
          o = t !== null ? t.memoizedProps : s,
          a = n.type,
          l = n.updateQueue;
        if (((n.updateQueue = null), l !== null))
          try {
            a === "input" && s.type === "radio" && s.name != null && rR(r, s),
              vx(a, o);
            var u = vx(a, s);
            for (o = 0; o < l.length; o += 2) {
              var h = l[o],
                d = l[o + 1];
              h === "style"
                ? cR(r, d)
                : h === "dangerouslySetInnerHTML"
                ? aR(r, d)
                : h === "children"
                ? Df(r, d)
                : yA(r, h, d, u);
            }
            switch (a) {
              case "input":
                hx(r, s);
                break;
              case "textarea":
                sR(r, s);
                break;
              case "select":
                var p = r._wrapperState.wasMultiple;
                r._wrapperState.wasMultiple = !!s.multiple;
                var m = s.value;
                m != null
                  ? Tc(r, !!s.multiple, m, !1)
                  : p !== !!s.multiple &&
                    (s.defaultValue != null
                      ? Tc(r, !!s.multiple, s.defaultValue, !0)
                      : Tc(r, !!s.multiple, s.multiple ? [] : "", !1));
            }
            r[Vf] = s;
          } catch (M) {
            mn(n, n.return, M);
          }
      }
      break;
    case 6:
      if ((Br(e, n), as(n), i & 4)) {
        if (n.stateNode === null) throw Error(Ce(162));
        (r = n.stateNode), (s = n.memoizedProps);
        try {
          r.nodeValue = s;
        } catch (M) {
          mn(n, n.return, M);
        }
      }
      break;
    case 3:
      if (
        (Br(e, n), as(n), i & 4 && t !== null && t.memoizedState.isDehydrated)
      )
        try {
          Of(e.containerInfo);
        } catch (M) {
          mn(n, n.return, M);
        }
      break;
    case 4:
      Br(e, n), as(n);
      break;
    case 13:
      Br(e, n),
        as(n),
        (r = n.child),
        r.flags & 8192 &&
          ((s = r.memoizedState !== null),
          (r.stateNode.isHidden = s),
          !s ||
            (r.alternate !== null && r.alternate.memoizedState !== null) ||
            (qA = _n())),
        i & 4 && lw(n);
      break;
    case 22:
      if (
        ((h = t !== null && t.memoizedState !== null),
        n.mode & 1 ? ((ai = (u = ai) || h), Br(e, n), (ai = u)) : Br(e, n),
        as(n),
        i & 8192)
      ) {
        if (
          ((u = n.memoizedState !== null),
          (n.stateNode.isHidden = u) && !h && n.mode & 1)
        )
          for (je = n, h = n.child; h !== null; ) {
            for (d = je = h; je !== null; ) {
              switch (((p = je), (m = p.child), p.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  _f(4, p, p.return);
                  break;
                case 1:
                  mc(p, p.return);
                  var y = p.stateNode;
                  if (typeof y.componentWillUnmount == "function") {
                    (i = p), (t = p.return);
                    try {
                      (e = i),
                        (y.props = e.memoizedProps),
                        (y.state = e.memoizedState),
                        y.componentWillUnmount();
                    } catch (M) {
                      mn(i, t, M);
                    }
                  }
                  break;
                case 5:
                  mc(p, p.return);
                  break;
                case 22:
                  if (p.memoizedState !== null) {
                    uw(d);
                    continue;
                  }
              }
              m !== null ? ((m.return = p), (je = m)) : uw(d);
            }
            h = h.sibling;
          }
        e: for (h = null, d = n; ; ) {
          if (d.tag === 5) {
            if (h === null) {
              h = d;
              try {
                (r = d.stateNode),
                  u
                    ? ((s = r.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((a = d.stateNode),
                      (l = d.memoizedProps.style),
                      (o =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (a.style.display = lR("display", o)));
              } catch (M) {
                mn(n, n.return, M);
              }
            }
          } else if (d.tag === 6) {
            if (h === null)
              try {
                d.stateNode.nodeValue = u ? "" : d.memoizedProps;
              } catch (M) {
                mn(n, n.return, M);
              }
          } else if (
            ((d.tag !== 22 && d.tag !== 23) ||
              d.memoizedState === null ||
              d === n) &&
            d.child !== null
          ) {
            (d.child.return = d), (d = d.child);
            continue;
          }
          if (d === n) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === n) break e;
            h === d && (h = null), (d = d.return);
          }
          h === d && (h = null), (d.sibling.return = d.return), (d = d.sibling);
        }
      }
      break;
    case 19:
      Br(e, n), as(n), i & 4 && lw(n);
      break;
    case 21:
      break;
    default:
      Br(e, n), as(n);
  }
}
function as(n) {
  var e = n.flags;
  if (e & 2) {
    try {
      e: {
        for (var t = n.return; t !== null; ) {
          if (FP(t)) {
            var i = t;
            break e;
          }
          t = t.return;
        }
        throw Error(Ce(160));
      }
      switch (i.tag) {
        case 5:
          var r = i.stateNode;
          i.flags & 32 && (Df(r, ""), (i.flags &= -33));
          var s = aw(n);
          Jx(n, s, r);
          break;
        case 3:
        case 4:
          var o = i.stateNode.containerInfo,
            a = aw(n);
          Xx(n, a, o);
          break;
        default:
          throw Error(Ce(161));
      }
    } catch (l) {
      mn(n, n.return, l);
    }
    n.flags &= -3;
  }
  e & 4096 && (n.flags &= -4097);
}
function xN(n, e, t) {
  (je = n), OP(n);
}
function OP(n, e, t) {
  for (var i = (n.mode & 1) !== 0; je !== null; ) {
    var r = je,
      s = r.child;
    if (r.tag === 22 && i) {
      var o = r.memoizedState !== null || tp;
      if (!o) {
        var a = r.alternate,
          l = (a !== null && a.memoizedState !== null) || ai;
        a = tp;
        var u = ai;
        if (((tp = o), (ai = l) && !u))
          for (je = r; je !== null; )
            (o = je),
              (l = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? fw(r)
                : l !== null
                ? ((l.return = o), (je = l))
                : fw(r);
        for (; s !== null; ) (je = s), OP(s), (s = s.sibling);
        (je = r), (tp = a), (ai = u);
      }
      cw(n);
    } else
      r.subtreeFlags & 8772 && s !== null ? ((s.return = r), (je = s)) : cw(n);
  }
}
function cw(n) {
  for (; je !== null; ) {
    var e = je;
    if (e.flags & 8772) {
      var t = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              ai || Sg(5, e);
              break;
            case 1:
              var i = e.stateNode;
              if (e.flags & 4 && !ai)
                if (t === null) i.componentDidMount();
                else {
                  var r =
                    e.elementType === e.type
                      ? t.memoizedProps
                      : Fr(e.type, t.memoizedProps);
                  i.componentDidUpdate(
                    r,
                    t.memoizedState,
                    i.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = e.updateQueue;
              s !== null && XE(e, s, i);
              break;
            case 3:
              var o = e.updateQueue;
              if (o !== null) {
                if (((t = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      t = e.child.stateNode;
                      break;
                    case 1:
                      t = e.child.stateNode;
                  }
                XE(e, o, t);
              }
              break;
            case 5:
              var a = e.stateNode;
              if (t === null && e.flags & 4) {
                t = a;
                var l = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && t.focus();
                    break;
                  case "img":
                    l.src && (t.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var u = e.alternate;
                if (u !== null) {
                  var h = u.memoizedState;
                  if (h !== null) {
                    var d = h.dehydrated;
                    d !== null && Of(d);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(Ce(163));
          }
        ai || (e.flags & 512 && jx(e));
      } catch (p) {
        mn(e, e.return, p);
      }
    }
    if (e === n) {
      je = null;
      break;
    }
    if (((t = e.sibling), t !== null)) {
      (t.return = e.return), (je = t);
      break;
    }
    je = e.return;
  }
}
function uw(n) {
  for (; je !== null; ) {
    var e = je;
    if (e === n) {
      je = null;
      break;
    }
    var t = e.sibling;
    if (t !== null) {
      (t.return = e.return), (je = t);
      break;
    }
    je = e.return;
  }
}
function fw(n) {
  for (; je !== null; ) {
    var e = je;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var t = e.return;
          try {
            Sg(4, e);
          } catch (l) {
            mn(e, t, l);
          }
          break;
        case 1:
          var i = e.stateNode;
          if (typeof i.componentDidMount == "function") {
            var r = e.return;
            try {
              i.componentDidMount();
            } catch (l) {
              mn(e, r, l);
            }
          }
          var s = e.return;
          try {
            jx(e);
          } catch (l) {
            mn(e, s, l);
          }
          break;
        case 5:
          var o = e.return;
          try {
            jx(e);
          } catch (l) {
            mn(e, o, l);
          }
      }
    } catch (l) {
      mn(e, e.return, l);
    }
    if (e === n) {
      je = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      (a.return = e.return), (je = a);
      break;
    }
    je = e.return;
  }
}
var _N = Math.ceil,
  Vm = to.ReactCurrentDispatcher,
  YA = to.ReactCurrentOwner,
  Mr = to.ReactCurrentBatchConfig,
  Bt = 0,
  Vn = null,
  Cn = null,
  Yn = 0,
  Wi = 0,
  gc = ta(0),
  In = 0,
  Yf = null,
  rl = 0,
  Mg = 0,
  QA = 0,
  Af = null,
  Ti = null,
  qA = 0,
  Wc = 1 / 0,
  Us = null,
  Wm = !1,
  Kx = null,
  No = null,
  np = !1,
  Ro = null,
  jm = 0,
  Sf = 0,
  Yx = null,
  cm = -1,
  um = 0;
function yi() {
  return Bt & 6 ? _n() : cm !== -1 ? cm : (cm = _n());
}
function Uo(n) {
  return n.mode & 1
    ? Bt & 2 && Yn !== 0
      ? Yn & -Yn
      : iN.transition !== null
      ? (um === 0 && (um = AR()), um)
      : ((n = Ot),
        n !== 0 || ((n = window.event), (n = n === void 0 ? 16 : bR(n.type))),
        n)
    : 1;
}
function zr(n, e, t, i) {
  if (50 < Sf) throw ((Sf = 0), (Yx = null), Error(Ce(185)));
  vh(n, t, i),
    (!(Bt & 2) || n !== Vn) &&
      (n === Vn && (!(Bt & 2) && (Mg |= t), In === 4 && Co(n, Yn)),
      Li(n, i),
      t === 1 && Bt === 0 && !(e.mode & 1) && ((Wc = _n() + 500), xg && na()));
}
function Li(n, e) {
  var t = n.callbackNode;
  iF(n, e);
  var i = bm(n, n === Vn ? Yn : 0);
  if (i === 0)
    t !== null && _E(t), (n.callbackNode = null), (n.callbackPriority = 0);
  else if (((e = i & -i), n.callbackPriority !== e)) {
    if ((t != null && _E(t), e === 1))
      n.tag === 0 ? nN(hw.bind(null, n)) : JR(hw.bind(null, n)),
        ZF(function () {
          !(Bt & 6) && na();
        }),
        (t = null);
    else {
      switch (SR(i)) {
        case 1:
          t = MA;
          break;
        case 4:
          t = xR;
          break;
        case 16:
          t = Cm;
          break;
        case 536870912:
          t = _R;
          break;
        default:
          t = Cm;
      }
      t = XP(t, kP.bind(null, n));
    }
    (n.callbackPriority = e), (n.callbackNode = t);
  }
}
function kP(n, e) {
  if (((cm = -1), (um = 0), Bt & 6)) throw Error(Ce(327));
  var t = n.callbackNode;
  if (Bc() && n.callbackNode !== t) return null;
  var i = bm(n, n === Vn ? Yn : 0);
  if (i === 0) return null;
  if (i & 30 || i & n.expiredLanes || e) e = Xm(n, i);
  else {
    e = i;
    var r = Bt;
    Bt |= 2;
    var s = zP();
    (Vn !== n || Yn !== e) && ((Us = null), (Wc = _n() + 500), Ja(n, e));
    do
      try {
        MN();
        break;
      } catch (a) {
        HP(n, a);
      }
    while (1);
    NA(),
      (Vm.current = s),
      (Bt = r),
      Cn !== null ? (e = 0) : ((Vn = null), (Yn = 0), (e = In));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((r = Sx(n)), r !== 0 && ((i = r), (e = Qx(n, r)))), e === 1)
    )
      throw ((t = Yf), Ja(n, 0), Co(n, i), Li(n, _n()), t);
    if (e === 6) Co(n, i);
    else {
      if (
        ((r = n.current.alternate),
        !(i & 30) &&
          !AN(r) &&
          ((e = Xm(n, i)),
          e === 2 && ((s = Sx(n)), s !== 0 && ((i = s), (e = Qx(n, s)))),
          e === 1))
      )
        throw ((t = Yf), Ja(n, 0), Co(n, i), Li(n, _n()), t);
      switch (((n.finishedWork = r), (n.finishedLanes = i), e)) {
        case 0:
        case 1:
          throw Error(Ce(345));
        case 2:
          Ra(n, Ti, Us);
          break;
        case 3:
          if (
            (Co(n, i), (i & 130023424) === i && ((e = qA + 500 - _n()), 10 < e))
          ) {
            if (bm(n, 0) !== 0) break;
            if (((r = n.suspendedLanes), (r & i) !== i)) {
              yi(), (n.pingedLanes |= n.suspendedLanes & r);
              break;
            }
            n.timeoutHandle = Px(Ra.bind(null, n, Ti, Us), e);
            break;
          }
          Ra(n, Ti, Us);
          break;
        case 4:
          if ((Co(n, i), (i & 4194240) === i)) break;
          for (e = n.eventTimes, r = -1; 0 < i; ) {
            var o = 31 - Hr(i);
            (s = 1 << o), (o = e[o]), o > r && (r = o), (i &= ~s);
          }
          if (
            ((i = r),
            (i = _n() - i),
            (i =
              (120 > i
                ? 120
                : 480 > i
                ? 480
                : 1080 > i
                ? 1080
                : 1920 > i
                ? 1920
                : 3e3 > i
                ? 3e3
                : 4320 > i
                ? 4320
                : 1960 * _N(i / 1960)) - i),
            10 < i)
          ) {
            n.timeoutHandle = Px(Ra.bind(null, n, Ti, Us), i);
            break;
          }
          Ra(n, Ti, Us);
          break;
        case 5:
          Ra(n, Ti, Us);
          break;
        default:
          throw Error(Ce(329));
      }
    }
  }
  return Li(n, _n()), n.callbackNode === t ? kP.bind(null, n) : null;
}
function Qx(n, e) {
  var t = Af;
  return (
    n.current.memoizedState.isDehydrated && (Ja(n, e).flags |= 256),
    (n = Xm(n, e)),
    n !== 2 && ((e = Ti), (Ti = t), e !== null && qx(e)),
    n
  );
}
function qx(n) {
  Ti === null ? (Ti = n) : Ti.push.apply(Ti, n);
}
function AN(n) {
  for (var e = n; ; ) {
    if (e.flags & 16384) {
      var t = e.updateQueue;
      if (t !== null && ((t = t.stores), t !== null))
        for (var i = 0; i < t.length; i++) {
          var r = t[i],
            s = r.getSnapshot;
          r = r.value;
          try {
            if (!jr(s(), r)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((t = e.child), e.subtreeFlags & 16384 && t !== null))
      (t.return = e), (e = t);
    else {
      if (e === n) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === n) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function Co(n, e) {
  for (
    e &= ~QA,
      e &= ~Mg,
      n.suspendedLanes |= e,
      n.pingedLanes &= ~e,
      n = n.expirationTimes;
    0 < e;

  ) {
    var t = 31 - Hr(e),
      i = 1 << t;
    (n[t] = -1), (e &= ~i);
  }
}
function hw(n) {
  if (Bt & 6) throw Error(Ce(327));
  Bc();
  var e = bm(n, 0);
  if (!(e & 1)) return Li(n, _n()), null;
  var t = Xm(n, e);
  if (n.tag !== 0 && t === 2) {
    var i = Sx(n);
    i !== 0 && ((e = i), (t = Qx(n, i)));
  }
  if (t === 1) throw ((t = Yf), Ja(n, 0), Co(n, e), Li(n, _n()), t);
  if (t === 6) throw Error(Ce(345));
  return (
    (n.finishedWork = n.current.alternate),
    (n.finishedLanes = e),
    Ra(n, Ti, Us),
    Li(n, _n()),
    null
  );
}
function ZA(n, e) {
  var t = Bt;
  Bt |= 1;
  try {
    return n(e);
  } finally {
    (Bt = t), Bt === 0 && ((Wc = _n() + 500), xg && na());
  }
}
function sl(n) {
  Ro !== null && Ro.tag === 0 && !(Bt & 6) && Bc();
  var e = Bt;
  Bt |= 1;
  var t = Mr.transition,
    i = Ot;
  try {
    if (((Mr.transition = null), (Ot = 1), n)) return n();
  } finally {
    (Ot = i), (Mr.transition = t), (Bt = e), !(Bt & 6) && na();
  }
}
function $A() {
  (Wi = gc.current), Qt(gc);
}
function Ja(n, e) {
  (n.finishedWork = null), (n.finishedLanes = 0);
  var t = n.timeoutHandle;
  if ((t !== -1 && ((n.timeoutHandle = -1), qF(t)), Cn !== null))
    for (t = Cn.return; t !== null; ) {
      var i = t;
      switch ((IA(i), i.tag)) {
        case 1:
          (i = i.type.childContextTypes), i != null && Im();
          break;
        case 3:
          Gc(), Qt(Pi), Qt(li), GA();
          break;
        case 5:
          zA(i);
          break;
        case 4:
          Gc();
          break;
        case 13:
          Qt(rn);
          break;
        case 19:
          Qt(rn);
          break;
        case 10:
          UA(i.type._context);
          break;
        case 22:
        case 23:
          $A();
      }
      t = t.return;
    }
  if (
    ((Vn = n),
    (Cn = n = Oo(n.current, null)),
    (Yn = Wi = e),
    (In = 0),
    (Yf = null),
    (QA = Mg = rl = 0),
    (Ti = Af = null),
    Oa !== null)
  ) {
    for (e = 0; e < Oa.length; e++)
      if (((t = Oa[e]), (i = t.interleaved), i !== null)) {
        t.interleaved = null;
        var r = i.next,
          s = t.pending;
        if (s !== null) {
          var o = s.next;
          (s.next = r), (i.next = o);
        }
        t.pending = i;
      }
    Oa = null;
  }
  return n;
}
function HP(n, e) {
  do {
    var t = Cn;
    try {
      if ((NA(), (om.current = Gm), zm)) {
        for (var i = cn.memoizedState; i !== null; ) {
          var r = i.queue;
          r !== null && (r.pending = null), (i = i.next);
        }
        zm = !1;
      }
      if (
        ((il = 0),
        (zn = Bn = cn = null),
        (xf = !1),
        (Xf = 0),
        (YA.current = null),
        t === null || t.return === null)
      ) {
        (In = 1), (Yf = e), (Cn = null);
        break;
      }
      e: {
        var s = n,
          o = t.return,
          a = t,
          l = e;
        if (
          ((e = Yn),
          (a.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var u = l,
            h = a,
            d = h.tag;
          if (!(h.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var p = h.alternate;
            p
              ? ((h.updateQueue = p.updateQueue),
                (h.memoizedState = p.memoizedState),
                (h.lanes = p.lanes))
              : ((h.updateQueue = null), (h.memoizedState = null));
          }
          var m = $E(o);
          if (m !== null) {
            (m.flags &= -257),
              ew(m, o, a, s, e),
              m.mode & 1 && ZE(s, u, e),
              (e = m),
              (l = u);
            var y = e.updateQueue;
            if (y === null) {
              var M = new Set();
              M.add(l), (e.updateQueue = M);
            } else y.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              ZE(s, u, e), e1();
              break e;
            }
            l = Error(Ce(426));
          }
        } else if (Zt && a.mode & 1) {
          var A = $E(o);
          if (A !== null) {
            !(A.flags & 65536) && (A.flags |= 256),
              ew(A, o, a, s, e),
              DA(Vc(l, a));
            break e;
          }
        }
        (s = l = Vc(l, a)),
          In !== 4 && (In = 2),
          Af === null ? (Af = [s]) : Af.push(s),
          (s = o);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (e &= -e), (s.lanes |= e);
              var g = MP(s, l, e);
              jE(s, g);
              break e;
            case 1:
              a = l;
              var x = s.type,
                _ = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof x.getDerivedStateFromError == "function" ||
                  (_ !== null &&
                    typeof _.componentDidCatch == "function" &&
                    (No === null || !No.has(_))))
              ) {
                (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                var E = EP(s, a, e);
                jE(s, E);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      VP(t);
    } catch (T) {
      (e = T), Cn === t && t !== null && (Cn = t = t.return);
      continue;
    }
    break;
  } while (1);
}
function zP() {
  var n = Vm.current;
  return (Vm.current = Gm), n === null ? Gm : n;
}
function e1() {
  (In === 0 || In === 3 || In === 2) && (In = 4),
    Vn === null || (!(rl & 268435455) && !(Mg & 268435455)) || Co(Vn, Yn);
}
function Xm(n, e) {
  var t = Bt;
  Bt |= 2;
  var i = zP();
  (Vn !== n || Yn !== e) && ((Us = null), Ja(n, e));
  do
    try {
      SN();
      break;
    } catch (r) {
      HP(n, r);
    }
  while (1);
  if ((NA(), (Bt = t), (Vm.current = i), Cn !== null)) throw Error(Ce(261));
  return (Vn = null), (Yn = 0), In;
}
function SN() {
  for (; Cn !== null; ) GP(Cn);
}
function MN() {
  for (; Cn !== null && !K3(); ) GP(Cn);
}
function GP(n) {
  var e = jP(n.alternate, n, Wi);
  (n.memoizedProps = n.pendingProps),
    e === null ? VP(n) : (Cn = e),
    (YA.current = null);
}
function VP(n) {
  var e = n;
  do {
    var t = e.alternate;
    if (((n = e.return), e.flags & 32768)) {
      if (((t = gN(t, e)), t !== null)) {
        (t.flags &= 32767), (Cn = t);
        return;
      }
      if (n !== null)
        (n.flags |= 32768), (n.subtreeFlags = 0), (n.deletions = null);
      else {
        (In = 6), (Cn = null);
        return;
      }
    } else if (((t = mN(t, e, Wi)), t !== null)) {
      Cn = t;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Cn = e;
      return;
    }
    Cn = e = n;
  } while (e !== null);
  In === 0 && (In = 5);
}
function Ra(n, e, t) {
  var i = Ot,
    r = Mr.transition;
  try {
    (Mr.transition = null), (Ot = 1), EN(n, e, t, i);
  } finally {
    (Mr.transition = r), (Ot = i);
  }
  return null;
}
function EN(n, e, t, i) {
  do Bc();
  while (Ro !== null);
  if (Bt & 6) throw Error(Ce(327));
  t = n.finishedWork;
  var r = n.finishedLanes;
  if (t === null) return null;
  if (((n.finishedWork = null), (n.finishedLanes = 0), t === n.current))
    throw Error(Ce(177));
  (n.callbackNode = null), (n.callbackPriority = 0);
  var s = t.lanes | t.childLanes;
  if (
    (rF(n, s),
    n === Vn && ((Cn = Vn = null), (Yn = 0)),
    (!(t.subtreeFlags & 2064) && !(t.flags & 2064)) ||
      np ||
      ((np = !0),
      XP(Cm, function () {
        return Bc(), null;
      })),
    (s = (t.flags & 15990) !== 0),
    t.subtreeFlags & 15990 || s)
  ) {
    (s = Mr.transition), (Mr.transition = null);
    var o = Ot;
    Ot = 1;
    var a = Bt;
    (Bt |= 4),
      (YA.current = null),
      yN(n, t),
      UP(t, n),
      WF(bx),
      (Rm = !!Cx),
      (bx = Cx = null),
      (n.current = t),
      xN(t),
      Y3(),
      (Bt = a),
      (Ot = o),
      (Mr.transition = s);
  } else n.current = t;
  if (
    (np && ((np = !1), (Ro = n), (jm = r)),
    (s = n.pendingLanes),
    s === 0 && (No = null),
    Z3(t.stateNode),
    Li(n, _n()),
    e !== null)
  )
    for (i = n.onRecoverableError, t = 0; t < e.length; t++)
      (r = e[t]), i(r.value, { componentStack: r.stack, digest: r.digest });
  if (Wm) throw ((Wm = !1), (n = Kx), (Kx = null), n);
  return (
    jm & 1 && n.tag !== 0 && Bc(),
    (s = n.pendingLanes),
    s & 1 ? (n === Yx ? Sf++ : ((Sf = 0), (Yx = n))) : (Sf = 0),
    na(),
    null
  );
}
function Bc() {
  if (Ro !== null) {
    var n = SR(jm),
      e = Mr.transition,
      t = Ot;
    try {
      if (((Mr.transition = null), (Ot = 16 > n ? 16 : n), Ro === null))
        var i = !1;
      else {
        if (((n = Ro), (Ro = null), (jm = 0), Bt & 6)) throw Error(Ce(331));
        var r = Bt;
        for (Bt |= 4, je = n.current; je !== null; ) {
          var s = je,
            o = s.child;
          if (je.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var u = a[l];
                for (je = u; je !== null; ) {
                  var h = je;
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      _f(8, h, s);
                  }
                  var d = h.child;
                  if (d !== null) (d.return = h), (je = d);
                  else
                    for (; je !== null; ) {
                      h = je;
                      var p = h.sibling,
                        m = h.return;
                      if ((DP(h), h === u)) {
                        je = null;
                        break;
                      }
                      if (p !== null) {
                        (p.return = m), (je = p);
                        break;
                      }
                      je = m;
                    }
                }
              }
              var y = s.alternate;
              if (y !== null) {
                var M = y.child;
                if (M !== null) {
                  y.child = null;
                  do {
                    var A = M.sibling;
                    (M.sibling = null), (M = A);
                  } while (M !== null);
                }
              }
              je = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (je = o);
          else
            e: for (; je !== null; ) {
              if (((s = je), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    _f(9, s, s.return);
                }
              var g = s.sibling;
              if (g !== null) {
                (g.return = s.return), (je = g);
                break e;
              }
              je = s.return;
            }
        }
        var x = n.current;
        for (je = x; je !== null; ) {
          o = je;
          var _ = o.child;
          if (o.subtreeFlags & 2064 && _ !== null) (_.return = o), (je = _);
          else
            e: for (o = x; je !== null; ) {
              if (((a = je), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Sg(9, a);
                  }
                } catch (T) {
                  mn(a, a.return, T);
                }
              if (a === o) {
                je = null;
                break e;
              }
              var E = a.sibling;
              if (E !== null) {
                (E.return = a.return), (je = E);
                break e;
              }
              je = a.return;
            }
        }
        if (
          ((Bt = r), na(), ds && typeof ds.onPostCommitFiberRoot == "function")
        )
          try {
            ds.onPostCommitFiberRoot(pg, n);
          } catch {}
        i = !0;
      }
      return i;
    } finally {
      (Ot = t), (Mr.transition = e);
    }
  }
  return !1;
}
function dw(n, e, t) {
  (e = Vc(t, e)),
    (e = MP(n, e, 1)),
    (n = Fo(n, e, 1)),
    (e = yi()),
    n !== null && (vh(n, 1, e), Li(n, e));
}
function mn(n, e, t) {
  if (n.tag === 3) dw(n, n, t);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        dw(e, n, t);
        break;
      } else if (e.tag === 1) {
        var i = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof i.componentDidCatch == "function" &&
            (No === null || !No.has(i)))
        ) {
          (n = Vc(t, n)),
            (n = EP(e, n, 1)),
            (e = Fo(e, n, 1)),
            (n = yi()),
            e !== null && (vh(e, 1, n), Li(e, n));
          break;
        }
      }
      e = e.return;
    }
}
function wN(n, e, t) {
  var i = n.pingCache;
  i !== null && i.delete(e),
    (e = yi()),
    (n.pingedLanes |= n.suspendedLanes & t),
    Vn === n &&
      (Yn & t) === t &&
      (In === 4 || (In === 3 && (Yn & 130023424) === Yn && 500 > _n() - qA)
        ? Ja(n, 0)
        : (QA |= t)),
    Li(n, e);
}
function WP(n, e) {
  e === 0 &&
    (n.mode & 1
      ? ((e = Xd), (Xd <<= 1), !(Xd & 130023424) && (Xd = 4194304))
      : (e = 1));
  var t = yi();
  (n = qs(n, e)), n !== null && (vh(n, e, t), Li(n, t));
}
function TN(n) {
  var e = n.memoizedState,
    t = 0;
  e !== null && (t = e.retryLane), WP(n, t);
}
function CN(n, e) {
  var t = 0;
  switch (n.tag) {
    case 13:
      var i = n.stateNode,
        r = n.memoizedState;
      r !== null && (t = r.retryLane);
      break;
    case 19:
      i = n.stateNode;
      break;
    default:
      throw Error(Ce(314));
  }
  i !== null && i.delete(e), WP(n, t);
}
var jP;
jP = function (n, e, t) {
  if (n !== null)
    if (n.memoizedProps !== e.pendingProps || Pi.current) Ri = !0;
    else {
      if (!(n.lanes & t) && !(e.flags & 128)) return (Ri = !1), pN(n, e, t);
      Ri = !!(n.flags & 131072);
    }
  else (Ri = !1), Zt && e.flags & 1048576 && KR(e, Nm, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var i = e.type;
      lm(n, e), (n = e.pendingProps);
      var r = kc(e, li.current);
      Pc(e, t), (r = WA(null, e, i, n, r, t));
      var s = jA();
      return (
        (e.flags |= 1),
        typeof r == "object" &&
        r !== null &&
        typeof r.render == "function" &&
        r.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            Bi(i) ? ((s = !0), Dm(e)) : (s = !1),
            (e.memoizedState =
              r.state !== null && r.state !== void 0 ? r.state : null),
            kA(e),
            (r.updater = _g),
            (e.stateNode = r),
            (r._reactInternals = e),
            Ux(e, i, n, t),
            (e = Hx(null, e, i, !0, s, t)))
          : ((e.tag = 0), Zt && s && LA(e), gi(null, e, r, t), (e = e.child)),
        e
      );
    case 16:
      i = e.elementType;
      e: {
        switch (
          (lm(n, e),
          (n = e.pendingProps),
          (r = i._init),
          (i = r(i._payload)),
          (e.type = i),
          (r = e.tag = RN(i)),
          (n = Fr(i, n)),
          r)
        ) {
          case 0:
            e = kx(null, e, i, n, t);
            break e;
          case 1:
            e = iw(null, e, i, n, t);
            break e;
          case 11:
            e = tw(null, e, i, n, t);
            break e;
          case 14:
            e = nw(null, e, i, Fr(i.type, n), t);
            break e;
        }
        throw Error(Ce(306, i, ""));
      }
      return e;
    case 0:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Fr(i, r)),
        kx(n, e, i, r, t)
      );
    case 1:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Fr(i, r)),
        iw(n, e, i, r, t)
      );
    case 3:
      e: {
        if ((bP(e), n === null)) throw Error(Ce(387));
        (i = e.pendingProps),
          (s = e.memoizedState),
          (r = s.element),
          ZR(n, e),
          km(e, i, null, t);
        var o = e.memoizedState;
        if (((i = o.element), s.isDehydrated))
          if (
            ((s = {
              element: i,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            (r = Vc(Error(Ce(423)), e)), (e = rw(n, e, i, t, r));
            break e;
          } else if (i !== r) {
            (r = Vc(Error(Ce(424)), e)), (e = rw(n, e, i, t, r));
            break e;
          } else
            for (
              ji = Do(e.stateNode.containerInfo.firstChild),
                Qi = e,
                Zt = !0,
                Or = null,
                t = nP(e, null, i, t),
                e.child = t;
              t;

            )
              (t.flags = (t.flags & -3) | 4096), (t = t.sibling);
        else {
          if ((Hc(), i === r)) {
            e = Zs(n, e, t);
            break e;
          }
          gi(n, e, i, t);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        iP(e),
        n === null && Dx(e),
        (i = e.type),
        (r = e.pendingProps),
        (s = n !== null ? n.memoizedProps : null),
        (o = r.children),
        Rx(i, r) ? (o = null) : s !== null && Rx(i, s) && (e.flags |= 32),
        CP(n, e),
        gi(n, e, o, t),
        e.child
      );
    case 6:
      return n === null && Dx(e), null;
    case 13:
      return RP(n, e, t);
    case 4:
      return (
        HA(e, e.stateNode.containerInfo),
        (i = e.pendingProps),
        n === null ? (e.child = zc(e, null, i, t)) : gi(n, e, i, t),
        e.child
      );
    case 11:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Fr(i, r)),
        tw(n, e, i, r, t)
      );
    case 7:
      return gi(n, e, e.pendingProps, t), e.child;
    case 8:
      return gi(n, e, e.pendingProps.children, t), e.child;
    case 12:
      return gi(n, e, e.pendingProps.children, t), e.child;
    case 10:
      e: {
        if (
          ((i = e.type._context),
          (r = e.pendingProps),
          (s = e.memoizedProps),
          (o = r.value),
          jt(Um, i._currentValue),
          (i._currentValue = o),
          s !== null)
        )
          if (jr(s.value, o)) {
            if (s.children === r.children && !Pi.current) {
              e = Zs(n, e, t);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var l = a.firstContext; l !== null; ) {
                  if (l.context === i) {
                    if (s.tag === 1) {
                      (l = js(-1, t & -t)), (l.tag = 2);
                      var u = s.updateQueue;
                      if (u !== null) {
                        u = u.shared;
                        var h = u.pending;
                        h === null
                          ? (l.next = l)
                          : ((l.next = h.next), (h.next = l)),
                          (u.pending = l);
                      }
                    }
                    (s.lanes |= t),
                      (l = s.alternate),
                      l !== null && (l.lanes |= t),
                      Fx(s.return, t, e),
                      (a.lanes |= t);
                    break;
                  }
                  l = l.next;
                }
              } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(Ce(341));
                (o.lanes |= t),
                  (a = o.alternate),
                  a !== null && (a.lanes |= t),
                  Fx(o, t, e),
                  (o = s.sibling);
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === e) {
                    o = null;
                    break;
                  }
                  if (((s = o.sibling), s !== null)) {
                    (s.return = o.return), (o = s);
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        gi(n, e, r.children, t), (e = e.child);
      }
      return e;
    case 9:
      return (
        (r = e.type),
        (i = e.pendingProps.children),
        Pc(e, t),
        (r = Er(r)),
        (i = i(r)),
        (e.flags |= 1),
        gi(n, e, i, t),
        e.child
      );
    case 14:
      return (
        (i = e.type),
        (r = Fr(i, e.pendingProps)),
        (r = Fr(i.type, r)),
        nw(n, e, i, r, t)
      );
    case 15:
      return wP(n, e, e.type, e.pendingProps, t);
    case 17:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Fr(i, r)),
        lm(n, e),
        (e.tag = 1),
        Bi(i) ? ((n = !0), Dm(e)) : (n = !1),
        Pc(e, t),
        eP(e, i, r),
        Ux(e, i, r, t),
        Hx(null, e, i, !0, n, t)
      );
    case 19:
      return PP(n, e, t);
    case 22:
      return TP(n, e, t);
  }
  throw Error(Ce(156, e.tag));
};
function XP(n, e) {
  return yR(n, e);
}
function bN(n, e, t, i) {
  (this.tag = n),
    (this.key = t),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = i),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function Sr(n, e, t, i) {
  return new bN(n, e, t, i);
}
function t1(n) {
  return (n = n.prototype), !(!n || !n.isReactComponent);
}
function RN(n) {
  if (typeof n == "function") return t1(n) ? 1 : 0;
  if (n != null) {
    if (((n = n.$$typeof), n === _A)) return 11;
    if (n === AA) return 14;
  }
  return 2;
}
function Oo(n, e) {
  var t = n.alternate;
  return (
    t === null
      ? ((t = Sr(n.tag, e, n.key, n.mode)),
        (t.elementType = n.elementType),
        (t.type = n.type),
        (t.stateNode = n.stateNode),
        (t.alternate = n),
        (n.alternate = t))
      : ((t.pendingProps = e),
        (t.type = n.type),
        (t.flags = 0),
        (t.subtreeFlags = 0),
        (t.deletions = null)),
    (t.flags = n.flags & 14680064),
    (t.childLanes = n.childLanes),
    (t.lanes = n.lanes),
    (t.child = n.child),
    (t.memoizedProps = n.memoizedProps),
    (t.memoizedState = n.memoizedState),
    (t.updateQueue = n.updateQueue),
    (e = n.dependencies),
    (t.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (t.sibling = n.sibling),
    (t.index = n.index),
    (t.ref = n.ref),
    t
  );
}
function fm(n, e, t, i, r, s) {
  var o = 2;
  if (((i = n), typeof n == "function")) t1(n) && (o = 1);
  else if (typeof n == "string") o = 5;
  else
    e: switch (n) {
      case oc:
        return Ka(t.children, r, s, e);
      case xA:
        (o = 8), (r |= 8);
        break;
      case ax:
        return (
          (n = Sr(12, t, e, r | 2)), (n.elementType = ax), (n.lanes = s), n
        );
      case lx:
        return (n = Sr(13, t, e, r)), (n.elementType = lx), (n.lanes = s), n;
      case cx:
        return (n = Sr(19, t, e, r)), (n.elementType = cx), (n.lanes = s), n;
      case tR:
        return Eg(t, r, s, e);
      default:
        if (typeof n == "object" && n !== null)
          switch (n.$$typeof) {
            case $b:
              o = 10;
              break e;
            case eR:
              o = 9;
              break e;
            case _A:
              o = 11;
              break e;
            case AA:
              o = 14;
              break e;
            case Ao:
              (o = 16), (i = null);
              break e;
          }
        throw Error(Ce(130, n == null ? n : typeof n, ""));
    }
  return (
    (e = Sr(o, t, e, r)), (e.elementType = n), (e.type = i), (e.lanes = s), e
  );
}
function Ka(n, e, t, i) {
  return (n = Sr(7, n, i, e)), (n.lanes = t), n;
}
function Eg(n, e, t, i) {
  return (
    (n = Sr(22, n, i, e)),
    (n.elementType = tR),
    (n.lanes = t),
    (n.stateNode = { isHidden: !1 }),
    n
  );
}
function Yv(n, e, t) {
  return (n = Sr(6, n, null, e)), (n.lanes = t), n;
}
function Qv(n, e, t) {
  return (
    (e = Sr(4, n.children !== null ? n.children : [], n.key, e)),
    (e.lanes = t),
    (e.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation,
    }),
    e
  );
}
function PN(n, e, t, i, r) {
  (this.tag = e),
    (this.containerInfo = n),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = Pv(0)),
    (this.expirationTimes = Pv(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = Pv(0)),
    (this.identifierPrefix = i),
    (this.onRecoverableError = r),
    (this.mutableSourceEagerHydrationData = null);
}
function n1(n, e, t, i, r, s, o, a, l) {
  return (
    (n = new PN(n, e, t, a, l)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = Sr(3, null, null, e)),
    (n.current = s),
    (s.stateNode = n),
    (s.memoizedState = {
      element: i,
      isDehydrated: t,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    kA(s),
    n
  );
}
function BN(n, e, t) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: sc,
    key: i == null ? null : "" + i,
    children: n,
    containerInfo: e,
    implementation: t,
  };
}
function JP(n) {
  if (!n) return Xo;
  n = n._reactInternals;
  e: {
    if (fl(n) !== n || n.tag !== 1) throw Error(Ce(170));
    var e = n;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (Bi(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(Ce(171));
  }
  if (n.tag === 1) {
    var t = n.type;
    if (Bi(t)) return XR(n, t, e);
  }
  return e;
}
function KP(n, e, t, i, r, s, o, a, l) {
  return (
    (n = n1(t, i, !0, n, r, s, o, a, l)),
    (n.context = JP(null)),
    (t = n.current),
    (i = yi()),
    (r = Uo(t)),
    (s = js(i, r)),
    (s.callback = e ?? null),
    Fo(t, s, r),
    (n.current.lanes = r),
    vh(n, r, i),
    Li(n, i),
    n
  );
}
function wg(n, e, t, i) {
  var r = e.current,
    s = yi(),
    o = Uo(r);
  return (
    (t = JP(t)),
    e.context === null ? (e.context = t) : (e.pendingContext = t),
    (e = js(s, o)),
    (e.payload = { element: n }),
    (i = i === void 0 ? null : i),
    i !== null && (e.callback = i),
    (n = Fo(r, e, o)),
    n !== null && (zr(n, r, o, s), sm(n, r, o)),
    o
  );
}
function Jm(n) {
  if (((n = n.current), !n.child)) return null;
  switch (n.child.tag) {
    case 5:
      return n.child.stateNode;
    default:
      return n.child.stateNode;
  }
}
function pw(n, e) {
  if (((n = n.memoizedState), n !== null && n.dehydrated !== null)) {
    var t = n.retryLane;
    n.retryLane = t !== 0 && t < e ? t : e;
  }
}
function i1(n, e) {
  pw(n, e), (n = n.alternate) && pw(n, e);
}
function LN() {
  return null;
}
var YP =
  typeof reportError == "function"
    ? reportError
    : function (n) {
        console.error(n);
      };
function r1(n) {
  this._internalRoot = n;
}
Tg.prototype.render = r1.prototype.render = function (n) {
  var e = this._internalRoot;
  if (e === null) throw Error(Ce(409));
  wg(n, e, null, null);
};
Tg.prototype.unmount = r1.prototype.unmount = function () {
  var n = this._internalRoot;
  if (n !== null) {
    this._internalRoot = null;
    var e = n.containerInfo;
    sl(function () {
      wg(null, n, null, null);
    }),
      (e[Qs] = null);
  }
};
function Tg(n) {
  this._internalRoot = n;
}
Tg.prototype.unstable_scheduleHydration = function (n) {
  if (n) {
    var e = wR();
    n = { blockedOn: null, target: n, priority: e };
    for (var t = 0; t < To.length && e !== 0 && e < To[t].priority; t++);
    To.splice(t, 0, n), t === 0 && CR(n);
  }
};
function s1(n) {
  return !(!n || (n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11));
}
function Cg(n) {
  return !(
    !n ||
    (n.nodeType !== 1 &&
      n.nodeType !== 9 &&
      n.nodeType !== 11 &&
      (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
  );
}
function mw() {}
function IN(n, e, t, i, r) {
  if (r) {
    if (typeof i == "function") {
      var s = i;
      i = function () {
        var u = Jm(o);
        s.call(u);
      };
    }
    var o = KP(e, i, n, 0, null, !1, !1, "", mw);
    return (
      (n._reactRootContainer = o),
      (n[Qs] = o.current),
      zf(n.nodeType === 8 ? n.parentNode : n),
      sl(),
      o
    );
  }
  for (; (r = n.lastChild); ) n.removeChild(r);
  if (typeof i == "function") {
    var a = i;
    i = function () {
      var u = Jm(l);
      a.call(u);
    };
  }
  var l = n1(n, 0, !1, null, null, !1, !1, "", mw);
  return (
    (n._reactRootContainer = l),
    (n[Qs] = l.current),
    zf(n.nodeType === 8 ? n.parentNode : n),
    sl(function () {
      wg(e, l, t, i);
    }),
    l
  );
}
function bg(n, e, t, i, r) {
  var s = t._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof r == "function") {
      var a = r;
      r = function () {
        var l = Jm(o);
        a.call(l);
      };
    }
    wg(e, o, n, r);
  } else o = IN(t, e, n, r, i);
  return Jm(o);
}
MR = function (n) {
  switch (n.tag) {
    case 3:
      var e = n.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var t = cf(e.pendingLanes);
        t !== 0 &&
          (EA(e, t | 1), Li(e, _n()), !(Bt & 6) && ((Wc = _n() + 500), na()));
      }
      break;
    case 13:
      sl(function () {
        var i = qs(n, 1);
        if (i !== null) {
          var r = yi();
          zr(i, n, 1, r);
        }
      }),
        i1(n, 1);
  }
};
wA = function (n) {
  if (n.tag === 13) {
    var e = qs(n, 134217728);
    if (e !== null) {
      var t = yi();
      zr(e, n, 134217728, t);
    }
    i1(n, 134217728);
  }
};
ER = function (n) {
  if (n.tag === 13) {
    var e = Uo(n),
      t = qs(n, e);
    if (t !== null) {
      var i = yi();
      zr(t, n, e, i);
    }
    i1(n, e);
  }
};
wR = function () {
  return Ot;
};
TR = function (n, e) {
  var t = Ot;
  try {
    return (Ot = n), e();
  } finally {
    Ot = t;
  }
};
xx = function (n, e, t) {
  switch (e) {
    case "input":
      if ((hx(n, t), (e = t.name), t.type === "radio" && e != null)) {
        for (t = n; t.parentNode; ) t = t.parentNode;
        for (
          t = t.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < t.length;
          e++
        ) {
          var i = t[e];
          if (i !== n && i.form === n.form) {
            var r = yg(i);
            if (!r) throw Error(Ce(90));
            iR(i), hx(i, r);
          }
        }
      }
      break;
    case "textarea":
      sR(n, t);
      break;
    case "select":
      (e = t.value), e != null && Tc(n, !!t.multiple, e, !1);
  }
};
hR = ZA;
dR = sl;
var DN = { usingClientEntryPoint: !1, Events: [xh, uc, yg, uR, fR, ZA] },
  ku = {
    findFiberByHostInstance: Ua,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom",
  },
  FN = {
    bundleType: ku.bundleType,
    version: ku.version,
    rendererPackageName: ku.rendererPackageName,
    rendererConfig: ku.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: to.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (n) {
      return (n = gR(n)), n === null ? null : n.stateNode;
    },
    findFiberByHostInstance: ku.findFiberByHostInstance || LN,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var ip = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!ip.isDisabled && ip.supportsFiber)
    try {
      (pg = ip.inject(FN)), (ds = ip);
    } catch {}
}
nr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = DN;
nr.createPortal = function (n, e) {
  var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!s1(e)) throw Error(Ce(200));
  return BN(n, e, null, t);
};
nr.createRoot = function (n, e) {
  if (!s1(n)) throw Error(Ce(299));
  var t = !1,
    i = "",
    r = YP;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (t = !0),
      e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    (e = n1(n, 1, !1, null, null, t, !1, i, r)),
    (n[Qs] = e.current),
    zf(n.nodeType === 8 ? n.parentNode : n),
    new r1(e)
  );
};
nr.findDOMNode = function (n) {
  if (n == null) return null;
  if (n.nodeType === 1) return n;
  var e = n._reactInternals;
  if (e === void 0)
    throw typeof n.render == "function"
      ? Error(Ce(188))
      : ((n = Object.keys(n).join(",")), Error(Ce(268, n)));
  return (n = gR(e)), (n = n === null ? null : n.stateNode), n;
};
nr.flushSync = function (n) {
  return sl(n);
};
nr.hydrate = function (n, e, t) {
  if (!Cg(e)) throw Error(Ce(200));
  return bg(null, n, e, !0, t);
};
nr.hydrateRoot = function (n, e, t) {
  if (!s1(n)) throw Error(Ce(405));
  var i = (t != null && t.hydratedSources) || null,
    r = !1,
    s = "",
    o = YP;
  if (
    (t != null &&
      (t.unstable_strictMode === !0 && (r = !0),
      t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    (e = KP(e, null, n, 1, t ?? null, r, !1, s, o)),
    (n[Qs] = e.current),
    zf(n),
    i)
  )
    for (n = 0; n < i.length; n++)
      (t = i[n]),
        (r = t._getVersion),
        (r = r(t._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [t, r])
          : e.mutableSourceEagerHydrationData.push(t, r);
  return new Tg(e);
};
nr.render = function (n, e, t) {
  if (!Cg(e)) throw Error(Ce(200));
  return bg(null, n, e, !1, t);
};
nr.unmountComponentAtNode = function (n) {
  if (!Cg(n)) throw Error(Ce(40));
  return n._reactRootContainer
    ? (sl(function () {
        bg(null, null, n, !1, function () {
          (n._reactRootContainer = null), (n[Qs] = null);
        });
      }),
      !0)
    : !1;
};
nr.unstable_batchedUpdates = ZA;
nr.unstable_renderSubtreeIntoContainer = function (n, e, t, i) {
  if (!Cg(t)) throw Error(Ce(200));
  if (n == null || n._reactInternals === void 0) throw Error(Ce(38));
  return bg(n, e, t, !1, i);
};
nr.version = "18.2.0-next-9e3b772b8-20220608";
function QP() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(QP);
    } catch (n) {
      console.error(n);
    }
}
QP(), (Kb.exports = nr);
var NN = Kb.exports,
  qP,
  gw = NN;
(qP = sx.createRoot = gw.createRoot), (sx.hydrateRoot = gw.hydrateRoot);
/**
 * @remix-run/router v1.7.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Qf() {
  return (
    (Qf = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    Qf.apply(this, arguments)
  );
}
var Ha;
(function (n) {
  (n.Pop = "POP"), (n.Push = "PUSH"), (n.Replace = "REPLACE");
})(Ha || (Ha = {}));
const vw = "popstate";
function UN(n) {
  n === void 0 && (n = {});
  function e(i, r) {
    let { pathname: s, search: o, hash: a } = i.location;
    return Zx(
      "",
      { pathname: s, search: o, hash: a },
      (r.state && r.state.usr) || null,
      (r.state && r.state.key) || "default"
    );
  }
  function t(i, r) {
    return typeof r == "string" ? r : Km(r);
  }
  return kN(e, t, null, n);
}
function Gr(n, e) {
  if (n === !1 || n === null || typeof n > "u") throw new Error(e);
}
function ON() {
  return Math.random().toString(36).substr(2, 8);
}
function yw(n, e) {
  return { usr: n.state, key: n.key, idx: e };
}
function Zx(n, e, t, i) {
  return (
    t === void 0 && (t = null),
    Qf(
      { pathname: typeof n == "string" ? n : n.pathname, search: "", hash: "" },
      typeof e == "string" ? Rg(e) : e,
      { state: t, key: (e && e.key) || i || ON() }
    )
  );
}
function Km(n) {
  let { pathname: e = "/", search: t = "", hash: i = "" } = n;
  return (
    t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t),
    i && i !== "#" && (e += i.charAt(0) === "#" ? i : "#" + i),
    e
  );
}
function Rg(n) {
  let e = {};
  if (n) {
    let t = n.indexOf("#");
    t >= 0 && ((e.hash = n.substr(t)), (n = n.substr(0, t)));
    let i = n.indexOf("?");
    i >= 0 && ((e.search = n.substr(i)), (n = n.substr(0, i))),
      n && (e.pathname = n);
  }
  return e;
}
function kN(n, e, t, i) {
  i === void 0 && (i = {});
  let { window: r = document.defaultView, v5Compat: s = !1 } = i,
    o = r.history,
    a = Ha.Pop,
    l = null,
    u = h();
  u == null && ((u = 0), o.replaceState(Qf({}, o.state, { idx: u }), ""));
  function h() {
    return (o.state || { idx: null }).idx;
  }
  function d() {
    a = Ha.Pop;
    let A = h(),
      g = A == null ? null : A - u;
    (u = A), l && l({ action: a, location: M.location, delta: g });
  }
  function p(A, g) {
    a = Ha.Push;
    let x = Zx(M.location, A, g);
    t && t(x, A), (u = h() + 1);
    let _ = yw(x, u),
      E = M.createHref(x);
    try {
      o.pushState(_, "", E);
    } catch (T) {
      if (T instanceof DOMException && T.name === "DataCloneError") throw T;
      r.location.assign(E);
    }
    s && l && l({ action: a, location: M.location, delta: 1 });
  }
  function m(A, g) {
    a = Ha.Replace;
    let x = Zx(M.location, A, g);
    t && t(x, A), (u = h());
    let _ = yw(x, u),
      E = M.createHref(x);
    o.replaceState(_, "", E),
      s && l && l({ action: a, location: M.location, delta: 0 });
  }
  function y(A) {
    let g = r.location.origin !== "null" ? r.location.origin : r.location.href,
      x = typeof A == "string" ? A : Km(A);
    return (
      Gr(
        g,
        "No window.location.(origin|href) available to create URL for href: " +
          x
      ),
      new URL(x, g)
    );
  }
  let M = {
    get action() {
      return a;
    },
    get location() {
      return n(r, o);
    },
    listen(A) {
      if (l) throw new Error("A history only accepts one active listener");
      return (
        r.addEventListener(vw, d),
        (l = A),
        () => {
          r.removeEventListener(vw, d), (l = null);
        }
      );
    },
    createHref(A) {
      return e(r, A);
    },
    createURL: y,
    encodeLocation(A) {
      let g = y(A);
      return { pathname: g.pathname, search: g.search, hash: g.hash };
    },
    push: p,
    replace: m,
    go(A) {
      return o.go(A);
    },
  };
  return M;
}
var xw;
(function (n) {
  (n.data = "data"),
    (n.deferred = "deferred"),
    (n.redirect = "redirect"),
    (n.error = "error");
})(xw || (xw = {}));
function ZP(n, e) {
  if (e === "/") return n;
  if (!n.toLowerCase().startsWith(e.toLowerCase())) return null;
  let t = e.endsWith("/") ? e.length - 1 : e.length,
    i = n.charAt(t);
  return i && i !== "/" ? null : n.slice(t) || "/";
}
function HN(n, e) {
  e === void 0 && (e = "/");
  let {
    pathname: t,
    search: i = "",
    hash: r = "",
  } = typeof n == "string" ? Rg(n) : n;
  return {
    pathname: t ? (t.startsWith("/") ? t : zN(t, e)) : e,
    search: GN(i),
    hash: VN(r),
  };
}
function zN(n, e) {
  let t = e.replace(/\/+$/, "").split("/");
  return (
    n.split("/").forEach((r) => {
      r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r);
    }),
    t.length > 1 ? t.join("/") : "/"
  );
}
function qv(n, e, t, i) {
  return (
    "Cannot include a '" +
    n +
    "' character in a manually specified " +
    ("`to." +
      e +
      "` field [" +
      JSON.stringify(i) +
      "].  Please separate it out to the ") +
    ("`to." + t + "` field. Alternatively you may provide the full path as ") +
    'a string in <Link to="..."> and the router will parse it for you.'
  );
}
function $P(n) {
  return n.filter(
    (e, t) => t === 0 || (e.route.path && e.route.path.length > 0)
  );
}
function e2(n, e, t, i) {
  i === void 0 && (i = !1);
  let r;
  typeof n == "string"
    ? (r = Rg(n))
    : ((r = Qf({}, n)),
      Gr(
        !r.pathname || !r.pathname.includes("?"),
        qv("?", "pathname", "search", r)
      ),
      Gr(
        !r.pathname || !r.pathname.includes("#"),
        qv("#", "pathname", "hash", r)
      ),
      Gr(!r.search || !r.search.includes("#"), qv("#", "search", "hash", r)));
  let s = n === "" || r.pathname === "",
    o = s ? "/" : r.pathname,
    a;
  if (i || o == null) a = t;
  else {
    let d = e.length - 1;
    if (o.startsWith("..")) {
      let p = o.split("/");
      for (; p[0] === ".."; ) p.shift(), (d -= 1);
      r.pathname = p.join("/");
    }
    a = d >= 0 ? e[d] : "/";
  }
  let l = HN(r, a),
    u = o && o !== "/" && o.endsWith("/"),
    h = (s || o === ".") && t.endsWith("/");
  return !l.pathname.endsWith("/") && (u || h) && (l.pathname += "/"), l;
}
const t2 = (n) => n.join("/").replace(/\/\/+/g, "/"),
  GN = (n) => (!n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n),
  VN = (n) => (!n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n),
  n2 = ["post", "put", "patch", "delete"];
new Set(n2);
const WN = ["get", ...n2];
new Set(WN);
/**
 * React Router v6.14.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function $x() {
  return (
    ($x = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    $x.apply(this, arguments)
  );
}
const i2 = W.createContext(null),
  Ah = W.createContext(null),
  o1 = W.createContext(null),
  Pg = W.createContext({ outlet: null, matches: [], isDataRoute: !1 });
function jN(n, e) {
  let { relative: t } = e === void 0 ? {} : e;
  Bg() || Gr(!1);
  let { basename: i, navigator: r } = W.useContext(Ah),
    { hash: s, pathname: o, search: a } = s2(n, { relative: t }),
    l = o;
  return (
    i !== "/" && (l = o === "/" ? i : t2([i, o])),
    r.createHref({ pathname: l, search: a, hash: s })
  );
}
function Bg() {
  return W.useContext(o1) != null;
}
function a1() {
  return Bg() || Gr(!1), W.useContext(o1).location;
}
function r2(n) {
  W.useContext(Ah).static || W.useLayoutEffect(n);
}
function XN() {
  let { isDataRoute: n } = W.useContext(Pg);
  return n ? qN() : JN();
}
function JN() {
  Bg() || Gr(!1);
  let n = W.useContext(i2),
    { basename: e, navigator: t } = W.useContext(Ah),
    { matches: i } = W.useContext(Pg),
    { pathname: r } = a1(),
    s = JSON.stringify($P(i).map((l) => l.pathnameBase)),
    o = W.useRef(!1);
  return (
    r2(() => {
      o.current = !0;
    }),
    W.useCallback(
      function (l, u) {
        if ((u === void 0 && (u = {}), !o.current)) return;
        if (typeof l == "number") {
          t.go(l);
          return;
        }
        let h = e2(l, JSON.parse(s), r, u.relative === "path");
        n == null &&
          e !== "/" &&
          (h.pathname = h.pathname === "/" ? e : t2([e, h.pathname])),
          (u.replace ? t.replace : t.push)(h, u.state, u);
      },
      [e, t, s, r, n]
    )
  );
}
function s2(n, e) {
  let { relative: t } = e === void 0 ? {} : e,
    { matches: i } = W.useContext(Pg),
    { pathname: r } = a1(),
    s = JSON.stringify($P(i).map((o) => o.pathnameBase));
  return W.useMemo(() => e2(n, JSON.parse(s), r, t === "path"), [n, s, r, t]);
}
var e_;
(function (n) {
  (n.UseBlocker = "useBlocker"),
    (n.UseRevalidator = "useRevalidator"),
    (n.UseNavigateStable = "useNavigate");
})(e_ || (e_ = {}));
var t_;
(function (n) {
  (n.UseBlocker = "useBlocker"),
    (n.UseLoaderData = "useLoaderData"),
    (n.UseActionData = "useActionData"),
    (n.UseRouteError = "useRouteError"),
    (n.UseNavigation = "useNavigation"),
    (n.UseRouteLoaderData = "useRouteLoaderData"),
    (n.UseMatches = "useMatches"),
    (n.UseRevalidator = "useRevalidator"),
    (n.UseNavigateStable = "useNavigate"),
    (n.UseRouteId = "useRouteId");
})(t_ || (t_ = {}));
function KN(n) {
  let e = W.useContext(i2);
  return e || Gr(!1), e;
}
function YN(n) {
  let e = W.useContext(Pg);
  return e || Gr(!1), e;
}
function QN(n) {
  let e = YN(),
    t = e.matches[e.matches.length - 1];
  return t.route.id || Gr(!1), t.route.id;
}
function qN() {
  let { router: n } = KN(e_.UseNavigateStable),
    e = QN(t_.UseNavigateStable),
    t = W.useRef(!1);
  return (
    r2(() => {
      t.current = !0;
    }),
    W.useCallback(
      function (r, s) {
        s === void 0 && (s = {}),
          t.current &&
            (typeof r == "number"
              ? n.navigate(r)
              : n.navigate(r, $x({ fromRouteId: e }, s)));
      },
      [n, e]
    )
  );
}
function ZN(n) {
  let {
    basename: e = "/",
    children: t = null,
    location: i,
    navigationType: r = Ha.Pop,
    navigator: s,
    static: o = !1,
  } = n;
  Bg() && Gr(!1);
  let a = e.replace(/^\/*/, "/"),
    l = W.useMemo(() => ({ basename: a, navigator: s, static: o }), [a, s, o]);
  typeof i == "string" && (i = Rg(i));
  let {
      pathname: u = "/",
      search: h = "",
      hash: d = "",
      state: p = null,
      key: m = "default",
    } = i,
    y = W.useMemo(() => {
      let M = ZP(u, a);
      return M == null
        ? null
        : {
            location: { pathname: M, search: h, hash: d, state: p, key: m },
            navigationType: r,
          };
    }, [a, u, h, d, p, m, r]);
  return y == null
    ? null
    : W.createElement(
        Ah.Provider,
        { value: l },
        W.createElement(o1.Provider, { children: t, value: y })
      );
}
var _w;
(function (n) {
  (n[(n.pending = 0)] = "pending"),
    (n[(n.success = 1)] = "success"),
    (n[(n.error = 2)] = "error");
})(_w || (_w = {}));
new Promise(() => {});
/**
 * React Router DOM v6.14.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function n_() {
  return (
    (n_ = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    n_.apply(this, arguments)
  );
}
function $N(n, e) {
  if (n == null) return {};
  var t = {},
    i = Object.keys(n),
    r,
    s;
  for (s = 0; s < i.length; s++)
    (r = i[s]), !(e.indexOf(r) >= 0) && (t[r] = n[r]);
  return t;
}
function eU(n) {
  return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey);
}
function tU(n, e) {
  return n.button === 0 && (!e || e === "_self") && !eU(n);
}
const nU = [
    "onClick",
    "relative",
    "reloadDocument",
    "replace",
    "state",
    "target",
    "to",
    "preventScrollReset",
  ],
  iU = "startTransition",
  Aw = T3[iU];
function rU(n) {
  let { basename: e, children: t, future: i, window: r } = n,
    s = W.useRef();
  s.current == null && (s.current = UN({ window: r, v5Compat: !0 }));
  let o = s.current,
    [a, l] = W.useState({ action: o.action, location: o.location }),
    { v7_startTransition: u } = i || {},
    h = W.useCallback(
      (d) => {
        u && Aw ? Aw(() => l(d)) : l(d);
      },
      [l, u]
    );
  return (
    W.useLayoutEffect(() => o.listen(h), [o, h]),
    W.createElement(ZN, {
      basename: e,
      children: t,
      location: a.location,
      navigationType: a.action,
      navigator: o,
    })
  );
}
const sU =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  oU = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  aU = W.forwardRef(function (e, t) {
    let {
        onClick: i,
        relative: r,
        reloadDocument: s,
        replace: o,
        state: a,
        target: l,
        to: u,
        preventScrollReset: h,
      } = e,
      d = $N(e, nU),
      { basename: p } = W.useContext(Ah),
      m,
      y = !1;
    if (typeof u == "string" && oU.test(u) && ((m = u), sU))
      try {
        let x = new URL(window.location.href),
          _ = u.startsWith("//") ? new URL(x.protocol + u) : new URL(u),
          E = ZP(_.pathname, p);
        _.origin === x.origin && E != null
          ? (u = E + _.search + _.hash)
          : (y = !0);
      } catch {}
    let M = jN(u, { relative: r }),
      A = lU(u, {
        replace: o,
        state: a,
        target: l,
        preventScrollReset: h,
        relative: r,
      });
    function g(x) {
      i && i(x), x.defaultPrevented || A(x);
    }
    return W.createElement(
      "a",
      n_({}, d, { href: m || M, onClick: y || s ? i : g, ref: t, target: l })
    );
  });
var Sw;
(function (n) {
  (n.UseScrollRestoration = "useScrollRestoration"),
    (n.UseSubmit = "useSubmit"),
    (n.UseSubmitFetcher = "useSubmitFetcher"),
    (n.UseFetcher = "useFetcher");
})(Sw || (Sw = {}));
var Mw;
(function (n) {
  (n.UseFetchers = "useFetchers"),
    (n.UseScrollRestoration = "useScrollRestoration");
})(Mw || (Mw = {}));
function lU(n, e) {
  let {
      target: t,
      replace: i,
      state: r,
      preventScrollReset: s,
      relative: o,
    } = e === void 0 ? {} : e,
    a = XN(),
    l = a1(),
    u = s2(n, { relative: o });
  return W.useCallback(
    (h) => {
      if (tU(h, t)) {
        h.preventDefault();
        let d = i !== void 0 ? i : Km(l) === Km(u);
        a(n, { replace: d, state: r, preventScrollReset: s, relative: o });
      }
    },
    [l, a, u, i, r, t, n, s, o]
  );
}
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Sh = "154",
  Pa = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  Ba = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  o2 = 0,
  i_ = 1,
  a2 = 2,
  cU = 3,
  l2 = 0,
  Lg = 1,
  Mf = 2,
  Nr = 3,
  xs = 0,
  xi = 1,
  Ar = 2,
  uU = 2,
  Xs = 0,
  Ya = 1,
  r_ = 2,
  s_ = 3,
  o_ = 4,
  c2 = 5,
  Fa = 100,
  u2 = 101,
  f2 = 102,
  a_ = 103,
  l_ = 104,
  h2 = 200,
  d2 = 201,
  p2 = 202,
  m2 = 203,
  l1 = 204,
  c1 = 205,
  g2 = 206,
  v2 = 207,
  y2 = 208,
  x2 = 209,
  _2 = 210,
  A2 = 0,
  S2 = 1,
  M2 = 2,
  Ym = 3,
  E2 = 4,
  w2 = 5,
  T2 = 6,
  C2 = 7,
  Mh = 0,
  b2 = 1,
  R2 = 2,
  Vr = 0,
  P2 = 1,
  B2 = 2,
  L2 = 3,
  u1 = 4,
  I2 = 5,
  Ig = 300,
  Jo = 301,
  Ko = 302,
  qf = 303,
  Zf = 304,
  ou = 306,
  Yo = 1e3,
  Kn = 1001,
  jc = 1002,
  gn = 1003,
  $f = 1004,
  fU = 1004,
  Lc = 1005,
  hU = 1005,
  sn = 1006,
  Dg = 1007,
  dU = 1007,
  _s = 1008,
  pU = 1008,
  ms = 1009,
  D2 = 1010,
  F2 = 1011,
  Fg = 1012,
  f1 = 1013,
  Gs = 1014,
  fs = 1015,
  Xc = 1016,
  h1 = 1017,
  d1 = 1018,
  ko = 1020,
  N2 = 1021,
  bi = 1023,
  U2 = 1024,
  O2 = 1025,
  Ho = 1026,
  ol = 1027,
  k2 = 1028,
  p1 = 1029,
  H2 = 1030,
  m1 = 1031,
  g1 = 1033,
  hm = 33776,
  dm = 33777,
  pm = 33778,
  mm = 33779,
  c_ = 35840,
  u_ = 35841,
  f_ = 35842,
  h_ = 35843,
  z2 = 36196,
  d_ = 37492,
  p_ = 37496,
  m_ = 37808,
  g_ = 37809,
  v_ = 37810,
  y_ = 37811,
  x_ = 37812,
  __ = 37813,
  A_ = 37814,
  S_ = 37815,
  M_ = 37816,
  E_ = 37817,
  w_ = 37818,
  T_ = 37819,
  C_ = 37820,
  b_ = 37821,
  gm = 36492,
  G2 = 36283,
  R_ = 36284,
  P_ = 36285,
  B_ = 36286,
  V2 = 2200,
  W2 = 2201,
  j2 = 2202,
  Jc = 2300,
  al = 2301,
  vm = 2302,
  za = 2400,
  Ga = 2401,
  eh = 2402,
  Ng = 2500,
  v1 = 2501,
  X2 = 0,
  y1 = 1,
  Qm = 2,
  x1 = 3e3,
  zo = 3001,
  J2 = 3200,
  K2 = 3201,
  ia = 0,
  Y2 = 1,
  Go = "",
  mt = "srgb",
  Xr = "srgb-linear",
  _1 = "display-p3",
  mU = 0,
  ym = 7680,
  gU = 7681,
  vU = 7682,
  yU = 7683,
  xU = 34055,
  _U = 34056,
  AU = 5386,
  SU = 512,
  MU = 513,
  EU = 514,
  wU = 515,
  TU = 516,
  CU = 517,
  bU = 518,
  Q2 = 519,
  q2 = 512,
  Z2 = 513,
  $2 = 514,
  eB = 515,
  tB = 516,
  nB = 517,
  iB = 518,
  rB = 519,
  th = 35044,
  Qa = 35048,
  RU = 35040,
  PU = 35045,
  BU = 35049,
  LU = 35041,
  IU = 35046,
  DU = 35050,
  FU = 35042,
  NU = "100",
  L_ = "300 es",
  qm = 1035,
  hs = 2e3,
  nh = 2001;
class Ss {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
const si = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let Ew = 1234567;
const qa = Math.PI / 180,
  Kc = 180 / Math.PI;
function qi() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0;
  return (
    si[n & 255] +
    si[(n >> 8) & 255] +
    si[(n >> 16) & 255] +
    si[(n >> 24) & 255] +
    "-" +
    si[e & 255] +
    si[(e >> 8) & 255] +
    "-" +
    si[((e >> 16) & 15) | 64] +
    si[(e >> 24) & 255] +
    "-" +
    si[(t & 63) | 128] +
    si[(t >> 8) & 255] +
    "-" +
    si[(t >> 16) & 255] +
    si[(t >> 24) & 255] +
    si[i & 255] +
    si[(i >> 8) & 255] +
    si[(i >> 16) & 255] +
    si[(i >> 24) & 255]
  ).toLowerCase();
}
function vn(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function A1(n, e) {
  return ((n % e) + e) % e;
}
function UU(n, e, t, i, r) {
  return i + ((n - e) * (r - i)) / (t - e);
}
function OU(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function Ef(n, e, t) {
  return (1 - t) * n + t * e;
}
function kU(n, e, t, i) {
  return Ef(n, e, 1 - Math.exp(-t * i));
}
function HU(n, e = 1) {
  return e - Math.abs(A1(n, e * 2) - e);
}
function zU(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function GU(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function VU(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function WU(n, e) {
  return n + Math.random() * (e - n);
}
function jU(n) {
  return n * (0.5 - Math.random());
}
function XU(n) {
  n !== void 0 && (Ew = n);
  let e = (Ew += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function JU(n) {
  return n * qa;
}
function KU(n) {
  return n * Kc;
}
function I_(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function sB(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function Zm(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function YU(n, e, t, i, r) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    l = o(t / 2),
    u = s((e + i) / 2),
    h = o((e + i) / 2),
    d = s((e - i) / 2),
    p = o((e - i) / 2),
    m = s((i - e) / 2),
    y = o((i - e) / 2);
  switch (r) {
    case "XYX":
      n.set(a * h, l * d, l * p, a * u);
      break;
    case "YZY":
      n.set(l * p, a * h, l * d, a * u);
      break;
    case "ZXZ":
      n.set(l * d, l * p, a * h, a * u);
      break;
    case "XZX":
      n.set(a * h, l * y, l * m, a * u);
      break;
    case "YXY":
      n.set(l * m, a * h, l * y, a * u);
      break;
    case "ZYZ":
      n.set(l * y, l * m, a * h, a * u);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          r
      );
  }
}
function Xi(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function At(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const oB = {
  DEG2RAD: qa,
  RAD2DEG: Kc,
  generateUUID: qi,
  clamp: vn,
  euclideanModulo: A1,
  mapLinear: UU,
  inverseLerp: OU,
  lerp: Ef,
  damp: kU,
  pingpong: HU,
  smoothstep: zU,
  smootherstep: GU,
  randInt: VU,
  randFloat: WU,
  randFloatSpread: jU,
  seededRandom: XU,
  degToRad: JU,
  radToDeg: KU,
  isPowerOfTwo: I_,
  ceilPowerOfTwo: sB,
  floorPowerOfTwo: Zm,
  setQuaternionFromProperEuler: YU,
  normalize: At,
  denormalize: Xi,
};
class ve {
  constructor(e = 0, t = 0) {
    (ve.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * i + r[6]),
      (this.y = r[1] * t + r[4] * i + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(vn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y;
    return (this.x = s * i - o * r + e.x), (this.y = s * r + o * i + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class _t {
  constructor(e, t, i, r, s, o, a, l, u) {
    (_t.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, l, u);
  }
  set(e, t, i, r, s, o, a, l, u) {
    const h = this.elements;
    return (
      (h[0] = e),
      (h[1] = r),
      (h[2] = a),
      (h[3] = t),
      (h[4] = s),
      (h[5] = l),
      (h[6] = i),
      (h[7] = o),
      (h[8] = u),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[3],
      l = i[6],
      u = i[1],
      h = i[4],
      d = i[7],
      p = i[2],
      m = i[5],
      y = i[8],
      M = r[0],
      A = r[3],
      g = r[6],
      x = r[1],
      _ = r[4],
      E = r[7],
      T = r[2],
      R = r[5],
      P = r[8];
    return (
      (s[0] = o * M + a * x + l * T),
      (s[3] = o * A + a * _ + l * R),
      (s[6] = o * g + a * E + l * P),
      (s[1] = u * M + h * x + d * T),
      (s[4] = u * A + h * _ + d * R),
      (s[7] = u * g + h * E + d * P),
      (s[2] = p * M + m * x + y * T),
      (s[5] = p * A + m * _ + y * R),
      (s[8] = p * g + m * E + y * P),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      u = e[7],
      h = e[8];
    return (
      t * o * h - t * a * u - i * s * h + i * a * l + r * s * u - r * o * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      u = e[7],
      h = e[8],
      d = h * o - a * u,
      p = a * l - h * s,
      m = u * s - o * l,
      y = t * d + i * p + r * m;
    if (y === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const M = 1 / y;
    return (
      (e[0] = d * M),
      (e[1] = (r * u - h * i) * M),
      (e[2] = (a * i - r * o) * M),
      (e[3] = p * M),
      (e[4] = (h * t - r * l) * M),
      (e[5] = (r * s - a * t) * M),
      (e[6] = m * M),
      (e[7] = (i * l - u * t) * M),
      (e[8] = (o * t - i * s) * M),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const l = Math.cos(s),
      u = Math.sin(s);
    return (
      this.set(
        i * l,
        i * u,
        -i * (l * o + u * a) + o + e,
        -r * u,
        r * l,
        -r * (-u * o + l * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(Zv.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Zv.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Zv.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Zv = new _t();
function aB(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
const QU = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function vc(n, e) {
  return new QU[n](e);
}
function ih(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
const ww = {};
function wf(n) {
  n in ww || ((ww[n] = !0), console.warn(n));
}
function Ic(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function $v(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
const qU = new _t().fromArray([
    0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7,
    1e-7, 0.9105199,
  ]),
  ZU = new _t().fromArray([
    1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7,
    0, 1.0982735,
  ]);
function $U(n) {
  return n.convertSRGBToLinear().applyMatrix3(ZU);
}
function eO(n) {
  return n.applyMatrix3(qU).convertLinearToSRGB();
}
const tO = { [Xr]: (n) => n, [mt]: (n) => n.convertSRGBToLinear(), [_1]: $U },
  nO = { [Xr]: (n) => n, [mt]: (n) => n.convertLinearToSRGB(), [_1]: eO },
  mr = {
    enabled: !0,
    get legacyMode() {
      return (
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
        ),
        !this.enabled
      );
    },
    set legacyMode(n) {
      console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
        (this.enabled = !n);
    },
    get workingColorSpace() {
      return Xr;
    },
    set workingColorSpace(n) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function (n, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return n;
      const i = tO[e],
        r = nO[t];
      if (i === void 0 || r === void 0)
        throw new Error(
          `Unsupported color space conversion, "${e}" to "${t}".`
        );
      return r(i(n));
    },
    fromWorkingColorSpace: function (n, e) {
      return this.convert(n, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function (n, e) {
      return this.convert(n, e, this.workingColorSpace);
    },
  };
let Il;
class S1 {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      Il === void 0 && (Il = ih("canvas")),
        (Il.width = e.width),
        (Il.height = e.height);
      const i = Il.getContext("2d");
      e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (t = Il);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = ih("canvas");
      (t.width = e.width), (t.height = e.height);
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height),
        s = r.data;
      for (let o = 0; o < s.length; o++) s[o] = Ic(s[o] / 255) * 255;
      return i.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[i] = Math.floor(Ic(t[i] / 255) * 255))
          : (t[i] = Ic(t[i]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let iO = 0;
class Va {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: iO++ }),
      (this.uuid = qi()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" },
      r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, a = r.length; o < a; o++)
          r[o].isDataTexture ? s.push(ey(r[o].image)) : s.push(ey(r[o]));
      } else s = ey(r);
      i.url = s;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function ey(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? S1.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let rO = 0;
class en extends Ss {
  constructor(
    e = en.DEFAULT_IMAGE,
    t = en.DEFAULT_MAPPING,
    i = Kn,
    r = Kn,
    s = sn,
    o = _s,
    a = bi,
    l = ms,
    u = en.DEFAULT_ANISOTROPY,
    h = Go
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: rO++ }),
      (this.uuid = qi()),
      (this.name = ""),
      (this.source = new Va(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = i),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = u),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new ve(0, 0)),
      (this.repeat = new ve(1, 1)),
      (this.center = new ve(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new _t()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof h == "string"
        ? (this.colorSpace = h)
        : (wf(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
          (this.colorSpace = h === zo ? mt : Go)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      t || (e.textures[this.uuid] = i),
      i
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Ig) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Yo:
          e.x = e.x - Math.floor(e.x);
          break;
        case Kn:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case jc:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Yo:
          e.y = e.y - Math.floor(e.y);
          break;
        case Kn:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case jc:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  get encoding() {
    return (
      wf("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      this.colorSpace === mt ? zo : x1
    );
  }
  set encoding(e) {
    wf("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      (this.colorSpace = e === zo ? mt : Go);
  }
}
en.DEFAULT_IMAGE = null;
en.DEFAULT_MAPPING = Ig;
en.DEFAULT_ANISOTROPY = 1;
class Ut {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (Ut.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      (this.w = r);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s),
      (this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s),
      (this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s),
      (this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s;
    const l = e.elements,
      u = l[0],
      h = l[4],
      d = l[8],
      p = l[1],
      m = l[5],
      y = l[9],
      M = l[2],
      A = l[6],
      g = l[10];
    if (
      Math.abs(h - p) < 0.01 &&
      Math.abs(d - M) < 0.01 &&
      Math.abs(y - A) < 0.01
    ) {
      if (
        Math.abs(h + p) < 0.1 &&
        Math.abs(d + M) < 0.1 &&
        Math.abs(y + A) < 0.1 &&
        Math.abs(u + m + g - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const _ = (u + 1) / 2,
        E = (m + 1) / 2,
        T = (g + 1) / 2,
        R = (h + p) / 4,
        P = (d + M) / 4,
        B = (y + A) / 4;
      return (
        _ > E && _ > T
          ? _ < 0.01
            ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(_)), (r = R / i), (s = P / i))
          : E > T
          ? E < 0.01
            ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
            : ((r = Math.sqrt(E)), (i = R / r), (s = B / r))
          : T < 0.01
          ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
          : ((s = Math.sqrt(T)), (i = P / s), (r = B / s)),
        this.set(i, r, s, t),
        this
      );
    }
    let x = Math.sqrt(
      (A - y) * (A - y) + (d - M) * (d - M) + (p - h) * (p - h)
    );
    return (
      Math.abs(x) < 0.001 && (x = 1),
      (this.x = (A - y) / x),
      (this.y = (d - M) / x),
      (this.z = (p - h) / x),
      (this.w = Math.acos((u + m + g - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Jr extends Ss {
  constructor(e = 1, t = 1, i = {}) {
    super(),
      (this.isWebGLRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new Ut(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Ut(0, 0, e, t));
    const r = { width: e, height: t, depth: 1 };
    i.encoding !== void 0 &&
      (wf(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (i.colorSpace = i.encoding === zo ? mt : Go)),
      (this.texture = new en(
        r,
        i.mapping,
        i.wrapS,
        i.wrapT,
        i.magFilter,
        i.minFilter,
        i.format,
        i.type,
        i.anisotropy,
        i.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps =
        i.generateMipmaps !== void 0 ? i.generateMipmaps : !1),
      (this.texture.internalFormat =
        i.internalFormat !== void 0 ? i.internalFormat : null),
      (this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : sn),
      (this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0),
      (this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1),
      (this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null),
      (this.samples = i.samples !== void 0 ? i.samples : 0);
  }
  setSize(e, t, i = 1) {
    (this.width !== e || this.height !== t || this.depth !== i) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = i),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = i),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new Va(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Ug extends en {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = gn),
      (this.minFilter = gn),
      (this.wrapR = Kn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class sO extends Jr {
  constructor(e = 1, t = 1, i = 1) {
    super(e, t),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = i),
      (this.texture = new Ug(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class M1 extends en {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = gn),
      (this.minFilter = gn),
      (this.wrapR = Kn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class oO extends Jr {
  constructor(e = 1, t = 1, i = 1) {
    super(e, t),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = i),
      (this.texture = new M1(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class aO extends Jr {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r), (this.isWebGLMultipleRenderTargets = !0);
    const s = this.texture;
    this.texture = [];
    for (let o = 0; o < i; o++)
      (this.texture[o] = s.clone()),
        (this.texture[o].isRenderTargetTexture = !0);
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      (this.width = e), (this.height = t), (this.depth = i);
      for (let r = 0, s = this.texture.length; r < s; r++)
        (this.texture[r].image.width = e),
          (this.texture[r].image.height = t),
          (this.texture[r].image.depth = i);
      this.dispose();
    }
    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
  }
  copy(e) {
    this.dispose(),
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.texture.length = 0);
    for (let t = 0, i = e.texture.length; t < i; t++)
      (this.texture[t] = e.texture[t].clone()),
        (this.texture[t].isRenderTargetTexture = !0);
    return this;
  }
}
class Wn {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r);
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let l = i[r + 0],
      u = i[r + 1],
      h = i[r + 2],
      d = i[r + 3];
    const p = s[o + 0],
      m = s[o + 1],
      y = s[o + 2],
      M = s[o + 3];
    if (a === 0) {
      (e[t + 0] = l), (e[t + 1] = u), (e[t + 2] = h), (e[t + 3] = d);
      return;
    }
    if (a === 1) {
      (e[t + 0] = p), (e[t + 1] = m), (e[t + 2] = y), (e[t + 3] = M);
      return;
    }
    if (d !== M || l !== p || u !== m || h !== y) {
      let A = 1 - a;
      const g = l * p + u * m + h * y + d * M,
        x = g >= 0 ? 1 : -1,
        _ = 1 - g * g;
      if (_ > Number.EPSILON) {
        const T = Math.sqrt(_),
          R = Math.atan2(T, g * x);
        (A = Math.sin(A * R) / T), (a = Math.sin(a * R) / T);
      }
      const E = a * x;
      if (
        ((l = l * A + p * E),
        (u = u * A + m * E),
        (h = h * A + y * E),
        (d = d * A + M * E),
        A === 1 - a)
      ) {
        const T = 1 / Math.sqrt(l * l + u * u + h * h + d * d);
        (l *= T), (u *= T), (h *= T), (d *= T);
      }
    }
    (e[t] = l), (e[t + 1] = u), (e[t + 2] = h), (e[t + 3] = d);
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r],
      l = i[r + 1],
      u = i[r + 2],
      h = i[r + 3],
      d = s[o],
      p = s[o + 1],
      m = s[o + 2],
      y = s[o + 3];
    return (
      (e[t] = a * y + h * d + l * m - u * p),
      (e[t + 1] = l * y + h * p + u * d - a * m),
      (e[t + 2] = u * y + h * m + a * p - l * d),
      (e[t + 3] = h * y - a * d - l * p - u * m),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, i, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      l = Math.sin,
      u = a(i / 2),
      h = a(r / 2),
      d = a(s / 2),
      p = l(i / 2),
      m = l(r / 2),
      y = l(s / 2);
    switch (o) {
      case "XYZ":
        (this._x = p * h * d + u * m * y),
          (this._y = u * m * d - p * h * y),
          (this._z = u * h * y + p * m * d),
          (this._w = u * h * d - p * m * y);
        break;
      case "YXZ":
        (this._x = p * h * d + u * m * y),
          (this._y = u * m * d - p * h * y),
          (this._z = u * h * y - p * m * d),
          (this._w = u * h * d + p * m * y);
        break;
      case "ZXY":
        (this._x = p * h * d - u * m * y),
          (this._y = u * m * d + p * h * y),
          (this._z = u * h * y + p * m * d),
          (this._w = u * h * d - p * m * y);
        break;
      case "ZYX":
        (this._x = p * h * d - u * m * y),
          (this._y = u * m * d + p * h * y),
          (this._z = u * h * y - p * m * d),
          (this._w = u * h * d + p * m * y);
        break;
      case "YZX":
        (this._x = p * h * d + u * m * y),
          (this._y = u * m * d + p * h * y),
          (this._z = u * h * y - p * m * d),
          (this._w = u * h * d - p * m * y);
        break;
      case "XZY":
        (this._x = p * h * d - u * m * y),
          (this._y = u * m * d - p * h * y),
          (this._z = u * h * y + p * m * d),
          (this._w = u * h * d + p * m * y);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      r = Math.sin(i);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      r = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      l = t[9],
      u = t[2],
      h = t[6],
      d = t[10],
      p = i + a + d;
    if (p > 0) {
      const m = 0.5 / Math.sqrt(p + 1);
      (this._w = 0.25 / m),
        (this._x = (h - l) * m),
        (this._y = (s - u) * m),
        (this._z = (o - r) * m);
    } else if (i > a && i > d) {
      const m = 2 * Math.sqrt(1 + i - a - d);
      (this._w = (h - l) / m),
        (this._x = 0.25 * m),
        (this._y = (r + o) / m),
        (this._z = (s + u) / m);
    } else if (a > d) {
      const m = 2 * Math.sqrt(1 + a - i - d);
      (this._w = (s - u) / m),
        (this._x = (r + o) / m),
        (this._y = 0.25 * m),
        (this._z = (l + h) / m);
    } else {
      const m = 2 * Math.sqrt(1 + d - i - a);
      (this._w = (o - r) / m),
        (this._x = (s + u) / m),
        (this._y = (l + h) / m),
        (this._z = 0.25 * m);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(vn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, t / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      l = t._y,
      u = t._z,
      h = t._w;
    return (
      (this._x = i * h + o * a + r * u - s * l),
      (this._y = r * h + o * l + s * a - i * u),
      (this._z = s * h + o * u + i * l - r * a),
      (this._w = o * h - i * a - r * l - s * u),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x,
      r = this._y,
      s = this._z,
      o = this._w;
    let a = o * e._w + i * e._x + r * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = i), (this._y = r), (this._z = s), this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const m = 1 - t;
      return (
        (this._w = m * o + t * this._w),
        (this._x = m * i + t * this._x),
        (this._y = m * r + t * this._y),
        (this._z = m * s + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const u = Math.sqrt(l),
      h = Math.atan2(u, a),
      d = Math.sin((1 - t) * h) / u,
      p = Math.sin(t * h) / u;
    return (
      (this._w = o * d + this._w * p),
      (this._x = i * d + this._x * p),
      (this._y = r * d + this._y * p),
      (this._z = s * d + this._z * p),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      i = Math.sqrt(e),
      r = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(r),
      i * Math.sin(s),
      i * Math.cos(s),
      t * Math.sin(r)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class F {
  constructor(e = 0, t = 0, i = 0) {
    (F.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
  }
  set(e, t, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(Tw.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Tw.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * i + s[6] * r),
      (this.y = s[1] * t + s[4] * i + s[7] * r),
      (this.z = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o),
      (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o),
      (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      l = e.w,
      u = l * t + o * r - a * i,
      h = l * i + a * t - s * r,
      d = l * r + s * i - o * t,
      p = -s * t - o * i - a * r;
    return (
      (this.x = u * l + p * -s + h * -a - d * -o),
      (this.y = h * l + p * -o + d * -s - u * -a),
      (this.z = d * l + p * -a + u * -o - h * -s),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * r),
      (this.y = s[1] * t + s[5] * i + s[9] * r),
      (this.z = s[2] * t + s[6] * i + s[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      l = t.z;
    return (
      (this.x = r * l - s * a),
      (this.y = s * o - i * l),
      (this.z = i * a - r * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return ty.copy(this).projectOnVector(e), this.sub(ty);
  }
  reflect(e) {
    return this.sub(ty.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(vn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = i), (this.z = r), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      i = Math.sqrt(1 - e ** 2);
    return (
      (this.x = i * Math.cos(t)), (this.y = i * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const ty = new F(),
  Tw = new Wn();
class Yr {
  constructor(
    e = new F(1 / 0, 1 / 0, 1 / 0),
    t = new F(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(Bs.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(Bs.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = Bs.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    if ((e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0))
      e.boundingBox === null && e.computeBoundingBox(),
        Dl.copy(e.boundingBox),
        Dl.applyMatrix4(e.matrixWorld),
        this.union(Dl);
    else {
      const r = e.geometry;
      if (r !== void 0)
        if (t && r.attributes !== void 0 && r.attributes.position !== void 0) {
          const s = r.attributes.position;
          for (let o = 0, a = s.count; o < a; o++)
            Bs.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
              this.expandByPoint(Bs);
        } else
          r.boundingBox === null && r.computeBoundingBox(),
            Dl.copy(r.boundingBox),
            Dl.applyMatrix4(e.matrixWorld),
            this.union(Dl);
    }
    const i = e.children;
    for (let r = 0, s = i.length; r < s; r++) this.expandByObject(i[r], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Bs),
      Bs.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, i;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Hu),
      rp.subVectors(this.max, Hu),
      Fl.subVectors(e.a, Hu),
      Nl.subVectors(e.b, Hu),
      Ul.subVectors(e.c, Hu),
      po.subVectors(Nl, Fl),
      mo.subVectors(Ul, Nl),
      ga.subVectors(Fl, Ul);
    let t = [
      0,
      -po.z,
      po.y,
      0,
      -mo.z,
      mo.y,
      0,
      -ga.z,
      ga.y,
      po.z,
      0,
      -po.x,
      mo.z,
      0,
      -mo.x,
      ga.z,
      0,
      -ga.x,
      -po.y,
      po.x,
      0,
      -mo.y,
      mo.x,
      0,
      -ga.y,
      ga.x,
      0,
    ];
    return !ny(t, Fl, Nl, Ul, rp) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !ny(t, Fl, Nl, Ul, rp))
      ? !1
      : (sp.crossVectors(po, mo),
        (t = [sp.x, sp.y, sp.z]),
        ny(t, Fl, Nl, Ul, rp));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Bs).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Bs).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Ps[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Ps[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Ps[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Ps[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Ps[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Ps[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Ps[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Ps[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Ps),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ps = [
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
  ],
  Bs = new F(),
  Dl = new Yr(),
  Fl = new F(),
  Nl = new F(),
  Ul = new F(),
  po = new F(),
  mo = new F(),
  ga = new F(),
  Hu = new F(),
  rp = new F(),
  sp = new F(),
  va = new F();
function ny(n, e, t, i, r) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    va.fromArray(n, s);
    const a =
        r.x * Math.abs(va.x) + r.y * Math.abs(va.y) + r.z * Math.abs(va.z),
      l = e.dot(va),
      u = t.dot(va),
      h = i.dot(va);
    if (Math.max(-Math.max(l, u, h), Math.min(l, u, h)) > a) return !1;
  }
  return !0;
}
const lO = new Yr(),
  zu = new F(),
  iy = new F();
class Tr {
  constructor(e = new F(), t = -1) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : lO.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++)
      r = Math.max(r, i.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(r)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    zu.subVectors(e, this.center);
    const t = zu.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t),
        r = (i - this.radius) * 0.5;
      this.center.addScaledVector(zu, r / i), (this.radius += r);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (iy.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(zu.copy(e.center).add(iy)),
            this.expandByPoint(zu.copy(e.center).sub(iy))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ls = new F(),
  ry = new F(),
  op = new F(),
  go = new F(),
  sy = new F(),
  ap = new F(),
  oy = new F();
class au {
  constructor(e = new F(), t = new F(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Ls)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Ls.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Ls.copy(this.origin).addScaledVector(this.direction, t),
        Ls.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    ry.copy(e).add(t).multiplyScalar(0.5),
      op.copy(t).sub(e).normalize(),
      go.copy(this.origin).sub(ry);
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(op),
      a = go.dot(this.direction),
      l = -go.dot(op),
      u = go.lengthSq(),
      h = Math.abs(1 - o * o);
    let d, p, m, y;
    if (h > 0)
      if (((d = o * l - a), (p = o * a - l), (y = s * h), d >= 0))
        if (p >= -y)
          if (p <= y) {
            const M = 1 / h;
            (d *= M),
              (p *= M),
              (m = d * (d + o * p + 2 * a) + p * (o * d + p + 2 * l) + u);
          } else
            (p = s),
              (d = Math.max(0, -(o * p + a))),
              (m = -d * d + p * (p + 2 * l) + u);
        else
          (p = -s),
            (d = Math.max(0, -(o * p + a))),
            (m = -d * d + p * (p + 2 * l) + u);
      else
        p <= -y
          ? ((d = Math.max(0, -(-o * s + a))),
            (p = d > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (m = -d * d + p * (p + 2 * l) + u))
          : p <= y
          ? ((d = 0),
            (p = Math.min(Math.max(-s, -l), s)),
            (m = p * (p + 2 * l) + u))
          : ((d = Math.max(0, -(o * s + a))),
            (p = d > 0 ? s : Math.min(Math.max(-s, -l), s)),
            (m = -d * d + p * (p + 2 * l) + u));
    else
      (p = o > 0 ? -s : s),
        (d = Math.max(0, -(o * p + a))),
        (m = -d * d + p * (p + 2 * l) + u);
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, d),
      r && r.copy(ry).addScaledVector(op, p),
      m
    );
  }
  intersectSphere(e, t) {
    Ls.subVectors(e.center, this.origin);
    const i = Ls.dot(this.direction),
      r = Ls.dot(Ls) - i * i,
      s = e.radius * e.radius;
    if (r > s) return null;
    const o = Math.sqrt(s - r),
      a = i - o,
      l = i + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, s, o, a, l;
    const u = 1 / this.direction.x,
      h = 1 / this.direction.y,
      d = 1 / this.direction.z,
      p = this.origin;
    return (
      u >= 0
        ? ((i = (e.min.x - p.x) * u), (r = (e.max.x - p.x) * u))
        : ((i = (e.max.x - p.x) * u), (r = (e.min.x - p.x) * u)),
      h >= 0
        ? ((s = (e.min.y - p.y) * h), (o = (e.max.y - p.y) * h))
        : ((s = (e.max.y - p.y) * h), (o = (e.min.y - p.y) * h)),
      i > o ||
      s > r ||
      ((s > i || isNaN(i)) && (i = s),
      (o < r || isNaN(r)) && (r = o),
      d >= 0
        ? ((a = (e.min.z - p.z) * d), (l = (e.max.z - p.z) * d))
        : ((a = (e.max.z - p.z) * d), (l = (e.min.z - p.z) * d)),
      i > l || a > r) ||
      ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Ls) !== null;
  }
  intersectTriangle(e, t, i, r, s) {
    sy.subVectors(t, e), ap.subVectors(i, e), oy.crossVectors(sy, ap);
    let o = this.direction.dot(oy),
      a;
    if (o > 0) {
      if (r) return null;
      a = 1;
    } else if (o < 0) (a = -1), (o = -o);
    else return null;
    go.subVectors(this.origin, e);
    const l = a * this.direction.dot(ap.crossVectors(go, ap));
    if (l < 0) return null;
    const u = a * this.direction.dot(sy.cross(go));
    if (u < 0 || l + u > o) return null;
    const h = -a * go.dot(oy);
    return h < 0 ? null : this.at(h / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class rt {
  constructor(e, t, i, r, s, o, a, l, u, h, d, p, m, y, M, A) {
    (rt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, l, u, h, d, p, m, y, M, A);
  }
  set(e, t, i, r, s, o, a, l, u, h, d, p, m, y, M, A) {
    const g = this.elements;
    return (
      (g[0] = e),
      (g[4] = t),
      (g[8] = i),
      (g[12] = r),
      (g[1] = s),
      (g[5] = o),
      (g[9] = a),
      (g[13] = l),
      (g[2] = u),
      (g[6] = h),
      (g[10] = d),
      (g[14] = p),
      (g[3] = m),
      (g[7] = y),
      (g[11] = M),
      (g[15] = A),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new rt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements;
    return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      r = 1 / Ol.setFromMatrixColumn(e, 0).length(),
      s = 1 / Ol.setFromMatrixColumn(e, 1).length(),
      o = 1 / Ol.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = i[0] * r),
      (t[1] = i[1] * r),
      (t[2] = i[2] * r),
      (t[3] = 0),
      (t[4] = i[4] * s),
      (t[5] = i[5] * s),
      (t[6] = i[6] * s),
      (t[7] = 0),
      (t[8] = i[8] * o),
      (t[9] = i[9] * o),
      (t[10] = i[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z,
      o = Math.cos(i),
      a = Math.sin(i),
      l = Math.cos(r),
      u = Math.sin(r),
      h = Math.cos(s),
      d = Math.sin(s);
    if (e.order === "XYZ") {
      const p = o * h,
        m = o * d,
        y = a * h,
        M = a * d;
      (t[0] = l * h),
        (t[4] = -l * d),
        (t[8] = u),
        (t[1] = m + y * u),
        (t[5] = p - M * u),
        (t[9] = -a * l),
        (t[2] = M - p * u),
        (t[6] = y + m * u),
        (t[10] = o * l);
    } else if (e.order === "YXZ") {
      const p = l * h,
        m = l * d,
        y = u * h,
        M = u * d;
      (t[0] = p + M * a),
        (t[4] = y * a - m),
        (t[8] = o * u),
        (t[1] = o * d),
        (t[5] = o * h),
        (t[9] = -a),
        (t[2] = m * a - y),
        (t[6] = M + p * a),
        (t[10] = o * l);
    } else if (e.order === "ZXY") {
      const p = l * h,
        m = l * d,
        y = u * h,
        M = u * d;
      (t[0] = p - M * a),
        (t[4] = -o * d),
        (t[8] = y + m * a),
        (t[1] = m + y * a),
        (t[5] = o * h),
        (t[9] = M - p * a),
        (t[2] = -o * u),
        (t[6] = a),
        (t[10] = o * l);
    } else if (e.order === "ZYX") {
      const p = o * h,
        m = o * d,
        y = a * h,
        M = a * d;
      (t[0] = l * h),
        (t[4] = y * u - m),
        (t[8] = p * u + M),
        (t[1] = l * d),
        (t[5] = M * u + p),
        (t[9] = m * u - y),
        (t[2] = -u),
        (t[6] = a * l),
        (t[10] = o * l);
    } else if (e.order === "YZX") {
      const p = o * l,
        m = o * u,
        y = a * l,
        M = a * u;
      (t[0] = l * h),
        (t[4] = M - p * d),
        (t[8] = y * d + m),
        (t[1] = d),
        (t[5] = o * h),
        (t[9] = -a * h),
        (t[2] = -u * h),
        (t[6] = m * d + y),
        (t[10] = p - M * d);
    } else if (e.order === "XZY") {
      const p = o * l,
        m = o * u,
        y = a * l,
        M = a * u;
      (t[0] = l * h),
        (t[4] = -d),
        (t[8] = u * h),
        (t[1] = p * d + M),
        (t[5] = o * h),
        (t[9] = m * d - y),
        (t[2] = y * d - m),
        (t[6] = a * h),
        (t[10] = M * d + p);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(cO, e, uO);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return (
      Gi.subVectors(e, t),
      Gi.lengthSq() === 0 && (Gi.z = 1),
      Gi.normalize(),
      vo.crossVectors(i, Gi),
      vo.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (Gi.x += 1e-4) : (Gi.z += 1e-4),
        Gi.normalize(),
        vo.crossVectors(i, Gi)),
      vo.normalize(),
      lp.crossVectors(Gi, vo),
      (r[0] = vo.x),
      (r[4] = lp.x),
      (r[8] = Gi.x),
      (r[1] = vo.y),
      (r[5] = lp.y),
      (r[9] = Gi.y),
      (r[2] = vo.z),
      (r[6] = lp.z),
      (r[10] = Gi.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[4],
      l = i[8],
      u = i[12],
      h = i[1],
      d = i[5],
      p = i[9],
      m = i[13],
      y = i[2],
      M = i[6],
      A = i[10],
      g = i[14],
      x = i[3],
      _ = i[7],
      E = i[11],
      T = i[15],
      R = r[0],
      P = r[4],
      B = r[8],
      b = r[12],
      L = r[1],
      z = r[5],
      $ = r[9],
      X = r[13],
      Y = r[2],
      K = r[6],
      ie = r[10],
      ee = r[14],
      I = r[3],
      G = r[7],
      k = r[11],
      U = r[15];
    return (
      (s[0] = o * R + a * L + l * Y + u * I),
      (s[4] = o * P + a * z + l * K + u * G),
      (s[8] = o * B + a * $ + l * ie + u * k),
      (s[12] = o * b + a * X + l * ee + u * U),
      (s[1] = h * R + d * L + p * Y + m * I),
      (s[5] = h * P + d * z + p * K + m * G),
      (s[9] = h * B + d * $ + p * ie + m * k),
      (s[13] = h * b + d * X + p * ee + m * U),
      (s[2] = y * R + M * L + A * Y + g * I),
      (s[6] = y * P + M * z + A * K + g * G),
      (s[10] = y * B + M * $ + A * ie + g * k),
      (s[14] = y * b + M * X + A * ee + g * U),
      (s[3] = x * R + _ * L + E * Y + T * I),
      (s[7] = x * P + _ * z + E * K + T * G),
      (s[11] = x * B + _ * $ + E * ie + T * k),
      (s[15] = x * b + _ * X + E * ee + T * U),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      r = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      l = e[9],
      u = e[13],
      h = e[2],
      d = e[6],
      p = e[10],
      m = e[14],
      y = e[3],
      M = e[7],
      A = e[11],
      g = e[15];
    return (
      y *
        (+s * l * d -
          r * u * d -
          s * a * p +
          i * u * p +
          r * a * m -
          i * l * m) +
      M *
        (+t * l * m -
          t * u * p +
          s * o * p -
          r * o * m +
          r * u * h -
          s * l * h) +
      A *
        (+t * u * d -
          t * a * m -
          s * o * d +
          i * o * m +
          s * a * h -
          i * u * h) +
      g *
        (-r * a * h - t * l * d + t * a * p + r * o * d - i * o * p + i * l * h)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = i)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      u = e[7],
      h = e[8],
      d = e[9],
      p = e[10],
      m = e[11],
      y = e[12],
      M = e[13],
      A = e[14],
      g = e[15],
      x = d * A * u - M * p * u + M * l * m - a * A * m - d * l * g + a * p * g,
      _ = y * p * u - h * A * u - y * l * m + o * A * m + h * l * g - o * p * g,
      E = h * M * u - y * d * u + y * a * m - o * M * m - h * a * g + o * d * g,
      T = y * d * l - h * M * l - y * a * p + o * M * p + h * a * A - o * d * A,
      R = t * x + i * _ + r * E + s * T;
    if (R === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const P = 1 / R;
    return (
      (e[0] = x * P),
      (e[1] =
        (M * p * s -
          d * A * s -
          M * r * m +
          i * A * m +
          d * r * g -
          i * p * g) *
        P),
      (e[2] =
        (a * A * s -
          M * l * s +
          M * r * u -
          i * A * u -
          a * r * g +
          i * l * g) *
        P),
      (e[3] =
        (d * l * s -
          a * p * s -
          d * r * u +
          i * p * u +
          a * r * m -
          i * l * m) *
        P),
      (e[4] = _ * P),
      (e[5] =
        (h * A * s -
          y * p * s +
          y * r * m -
          t * A * m -
          h * r * g +
          t * p * g) *
        P),
      (e[6] =
        (y * l * s -
          o * A * s -
          y * r * u +
          t * A * u +
          o * r * g -
          t * l * g) *
        P),
      (e[7] =
        (o * p * s -
          h * l * s +
          h * r * u -
          t * p * u -
          o * r * m +
          t * l * m) *
        P),
      (e[8] = E * P),
      (e[9] =
        (y * d * s -
          h * M * s -
          y * i * m +
          t * M * m +
          h * i * g -
          t * d * g) *
        P),
      (e[10] =
        (o * M * s -
          y * a * s +
          y * i * u -
          t * M * u -
          o * i * g +
          t * a * g) *
        P),
      (e[11] =
        (h * a * s -
          o * d * s -
          h * i * u +
          t * d * u +
          o * i * m -
          t * a * m) *
        P),
      (e[12] = T * P),
      (e[13] =
        (h * M * r -
          y * d * r +
          y * i * p -
          t * M * p -
          h * i * A +
          t * d * A) *
        P),
      (e[14] =
        (y * a * r -
          o * M * r -
          y * i * l +
          t * M * l +
          o * i * A -
          t * a * A) *
        P),
      (e[15] =
        (o * d * r -
          h * a * r +
          h * i * l -
          t * d * l -
          o * i * p +
          t * a * p) *
        P),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z;
    return (
      (t[0] *= i),
      (t[4] *= r),
      (t[8] *= s),
      (t[1] *= i),
      (t[5] *= r),
      (t[9] *= s),
      (t[2] *= i),
      (t[6] *= r),
      (t[10] *= s),
      (t[3] *= i),
      (t[7] *= r),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = 1 - i,
      o = e.x,
      a = e.y,
      l = e.z,
      u = s * o,
      h = s * a;
    return (
      this.set(
        u * o + i,
        u * a - r * l,
        u * l + r * a,
        0,
        u * a + r * l,
        h * a + i,
        h * l - r * o,
        0,
        u * l - r * a,
        h * l + r * o,
        s * l * l + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, i, r, s, o) {
    return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, i) {
    const r = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      l = t._w,
      u = s + s,
      h = o + o,
      d = a + a,
      p = s * u,
      m = s * h,
      y = s * d,
      M = o * h,
      A = o * d,
      g = a * d,
      x = l * u,
      _ = l * h,
      E = l * d,
      T = i.x,
      R = i.y,
      P = i.z;
    return (
      (r[0] = (1 - (M + g)) * T),
      (r[1] = (m + E) * T),
      (r[2] = (y - _) * T),
      (r[3] = 0),
      (r[4] = (m - E) * R),
      (r[5] = (1 - (p + g)) * R),
      (r[6] = (A + x) * R),
      (r[7] = 0),
      (r[8] = (y + _) * P),
      (r[9] = (A - x) * P),
      (r[10] = (1 - (p + M)) * P),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = Ol.set(r[0], r[1], r[2]).length();
    const o = Ol.set(r[4], r[5], r[6]).length(),
      a = Ol.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      Lr.copy(this);
    const u = 1 / s,
      h = 1 / o,
      d = 1 / a;
    return (
      (Lr.elements[0] *= u),
      (Lr.elements[1] *= u),
      (Lr.elements[2] *= u),
      (Lr.elements[4] *= h),
      (Lr.elements[5] *= h),
      (Lr.elements[6] *= h),
      (Lr.elements[8] *= d),
      (Lr.elements[9] *= d),
      (Lr.elements[10] *= d),
      t.setFromRotationMatrix(Lr),
      (i.x = s),
      (i.y = o),
      (i.z = a),
      this
    );
  }
  makePerspective(e, t, i, r, s, o, a = hs) {
    const l = this.elements,
      u = (2 * s) / (t - e),
      h = (2 * s) / (i - r),
      d = (t + e) / (t - e),
      p = (i + r) / (i - r);
    let m, y;
    if (a === hs) (m = -(o + s) / (o - s)), (y = (-2 * o * s) / (o - s));
    else if (a === nh) (m = -o / (o - s)), (y = (-o * s) / (o - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = u),
      (l[4] = 0),
      (l[8] = d),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = h),
      (l[9] = p),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = m),
      (l[14] = y),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, i, r, s, o, a = hs) {
    const l = this.elements,
      u = 1 / (t - e),
      h = 1 / (i - r),
      d = 1 / (o - s),
      p = (t + e) * u,
      m = (i + r) * h;
    let y, M;
    if (a === hs) (y = (o + s) * d), (M = -2 * d);
    else if (a === nh) (y = s * d), (M = -1 * d);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = 2 * u),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -p),
      (l[1] = 0),
      (l[5] = 2 * h),
      (l[9] = 0),
      (l[13] = -m),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = M),
      (l[14] = -y),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    );
  }
}
const Ol = new F(),
  Lr = new rt(),
  cO = new F(0, 0, 0),
  uO = new F(1, 1, 1),
  vo = new F(),
  lp = new F(),
  Gi = new F(),
  Cw = new rt(),
  bw = new Wn();
class Eh {
  constructor(e = 0, t = 0, i = 0, r = Eh.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements,
      s = r[0],
      o = r[4],
      a = r[8],
      l = r[1],
      u = r[5],
      h = r[9],
      d = r[2],
      p = r[6],
      m = r[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(vn(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-h, m)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(p, u)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-vn(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(a, m)), (this._z = Math.atan2(l, u)))
            : ((this._y = Math.atan2(-d, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(vn(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._y = Math.atan2(-d, m)), (this._z = Math.atan2(-o, u)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-vn(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._x = Math.atan2(p, m)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, u)));
        break;
      case "YZX":
        (this._z = Math.asin(vn(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-h, u)), (this._y = Math.atan2(-d, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, m)));
        break;
      case "XZY":
        (this._z = Math.asin(-vn(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(p, u)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-h, m)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return (
      Cw.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Cw, t, i)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return bw.setFromEuler(this), this.setFromQuaternion(bw, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Eh.DEFAULT_ORDER = "XYZ";
class Za {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let fO = 0;
const Rw = new F(),
  kl = new Wn(),
  Is = new rt(),
  cp = new F(),
  Gu = new F(),
  hO = new F(),
  dO = new Wn(),
  Pw = new F(1, 0, 0),
  Bw = new F(0, 1, 0),
  Lw = new F(0, 0, 1),
  pO = { type: "added" },
  Iw = { type: "removed" };
class Rt extends Ss {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: fO++ }),
      (this.uuid = qi()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Rt.DEFAULT_UP.clone());
    const e = new F(),
      t = new Eh(),
      i = new Wn(),
      r = new F(1, 1, 1);
    function s() {
      i.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(s),
      i._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new rt() },
        normalMatrix: { value: new _t() },
      }),
      (this.matrix = new rt()),
      (this.matrixWorld = new rt()),
      (this.matrixAutoUpdate = Rt.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = Rt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new Za()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return kl.setFromAxisAngle(e, t), this.quaternion.multiply(kl), this;
  }
  rotateOnWorldAxis(e, t) {
    return kl.setFromAxisAngle(e, t), this.quaternion.premultiply(kl), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Pw, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Bw, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Lw, e);
  }
  translateOnAxis(e, t) {
    return (
      Rw.copy(e).applyQuaternion(this.quaternion),
      this.position.add(Rw.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(Pw, e);
  }
  translateY(e) {
    return this.translateOnAxis(Bw, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Lw, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Is.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, i) {
    e.isVector3 ? cp.copy(e) : cp.set(e, t, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1),
      Gu.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Is.lookAt(Gu, cp, this.up)
        : Is.lookAt(cp, Gu, this.up),
      this.quaternion.setFromRotationMatrix(Is),
      r &&
        (Is.extractRotation(r.matrixWorld),
        kl.setFromRotationMatrix(Is),
        this.quaternion.premultiply(kl.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(pO))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(Iw)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      (t.parent = null), t.dispatchEvent(Iw);
    }
    return (this.children.length = 0), this;
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Is.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Is.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Is),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t) {
    let i = [];
    this[e] === t && i.push(this);
    for (let r = 0, s = this.children.length; r < s; r++) {
      const o = this.children[r].getObjectsByProperty(e, t);
      o.length > 0 && (i = i.concat(o));
    }
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Gu, e, hO), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Gu, dO, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (
      (e === !0 &&
        i !== null &&
        i.matrixWorldAutoUpdate === !0 &&
        i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      i = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const r = {};
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON()));
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let u = 0, h = l.length; u < h; u++) {
            const d = l[u];
            s(e.shapes, d);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, u = this.material.length; l < u; l++)
          a.push(s(e.materials, this.material[l]));
        r.material = a;
      } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        r.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries),
        l = o(e.materials),
        u = o(e.textures),
        h = o(e.images),
        d = o(e.shapes),
        p = o(e.skeletons),
        m = o(e.animations),
        y = o(e.nodes);
      a.length > 0 && (i.geometries = a),
        l.length > 0 && (i.materials = l),
        u.length > 0 && (i.textures = u),
        h.length > 0 && (i.images = h),
        d.length > 0 && (i.shapes = d),
        p.length > 0 && (i.skeletons = p),
        m.length > 0 && (i.animations = m),
        y.length > 0 && (i.nodes = y);
    }
    return (i.object = r), i;
    function o(a) {
      const l = [];
      for (const u in a) {
        const h = a[u];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
Rt.DEFAULT_UP = new F(0, 1, 0);
Rt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Rt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Ir = new F(),
  Ds = new F(),
  ay = new F(),
  Fs = new F(),
  Hl = new F(),
  zl = new F(),
  Dw = new F(),
  ly = new F(),
  cy = new F(),
  uy = new F();
let up = !1;
class Ci {
  constructor(e = new F(), t = new F(), i = new F()) {
    (this.a = e), (this.b = t), (this.c = i);
  }
  static getNormal(e, t, i, r) {
    r.subVectors(i, t), Ir.subVectors(e, t), r.cross(Ir);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, r, s) {
    Ir.subVectors(r, t), Ds.subVectors(i, t), ay.subVectors(e, t);
    const o = Ir.dot(Ir),
      a = Ir.dot(Ds),
      l = Ir.dot(ay),
      u = Ds.dot(Ds),
      h = Ds.dot(ay),
      d = o * u - a * a;
    if (d === 0) return s.set(-2, -1, -1);
    const p = 1 / d,
      m = (u * l - a * h) * p,
      y = (o * h - a * l) * p;
    return s.set(1 - m - y, y, m);
  }
  static containsPoint(e, t, i, r) {
    return (
      this.getBarycoord(e, t, i, r, Fs),
      Fs.x >= 0 && Fs.y >= 0 && Fs.x + Fs.y <= 1
    );
  }
  static getUV(e, t, i, r, s, o, a, l) {
    return (
      up === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (up = !0)),
      this.getInterpolation(e, t, i, r, s, o, a, l)
    );
  }
  static getInterpolation(e, t, i, r, s, o, a, l) {
    return (
      this.getBarycoord(e, t, i, r, Fs),
      l.setScalar(0),
      l.addScaledVector(s, Fs.x),
      l.addScaledVector(o, Fs.y),
      l.addScaledVector(a, Fs.z),
      l
    );
  }
  static isFrontFacing(e, t, i, r) {
    return Ir.subVectors(i, t), Ds.subVectors(e, t), Ir.cross(Ds).dot(r) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, r) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      Ir.subVectors(this.c, this.b),
      Ds.subVectors(this.a, this.b),
      Ir.cross(Ds).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Ci.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Ci.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, i, r, s) {
    return (
      up === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (up = !0)),
      Ci.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    );
  }
  getInterpolation(e, t, i, r, s) {
    return Ci.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
  }
  containsPoint(e) {
    return Ci.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Ci.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      r = this.b,
      s = this.c;
    let o, a;
    Hl.subVectors(r, i), zl.subVectors(s, i), ly.subVectors(e, i);
    const l = Hl.dot(ly),
      u = zl.dot(ly);
    if (l <= 0 && u <= 0) return t.copy(i);
    cy.subVectors(e, r);
    const h = Hl.dot(cy),
      d = zl.dot(cy);
    if (h >= 0 && d <= h) return t.copy(r);
    const p = l * d - h * u;
    if (p <= 0 && l >= 0 && h <= 0)
      return (o = l / (l - h)), t.copy(i).addScaledVector(Hl, o);
    uy.subVectors(e, s);
    const m = Hl.dot(uy),
      y = zl.dot(uy);
    if (y >= 0 && m <= y) return t.copy(s);
    const M = m * u - l * y;
    if (M <= 0 && u >= 0 && y <= 0)
      return (a = u / (u - y)), t.copy(i).addScaledVector(zl, a);
    const A = h * y - m * d;
    if (A <= 0 && d - h >= 0 && m - y >= 0)
      return (
        Dw.subVectors(s, r),
        (a = (d - h) / (d - h + (m - y))),
        t.copy(r).addScaledVector(Dw, a)
      );
    const g = 1 / (A + M + p);
    return (
      (o = M * g),
      (a = p * g),
      t.copy(i).addScaledVector(Hl, o).addScaledVector(zl, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let mO = 0;
class bn extends Ss {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: mO++ }),
      (this.uuid = qi()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Ya),
      (this.side = xs),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = l1),
      (this.blendDst = c1),
      (this.blendEquation = Fa),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = Ym),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = Q2),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = ym),
      (this.stencilZFail = ym),
      (this.stencilZPass = ym),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        r && r.isColor
          ? r.set(i)
          : r && r.isVector3 && i && i.isVector3
          ? r.copy(i)
          : (this[t] = i);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Ya && (i.blending = this.blending),
      this.side !== xs && (i.side = this.side),
      this.vertexColors && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = this.transparent),
      (i.depthFunc = this.depthFunc),
      (i.depthTest = this.depthTest),
      (i.depthWrite = this.depthWrite),
      (i.colorWrite = this.colorWrite),
      (i.stencilWrite = this.stencilWrite),
      (i.stencilWriteMask = this.stencilWriteMask),
      (i.stencilFunc = this.stencilFunc),
      (i.stencilRef = this.stencilRef),
      (i.stencilFuncMask = this.stencilFuncMask),
      (i.stencilFail = this.stencilFail),
      (i.stencilZFail = this.stencilZFail),
      (i.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (i.alphaHash = this.alphaHash),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (i.premultipliedAlpha = this.premultipliedAlpha),
      this.forceSinglePass === !0 && (i.forceSinglePass = this.forceSinglePass),
      this.wireframe === !0 && (i.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = this.flatShading),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const s = r(e.textures),
        o = r(e.images);
      s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const lB = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Dr = { h: 0, s: 0, l: 0 },
  fp = { h: 0, s: 0, l: 0 };
function fy(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  );
}
class Ue {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, i)
    );
  }
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const r = e;
      r && r.isColor
        ? this.copy(r)
        : typeof r == "number"
        ? this.setHex(r)
        : typeof r == "string" && this.setStyle(r);
    } else this.setRGB(e, t, i);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = mt) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      mr.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, i, r = mr.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      mr.toWorkingColorSpace(this, r),
      this
    );
  }
  setHSL(e, t, i, r = mr.workingColorSpace) {
    if (((e = A1(e, 1)), (t = vn(t, 0, 1)), (i = vn(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        o = 2 * i - s;
      (this.r = fy(o, s, e + 1 / 3)),
        (this.g = fy(o, s, e)),
        (this.b = fy(o, s, e - 1 / 3));
    }
    return mr.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = mt) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let r;
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = r[1],
        a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = mt) {
    const i = lB[e.toLowerCase()];
    return (
      i !== void 0
        ? this.setHex(i, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Ic(e.r)), (this.g = Ic(e.g)), (this.b = Ic(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = $v(e.r)), (this.g = $v(e.g)), (this.b = $v(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = mt) {
    return (
      mr.fromWorkingColorSpace(oi.copy(this), e),
      Math.round(vn(oi.r * 255, 0, 255)) * 65536 +
        Math.round(vn(oi.g * 255, 0, 255)) * 256 +
        Math.round(vn(oi.b * 255, 0, 255))
    );
  }
  getHexString(e = mt) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = mr.workingColorSpace) {
    mr.fromWorkingColorSpace(oi.copy(this), t);
    const i = oi.r,
      r = oi.g,
      s = oi.b,
      o = Math.max(i, r, s),
      a = Math.min(i, r, s);
    let l, u;
    const h = (a + o) / 2;
    if (a === o) (l = 0), (u = 0);
    else {
      const d = o - a;
      switch (((u = h <= 0.5 ? d / (o + a) : d / (2 - o - a)), o)) {
        case i:
          l = (r - s) / d + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - i) / d + 2;
          break;
        case s:
          l = (i - r) / d + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = u), (e.l = h), e;
  }
  getRGB(e, t = mr.workingColorSpace) {
    return (
      mr.fromWorkingColorSpace(oi.copy(this), t),
      (e.r = oi.r),
      (e.g = oi.g),
      (e.b = oi.b),
      e
    );
  }
  getStyle(e = mt) {
    mr.fromWorkingColorSpace(oi.copy(this), e);
    const t = oi.r,
      i = oi.g,
      r = oi.b;
    return e !== mt
      ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(
          r * 255
        )})`;
  }
  offsetHSL(e, t, i) {
    return (
      this.getHSL(Dr),
      (Dr.h += e),
      (Dr.s += t),
      (Dr.l += i),
      this.setHSL(Dr.h, Dr.s, Dr.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Dr), e.getHSL(fp);
    const i = Ef(Dr.h, fp.h, t),
      r = Ef(Dr.s, fp.s, t),
      s = Ef(Dr.l, fp.l, t);
    return this.setHSL(i, r, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      i = this.g,
      r = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * i + s[6] * r),
      (this.g = s[1] * t + s[4] * i + s[7] * r),
      (this.b = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const oi = new Ue();
Ue.NAMES = lB;
class Ji extends bn {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Ue(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Mh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const ks = gO();
function gO() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    i = new Uint32Array(512),
    r = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const u = l - 127;
    u < -27
      ? ((i[l] = 0), (i[l | 256] = 32768), (r[l] = 24), (r[l | 256] = 24))
      : u < -14
      ? ((i[l] = 1024 >> (-u - 14)),
        (i[l | 256] = (1024 >> (-u - 14)) | 32768),
        (r[l] = -u - 1),
        (r[l | 256] = -u - 1))
      : u <= 15
      ? ((i[l] = (u + 15) << 10),
        (i[l | 256] = ((u + 15) << 10) | 32768),
        (r[l] = 13),
        (r[l | 256] = 13))
      : u < 128
      ? ((i[l] = 31744), (i[l | 256] = 64512), (r[l] = 24), (r[l | 256] = 24))
      : ((i[l] = 31744), (i[l | 256] = 64512), (r[l] = 13), (r[l | 256] = 13));
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let u = l << 13,
      h = 0;
    for (; !(u & 8388608); ) (u <<= 1), (h -= 8388608);
    (u &= -8388609), (h += 947912704), (s[l] = u | h);
  }
  for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) o[l] = l << 23;
  (o[31] = 1199570944), (o[32] = 2147483648);
  for (let l = 33; l < 63; ++l) o[l] = 2147483648 + ((l - 32) << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: i,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  };
}
function wi(n) {
  Math.abs(n) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (n = vn(n, -65504, 65504)),
    (ks.floatView[0] = n);
  const e = ks.uint32View[0],
    t = (e >> 23) & 511;
  return ks.baseTable[t] + ((e & 8388607) >> ks.shiftTable[t]);
}
function ff(n) {
  const e = n >> 10;
  return (
    (ks.uint32View[0] =
      ks.mantissaTable[ks.offsetTable[e] + (n & 1023)] + ks.exponentTable[e]),
    ks.floatView[0]
  );
}
const vO = { toHalfFloat: wi, fromHalfFloat: ff },
  wn = new F(),
  hp = new ve();
class Ft {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = th),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.gpuType = fs),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.itemSize), (i *= t.itemSize);
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        hp.fromBufferAttribute(this, t),
          hp.applyMatrix3(e),
          this.setXY(t, hp.x, hp.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        wn.fromBufferAttribute(this, t),
          wn.applyMatrix3(e),
          this.setXYZ(t, wn.x, wn.y, wn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      wn.fromBufferAttribute(this, t),
        wn.applyMatrix4(e),
        this.setXYZ(t, wn.x, wn.y, wn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      wn.fromBufferAttribute(this, t),
        wn.applyNormalMatrix(e),
        this.setXYZ(t, wn.x, wn.y, wn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      wn.fromBufferAttribute(this, t),
        wn.transformDirection(e),
        this.setXYZ(t, wn.x, wn.y, wn.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Xi(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = At(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Xi(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = At(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Xi(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = At(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Xi(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = At(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = At(t, this.array)), (i = At(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = At(t, this.array)),
        (i = At(i, this.array)),
        (r = At(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = At(t, this.array)),
        (i = At(i, this.array)),
        (r = At(r, this.array)),
        (s = At(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== th && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    );
  }
}
class yO extends Ft {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i);
  }
}
class xO extends Ft {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i);
  }
}
class _O extends Ft {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i);
  }
}
class AO extends Ft {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i);
  }
}
class E1 extends Ft {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class SO extends Ft {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i);
  }
}
class w1 extends Ft {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class MO extends Ft {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = ff(this.array[e * this.itemSize]);
    return this.normalized && (t = Xi(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = At(t, this.array)),
      (this.array[e * this.itemSize] = wi(t)),
      this
    );
  }
  getY(e) {
    let t = ff(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Xi(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = At(t, this.array)),
      (this.array[e * this.itemSize + 1] = wi(t)),
      this
    );
  }
  getZ(e) {
    let t = ff(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Xi(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = At(t, this.array)),
      (this.array[e * this.itemSize + 2] = wi(t)),
      this
    );
  }
  getW(e) {
    let t = ff(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Xi(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = At(t, this.array)),
      (this.array[e * this.itemSize + 3] = wi(t)),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = At(t, this.array)), (i = At(i, this.array))),
      (this.array[e + 0] = wi(t)),
      (this.array[e + 1] = wi(i)),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = At(t, this.array)),
        (i = At(i, this.array)),
        (r = At(r, this.array))),
      (this.array[e + 0] = wi(t)),
      (this.array[e + 1] = wi(i)),
      (this.array[e + 2] = wi(r)),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = At(t, this.array)),
        (i = At(i, this.array)),
        (r = At(r, this.array)),
        (s = At(s, this.array))),
      (this.array[e + 0] = wi(t)),
      (this.array[e + 1] = wi(i)),
      (this.array[e + 2] = wi(r)),
      (this.array[e + 3] = wi(s)),
      this
    );
  }
}
class Ye extends Ft {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
class EO extends Ft {
  constructor(e, t, i) {
    super(new Float64Array(e), t, i);
  }
}
let wO = 0;
const hr = new rt(),
  hy = new Rt(),
  Gl = new F(),
  Vi = new Yr(),
  Vu = new Yr(),
  kn = new F();
class gt extends Ss {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: wO++ }),
      (this.uuid = qi()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (aB(e) ? w1 : E1)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new _t().getNormalMatrix(e);
      i.applyNormalMatrix(s), (i.needsUpdate = !0);
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return hr.makeRotationFromQuaternion(e), this.applyMatrix4(hr), this;
  }
  rotateX(e) {
    return hr.makeRotationX(e), this.applyMatrix4(hr), this;
  }
  rotateY(e) {
    return hr.makeRotationY(e), this.applyMatrix4(hr), this;
  }
  rotateZ(e) {
    return hr.makeRotationZ(e), this.applyMatrix4(hr), this;
  }
  translate(e, t, i) {
    return hr.makeTranslation(e, t, i), this.applyMatrix4(hr), this;
  }
  scale(e, t, i) {
    return hr.makeScale(e, t, i), this.applyMatrix4(hr), this;
  }
  lookAt(e) {
    return hy.lookAt(e), hy.updateMatrix(), this.applyMatrix4(hy.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Gl).negate(),
      this.translate(Gl.x, Gl.y, Gl.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const s = e[i];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Ye(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Yr());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new F(-1 / 0, -1 / 0, -1 / 0),
          new F(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i];
          Vi.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (kn.addVectors(this.boundingBox.min, Vi.min),
                this.boundingBox.expandByPoint(kn),
                kn.addVectors(this.boundingBox.max, Vi.max),
                this.boundingBox.expandByPoint(kn))
              : (this.boundingBox.expandByPoint(Vi.min),
                this.boundingBox.expandByPoint(Vi.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Tr());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new F(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if ((Vi.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s];
          Vu.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (kn.addVectors(Vi.min, Vu.min),
                Vi.expandByPoint(kn),
                kn.addVectors(Vi.max, Vu.max),
                Vi.expandByPoint(kn))
              : (Vi.expandByPoint(Vu.min), Vi.expandByPoint(Vu.max));
        }
      Vi.getCenter(i);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        kn.fromBufferAttribute(e, s),
          (r = Math.max(r, i.distanceToSquared(kn)));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            l = this.morphTargetsRelative;
          for (let u = 0, h = a.count; u < h; u++)
            kn.fromBufferAttribute(a, u),
              l && (Gl.fromBufferAttribute(e, u), kn.add(Gl)),
              (r = Math.max(r, i.distanceToSquared(kn)));
        }
      (this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const i = e.array,
      r = t.position.array,
      s = t.normal.array,
      o = t.uv.array,
      a = r.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Ft(new Float32Array(4 * a), 4));
    const l = this.getAttribute("tangent").array,
      u = [],
      h = [];
    for (let L = 0; L < a; L++) (u[L] = new F()), (h[L] = new F());
    const d = new F(),
      p = new F(),
      m = new F(),
      y = new ve(),
      M = new ve(),
      A = new ve(),
      g = new F(),
      x = new F();
    function _(L, z, $) {
      d.fromArray(r, L * 3),
        p.fromArray(r, z * 3),
        m.fromArray(r, $ * 3),
        y.fromArray(o, L * 2),
        M.fromArray(o, z * 2),
        A.fromArray(o, $ * 2),
        p.sub(d),
        m.sub(d),
        M.sub(y),
        A.sub(y);
      const X = 1 / (M.x * A.y - A.x * M.y);
      isFinite(X) &&
        (g
          .copy(p)
          .multiplyScalar(A.y)
          .addScaledVector(m, -M.y)
          .multiplyScalar(X),
        x
          .copy(m)
          .multiplyScalar(M.x)
          .addScaledVector(p, -A.x)
          .multiplyScalar(X),
        u[L].add(g),
        u[z].add(g),
        u[$].add(g),
        h[L].add(x),
        h[z].add(x),
        h[$].add(x));
    }
    let E = this.groups;
    E.length === 0 && (E = [{ start: 0, count: i.length }]);
    for (let L = 0, z = E.length; L < z; ++L) {
      const $ = E[L],
        X = $.start,
        Y = $.count;
      for (let K = X, ie = X + Y; K < ie; K += 3)
        _(i[K + 0], i[K + 1], i[K + 2]);
    }
    const T = new F(),
      R = new F(),
      P = new F(),
      B = new F();
    function b(L) {
      P.fromArray(s, L * 3), B.copy(P);
      const z = u[L];
      T.copy(z),
        T.sub(P.multiplyScalar(P.dot(z))).normalize(),
        R.crossVectors(B, z);
      const X = R.dot(h[L]) < 0 ? -1 : 1;
      (l[L * 4] = T.x),
        (l[L * 4 + 1] = T.y),
        (l[L * 4 + 2] = T.z),
        (l[L * 4 + 3] = X);
    }
    for (let L = 0, z = E.length; L < z; ++L) {
      const $ = E[L],
        X = $.start,
        Y = $.count;
      for (let K = X, ie = X + Y; K < ie; K += 3)
        b(i[K + 0]), b(i[K + 1]), b(i[K + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        (i = new Ft(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", i);
      else for (let p = 0, m = i.count; p < m; p++) i.setXYZ(p, 0, 0, 0);
      const r = new F(),
        s = new F(),
        o = new F(),
        a = new F(),
        l = new F(),
        u = new F(),
        h = new F(),
        d = new F();
      if (e)
        for (let p = 0, m = e.count; p < m; p += 3) {
          const y = e.getX(p + 0),
            M = e.getX(p + 1),
            A = e.getX(p + 2);
          r.fromBufferAttribute(t, y),
            s.fromBufferAttribute(t, M),
            o.fromBufferAttribute(t, A),
            h.subVectors(o, s),
            d.subVectors(r, s),
            h.cross(d),
            a.fromBufferAttribute(i, y),
            l.fromBufferAttribute(i, M),
            u.fromBufferAttribute(i, A),
            a.add(h),
            l.add(h),
            u.add(h),
            i.setXYZ(y, a.x, a.y, a.z),
            i.setXYZ(M, l.x, l.y, l.z),
            i.setXYZ(A, u.x, u.y, u.z);
        }
      else
        for (let p = 0, m = t.count; p < m; p += 3)
          r.fromBufferAttribute(t, p + 0),
            s.fromBufferAttribute(t, p + 1),
            o.fromBufferAttribute(t, p + 2),
            h.subVectors(o, s),
            d.subVectors(r, s),
            h.cross(d),
            i.setXYZ(p + 0, h.x, h.y, h.z),
            i.setXYZ(p + 1, h.x, h.y, h.z),
            i.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), (i.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      kn.fromBufferAttribute(e, t),
        kn.normalize(),
        e.setXYZ(t, kn.x, kn.y, kn.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const u = a.array,
        h = a.itemSize,
        d = a.normalized,
        p = new u.constructor(l.length * h);
      let m = 0,
        y = 0;
      for (let M = 0, A = l.length; M < A; M++) {
        a.isInterleavedBufferAttribute
          ? (m = l[M] * a.data.stride + a.offset)
          : (m = l[M] * h);
        for (let g = 0; g < h; g++) p[y++] = u[m++];
      }
      return new Ft(p, h, d);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new gt(),
      i = this.index.array,
      r = this.attributes;
    for (const a in r) {
      const l = r[a],
        u = e(l, i);
      t.setAttribute(a, u);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [],
        u = s[a];
      for (let h = 0, d = u.length; h < d; h++) {
        const p = u[h],
          m = e(p, i);
        l.push(m);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const u = o[a];
      t.addGroup(u.start, u.count, u.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const u in l) l[u] !== void 0 && (e[u] = l[u]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const i = this.attributes;
    for (const l in i) {
      const u = i[l];
      e.data.attributes[l] = u.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const u = this.morphAttributes[l],
        h = [];
      for (let d = 0, p = u.length; d < p; d++) {
        const m = u[d];
        h.push(m.toJSON(e.data));
      }
      h.length > 0 && ((r[l] = h), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const r = e.attributes;
    for (const u in r) {
      const h = r[u];
      this.setAttribute(u, h.clone(t));
    }
    const s = e.morphAttributes;
    for (const u in s) {
      const h = [],
        d = s[u];
      for (let p = 0, m = d.length; p < m; p++) h.push(d[p].clone(t));
      this.morphAttributes[u] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let u = 0, h = o.length; u < h; u++) {
      const d = o[u];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Fw = new rt(),
  ya = new au(),
  dp = new Tr(),
  Nw = new F(),
  Vl = new F(),
  Wl = new F(),
  jl = new F(),
  dy = new F(),
  pp = new F(),
  mp = new ve(),
  gp = new ve(),
  vp = new ve(),
  Uw = new F(),
  Ow = new F(),
  kw = new F(),
  yp = new F(),
  xp = new F();
class Gn extends Rt {
  constructor(e = new gt(), t = new Ji()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      r = i.attributes.position,
      s = i.morphAttributes.position,
      o = i.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      pp.set(0, 0, 0);
      for (let l = 0, u = s.length; l < u; l++) {
        const h = a[l],
          d = s[l];
        h !== 0 &&
          (dy.fromBufferAttribute(d, e),
          o ? pp.addScaledVector(dy, h) : pp.addScaledVector(dy.sub(t), h));
      }
      t.add(pp);
    }
    return t;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.material,
      s = this.matrixWorld;
    r !== void 0 &&
      (i.boundingSphere === null && i.computeBoundingSphere(),
      dp.copy(i.boundingSphere),
      dp.applyMatrix4(s),
      ya.copy(e.ray).recast(e.near),
      !(
        dp.containsPoint(ya.origin) === !1 &&
        (ya.intersectSphere(dp, Nw) === null ||
          ya.origin.distanceToSquared(Nw) > (e.far - e.near) ** 2)
      ) &&
        (Fw.copy(s).invert(),
        ya.copy(e.ray).applyMatrix4(Fw),
        !(i.boundingBox !== null && ya.intersectsBox(i.boundingBox) === !1) &&
          this._computeIntersections(e, t, ya)));
  }
  _computeIntersections(e, t, i) {
    let r;
    const s = this.geometry,
      o = this.material,
      a = s.index,
      l = s.attributes.position,
      u = s.attributes.uv,
      h = s.attributes.uv1,
      d = s.attributes.normal,
      p = s.groups,
      m = s.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let y = 0, M = p.length; y < M; y++) {
          const A = p[y],
            g = o[A.materialIndex],
            x = Math.max(A.start, m.start),
            _ = Math.min(
              a.count,
              Math.min(A.start + A.count, m.start + m.count)
            );
          for (let E = x, T = _; E < T; E += 3) {
            const R = a.getX(E),
              P = a.getX(E + 1),
              B = a.getX(E + 2);
            (r = _p(this, g, e, i, u, h, d, R, P, B)),
              r &&
                ((r.faceIndex = Math.floor(E / 3)),
                (r.face.materialIndex = A.materialIndex),
                t.push(r));
          }
        }
      else {
        const y = Math.max(0, m.start),
          M = Math.min(a.count, m.start + m.count);
        for (let A = y, g = M; A < g; A += 3) {
          const x = a.getX(A),
            _ = a.getX(A + 1),
            E = a.getX(A + 2);
          (r = _p(this, o, e, i, u, h, d, x, _, E)),
            r && ((r.faceIndex = Math.floor(A / 3)), t.push(r));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let y = 0, M = p.length; y < M; y++) {
          const A = p[y],
            g = o[A.materialIndex],
            x = Math.max(A.start, m.start),
            _ = Math.min(
              l.count,
              Math.min(A.start + A.count, m.start + m.count)
            );
          for (let E = x, T = _; E < T; E += 3) {
            const R = E,
              P = E + 1,
              B = E + 2;
            (r = _p(this, g, e, i, u, h, d, R, P, B)),
              r &&
                ((r.faceIndex = Math.floor(E / 3)),
                (r.face.materialIndex = A.materialIndex),
                t.push(r));
          }
        }
      else {
        const y = Math.max(0, m.start),
          M = Math.min(l.count, m.start + m.count);
        for (let A = y, g = M; A < g; A += 3) {
          const x = A,
            _ = A + 1,
            E = A + 2;
          (r = _p(this, o, e, i, u, h, d, x, _, E)),
            r && ((r.faceIndex = Math.floor(A / 3)), t.push(r));
        }
      }
  }
}
function TO(n, e, t, i, r, s, o, a) {
  let l;
  if (
    (e.side === xi
      ? (l = i.intersectTriangle(o, s, r, !0, a))
      : (l = i.intersectTriangle(r, s, o, e.side === xs, a)),
    l === null)
  )
    return null;
  xp.copy(a), xp.applyMatrix4(n.matrixWorld);
  const u = t.ray.origin.distanceTo(xp);
  return u < t.near || u > t.far
    ? null
    : { distance: u, point: xp.clone(), object: n };
}
function _p(n, e, t, i, r, s, o, a, l, u) {
  n.getVertexPosition(a, Vl),
    n.getVertexPosition(l, Wl),
    n.getVertexPosition(u, jl);
  const h = TO(n, e, t, i, Vl, Wl, jl, yp);
  if (h) {
    r &&
      (mp.fromBufferAttribute(r, a),
      gp.fromBufferAttribute(r, l),
      vp.fromBufferAttribute(r, u),
      (h.uv = Ci.getInterpolation(yp, Vl, Wl, jl, mp, gp, vp, new ve()))),
      s &&
        (mp.fromBufferAttribute(s, a),
        gp.fromBufferAttribute(s, l),
        vp.fromBufferAttribute(s, u),
        (h.uv1 = Ci.getInterpolation(yp, Vl, Wl, jl, mp, gp, vp, new ve())),
        (h.uv2 = h.uv1)),
      o &&
        (Uw.fromBufferAttribute(o, a),
        Ow.fromBufferAttribute(o, l),
        kw.fromBufferAttribute(o, u),
        (h.normal = Ci.getInterpolation(yp, Vl, Wl, jl, Uw, Ow, kw, new F())),
        h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
    const d = { a, b: l, c: u, normal: new F(), materialIndex: 0 };
    Ci.getNormal(Vl, Wl, jl, d.normal), (h.face = d);
  }
  return h;
}
class hl extends gt {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      });
    const a = this;
    (r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o));
    const l = [],
      u = [],
      h = [],
      d = [];
    let p = 0,
      m = 0;
    y("z", "y", "x", -1, -1, i, t, e, o, s, 0),
      y("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
      y("x", "z", "y", 1, 1, e, i, t, r, o, 2),
      y("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
      y("x", "y", "z", 1, -1, e, t, i, r, s, 4),
      y("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new Ye(u, 3)),
      this.setAttribute("normal", new Ye(h, 3)),
      this.setAttribute("uv", new Ye(d, 2));
    function y(M, A, g, x, _, E, T, R, P, B, b) {
      const L = E / P,
        z = T / B,
        $ = E / 2,
        X = T / 2,
        Y = R / 2,
        K = P + 1,
        ie = B + 1;
      let ee = 0,
        I = 0;
      const G = new F();
      for (let k = 0; k < ie; k++) {
        const U = k * z - X;
        for (let j = 0; j < K; j++) {
          const he = j * L - $;
          (G[M] = he * x),
            (G[A] = U * _),
            (G[g] = Y),
            u.push(G.x, G.y, G.z),
            (G[M] = 0),
            (G[A] = 0),
            (G[g] = R > 0 ? 1 : -1),
            h.push(G.x, G.y, G.z),
            d.push(j / P),
            d.push(1 - k / B),
            (ee += 1);
        }
      }
      for (let k = 0; k < B; k++)
        for (let U = 0; U < P; U++) {
          const j = p + U + K * k,
            he = p + U + K * (k + 1),
            ae = p + (U + 1) + K * (k + 1),
            xe = p + (U + 1) + K * k;
          l.push(j, he, xe), l.push(he, ae, xe), (I += 6);
        }
      a.addGroup(m, I, b), (m += I), (p += ee);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new hl(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function Yc(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const i in n[t]) {
      const r = n[t][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][i] = null))
          : (e[t][i] = r.clone())
        : Array.isArray(r)
        ? (e[t][i] = r.slice())
        : (e[t][i] = r);
    }
  }
  return e;
}
function pi(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = Yc(n[t]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
function CO(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function cB(n) {
  return n.getRenderTarget() === null ? n.outputColorSpace : Xr;
}
const uB = { clone: Yc, merge: pi };
var bO = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  RO = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class As extends bn {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = bO),
      (this.fragmentShader = RO),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Yc(e.uniforms)),
      (this.uniformsGroups = CO(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture
        ? (t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (t.uniforms[r] = { type: "c", value: o.getHex() })
        : o && o.isVector2
        ? (t.uniforms[r] = { type: "v2", value: o.toArray() })
        : o && o.isVector3
        ? (t.uniforms[r] = { type: "v3", value: o.toArray() })
        : o && o.isVector4
        ? (t.uniforms[r] = { type: "v4", value: o.toArray() })
        : o && o.isMatrix3
        ? (t.uniforms[r] = { type: "m3", value: o.toArray() })
        : o && o.isMatrix4
        ? (t.uniforms[r] = { type: "m4", value: o.toArray() })
        : (t.uniforms[r] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const i = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class wh extends Rt {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new rt()),
      (this.projectionMatrix = new rt()),
      (this.projectionMatrixInverse = new rt()),
      (this.coordinateSystem = hs);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class $t extends wh {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = Kc * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(qa * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return Kc * 2 * Math.atan(Math.tan(qa * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, i, r, s, o) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(qa * 0.5 * this.fov)) / this.zoom,
      i = 2 * t,
      r = this.aspect * i,
      s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        u = o.fullHeight;
      (s += (o.offsetX * r) / l),
        (t -= (o.offsetY * i) / u),
        (r *= o.width / l),
        (i *= o.height / u);
    }
    const a = this.filmOffset;
    a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + r,
        t,
        t - i,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Xl = -90,
  Jl = 1;
class T1 extends Rt {
  constructor(e, t, i) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = i),
      (this.coordinateSystem = null);
    const r = new $t(Xl, Jl, e, t);
    (r.layers = this.layers), this.add(r);
    const s = new $t(Xl, Jl, e, t);
    (s.layers = this.layers), this.add(s);
    const o = new $t(Xl, Jl, e, t);
    (o.layers = this.layers), this.add(o);
    const a = new $t(Xl, Jl, e, t);
    (a.layers = this.layers), this.add(a);
    const l = new $t(Xl, Jl, e, t);
    (l.layers = this.layers), this.add(l);
    const u = new $t(Xl, Jl, e, t);
    (u.layers = this.layers), this.add(u);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [i, r, s, o, a, l] = t;
    for (const u of t) this.remove(u);
    if (e === hs)
      i.up.set(0, 1, 0),
        i.lookAt(1, 0, 0),
        r.up.set(0, 1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === nh)
      i.up.set(0, -1, 0),
        i.lookAt(-1, 0, 0),
        r.up.set(0, -1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const u of t) this.add(u), u.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const i = this.renderTarget;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [r, s, o, a, l, u] = this.children,
      h = e.getRenderTarget(),
      d = e.toneMapping,
      p = e.xr.enabled;
    (e.toneMapping = Vr), (e.xr.enabled = !1);
    const m = i.texture.generateMipmaps;
    (i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0),
      e.render(t, r),
      e.setRenderTarget(i, 1),
      e.render(t, s),
      e.setRenderTarget(i, 2),
      e.render(t, o),
      e.setRenderTarget(i, 3),
      e.render(t, a),
      e.setRenderTarget(i, 4),
      e.render(t, l),
      (i.texture.generateMipmaps = m),
      e.setRenderTarget(i, 5),
      e.render(t, u),
      e.setRenderTarget(h),
      (e.toneMapping = d),
      (e.xr.enabled = p),
      (i.texture.needsPMREMUpdate = !0);
  }
}
class Th extends en {
  constructor(e, t, i, r, s, o, a, l, u, h) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : Jo),
      super(e, t, i, r, s, o, a, l, u, h),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class C1 extends Jr {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const i = { width: e, height: e, depth: 1 },
      r = [i, i, i, i, i, i];
    t.encoding !== void 0 &&
      (wf(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (t.colorSpace = t.encoding === zo ? mt : Go)),
      (this.texture = new Th(
        r,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : sn);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new hl(5, 5, 5),
      s = new As({
        name: "CubemapFromEquirect",
        uniforms: Yc(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: xi,
        blending: Xs,
      });
    s.uniforms.tEquirect.value = t;
    const o = new Gn(r, s),
      a = t.minFilter;
    return (
      t.minFilter === _s && (t.minFilter = sn),
      new T1(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, r);
    e.setRenderTarget(s);
  }
}
const py = new F(),
  PO = new F(),
  BO = new _t();
class Mo {
  constructor(e = new F(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, i, r) {
    return this.normal.set(e, t, i), (this.constant = r), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const r = py.subVectors(i, t).cross(PO.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(py),
      r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (t < 0 && i > 0) || (i < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || BO.getNormalMatrix(e),
      r = this.coplanarPoint(py).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize();
    return (this.constant = -r.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const xa = new Tr(),
  Ap = new F();
class Og {
  constructor(
    e = new Mo(),
    t = new Mo(),
    i = new Mo(),
    r = new Mo(),
    s = new Mo(),
    o = new Mo()
  ) {
    this.planes = [e, t, i, r, s, o];
  }
  set(e, t, i, r, s, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(i),
      a[3].copy(r),
      a[4].copy(s),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = hs) {
    const i = this.planes,
      r = e.elements,
      s = r[0],
      o = r[1],
      a = r[2],
      l = r[3],
      u = r[4],
      h = r[5],
      d = r[6],
      p = r[7],
      m = r[8],
      y = r[9],
      M = r[10],
      A = r[11],
      g = r[12],
      x = r[13],
      _ = r[14],
      E = r[15];
    if (
      (i[0].setComponents(l - s, p - u, A - m, E - g).normalize(),
      i[1].setComponents(l + s, p + u, A + m, E + g).normalize(),
      i[2].setComponents(l + o, p + h, A + y, E + x).normalize(),
      i[3].setComponents(l - o, p - h, A - y, E - x).normalize(),
      i[4].setComponents(l - a, p - d, A - M, E - _).normalize(),
      t === hs)
    )
      i[5].setComponents(l + a, p + d, A + M, E + _).normalize();
    else if (t === nh) i[5].setComponents(a, d, M, _).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        xa.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        xa.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(xa);
  }
  intersectsSprite(e) {
    return (
      xa.center.set(0, 0, 0),
      (xa.radius = 0.7071067811865476),
      xa.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(xa)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      r = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (
        ((Ap.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (Ap.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (Ap.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(Ap) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function fB() {
  let n = null,
    e = !1,
    t = null,
    i = null;
  function r(s, o) {
    t(s, o), (i = n.requestAnimationFrame(r));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(i), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      n = s;
    },
  };
}
function LO(n, e) {
  const t = e.isWebGL2,
    i = new WeakMap();
  function r(u, h) {
    const d = u.array,
      p = u.usage,
      m = n.createBuffer();
    n.bindBuffer(h, m), n.bufferData(h, d, p), u.onUploadCallback();
    let y;
    if (d instanceof Float32Array) y = n.FLOAT;
    else if (d instanceof Uint16Array)
      if (u.isFloat16BufferAttribute)
        if (t) y = n.HALF_FLOAT;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else y = n.UNSIGNED_SHORT;
    else if (d instanceof Int16Array) y = n.SHORT;
    else if (d instanceof Uint32Array) y = n.UNSIGNED_INT;
    else if (d instanceof Int32Array) y = n.INT;
    else if (d instanceof Int8Array) y = n.BYTE;
    else if (d instanceof Uint8Array) y = n.UNSIGNED_BYTE;
    else if (d instanceof Uint8ClampedArray) y = n.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + d
      );
    return {
      buffer: m,
      type: y,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: u.version,
    };
  }
  function s(u, h, d) {
    const p = h.array,
      m = h.updateRange;
    n.bindBuffer(d, u),
      m.count === -1
        ? n.bufferSubData(d, 0, p)
        : (t
            ? n.bufferSubData(
                d,
                m.offset * p.BYTES_PER_ELEMENT,
                p,
                m.offset,
                m.count
              )
            : n.bufferSubData(
                d,
                m.offset * p.BYTES_PER_ELEMENT,
                p.subarray(m.offset, m.offset + m.count)
              ),
          (m.count = -1)),
      h.onUploadCallback();
  }
  function o(u) {
    return u.isInterleavedBufferAttribute && (u = u.data), i.get(u);
  }
  function a(u) {
    u.isInterleavedBufferAttribute && (u = u.data);
    const h = i.get(u);
    h && (n.deleteBuffer(h.buffer), i.delete(u));
  }
  function l(u, h) {
    if (u.isGLBufferAttribute) {
      const p = i.get(u);
      (!p || p.version < u.version) &&
        i.set(u, {
          buffer: u.buffer,
          type: u.type,
          bytesPerElement: u.elementSize,
          version: u.version,
        });
      return;
    }
    u.isInterleavedBufferAttribute && (u = u.data);
    const d = i.get(u);
    d === void 0
      ? i.set(u, r(u, h))
      : d.version < u.version && (s(d.buffer, u, h), (d.version = u.version));
  }
  return { get: o, remove: a, update: l };
}
class Ch extends gt {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: r,
      });
    const s = e / 2,
      o = t / 2,
      a = Math.floor(i),
      l = Math.floor(r),
      u = a + 1,
      h = l + 1,
      d = e / a,
      p = t / l,
      m = [],
      y = [],
      M = [],
      A = [];
    for (let g = 0; g < h; g++) {
      const x = g * p - o;
      for (let _ = 0; _ < u; _++) {
        const E = _ * d - s;
        y.push(E, -x, 0), M.push(0, 0, 1), A.push(_ / a), A.push(1 - g / l);
      }
    }
    for (let g = 0; g < l; g++)
      for (let x = 0; x < a; x++) {
        const _ = x + u * g,
          E = x + u * (g + 1),
          T = x + 1 + u * (g + 1),
          R = x + 1 + u * g;
        m.push(_, E, R), m.push(E, T, R);
      }
    this.setIndex(m),
      this.setAttribute("position", new Ye(y, 3)),
      this.setAttribute("normal", new Ye(M, 3)),
      this.setAttribute("uv", new Ye(A, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ch(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var IO = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  DO = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  FO = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  NO = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  UO = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  OO = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  kO = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  HO = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  zO = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  GO = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  VO = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  WO = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  jO = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  XO = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  JO = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  KO = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  YO = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  QO = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  qO = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  ZO = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  $O = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  ek = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  tk = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  nk = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  ik = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  rk = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  sk = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  ok = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  ak = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  lk = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  ck = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  uk = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  fk = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  hk = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  dk = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  pk = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  mk = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  gk = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  vk = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  yk = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  xk = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  _k = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  Ak = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  Sk = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  Mk = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  Ek = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  wk = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  Tk = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  Ck = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  bk = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  Rk = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
  Pk = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  Bk = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  Lk = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  Ik = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  Dk = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  Fk = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Nk = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  Uk = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  Ok = `#ifdef USE_MAP
	diffuseColor *= texture2D( map, vMapUv );
#endif`,
  kk = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  Hk = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  zk = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  Gk = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  Vk = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  Wk = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  jk = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  Xk = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  Jk = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  Kk = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,
  Yk = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  Qk = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  qk = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Zk = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  $k = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  eH = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  tH = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  nH = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  iH = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  rH = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  sH = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  oH = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  aH = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  lH = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  cH = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  uH = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  fH = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  hH = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  dH = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  pH = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  mH = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  gH = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  vH = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  yH = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  xH = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  _H = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  AH = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  SH = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  MH = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  EH = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  wH = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  TH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  CH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  bH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  RH = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const PH = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  BH = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  LH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  IH = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  DH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  FH = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  NH = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  UH = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  OH = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  kH = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  HH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  zH = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  GH = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  VH = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  WH = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  jH = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  XH = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  JH = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  KH = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  YH = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  QH = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  qH = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  ZH = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  $H = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  ez = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  tz = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  nz = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  iz = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  rz = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  sz = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  oz = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  az = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  lz = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  cz = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  yt = {
    alphahash_fragment: IO,
    alphahash_pars_fragment: DO,
    alphamap_fragment: FO,
    alphamap_pars_fragment: NO,
    alphatest_fragment: UO,
    alphatest_pars_fragment: OO,
    aomap_fragment: kO,
    aomap_pars_fragment: HO,
    begin_vertex: zO,
    beginnormal_vertex: GO,
    bsdfs: VO,
    iridescence_fragment: WO,
    bumpmap_pars_fragment: jO,
    clipping_planes_fragment: XO,
    clipping_planes_pars_fragment: JO,
    clipping_planes_pars_vertex: KO,
    clipping_planes_vertex: YO,
    color_fragment: QO,
    color_pars_fragment: qO,
    color_pars_vertex: ZO,
    color_vertex: $O,
    common: ek,
    cube_uv_reflection_fragment: tk,
    defaultnormal_vertex: nk,
    displacementmap_pars_vertex: ik,
    displacementmap_vertex: rk,
    emissivemap_fragment: sk,
    emissivemap_pars_fragment: ok,
    colorspace_fragment: ak,
    colorspace_pars_fragment: lk,
    envmap_fragment: ck,
    envmap_common_pars_fragment: uk,
    envmap_pars_fragment: fk,
    envmap_pars_vertex: hk,
    envmap_physical_pars_fragment: Ek,
    envmap_vertex: dk,
    fog_vertex: pk,
    fog_pars_vertex: mk,
    fog_fragment: gk,
    fog_pars_fragment: vk,
    gradientmap_pars_fragment: yk,
    lightmap_fragment: xk,
    lightmap_pars_fragment: _k,
    lights_lambert_fragment: Ak,
    lights_lambert_pars_fragment: Sk,
    lights_pars_begin: Mk,
    lights_toon_fragment: wk,
    lights_toon_pars_fragment: Tk,
    lights_phong_fragment: Ck,
    lights_phong_pars_fragment: bk,
    lights_physical_fragment: Rk,
    lights_physical_pars_fragment: Pk,
    lights_fragment_begin: Bk,
    lights_fragment_maps: Lk,
    lights_fragment_end: Ik,
    logdepthbuf_fragment: Dk,
    logdepthbuf_pars_fragment: Fk,
    logdepthbuf_pars_vertex: Nk,
    logdepthbuf_vertex: Uk,
    map_fragment: Ok,
    map_pars_fragment: kk,
    map_particle_fragment: Hk,
    map_particle_pars_fragment: zk,
    metalnessmap_fragment: Gk,
    metalnessmap_pars_fragment: Vk,
    morphcolor_vertex: Wk,
    morphnormal_vertex: jk,
    morphtarget_pars_vertex: Xk,
    morphtarget_vertex: Jk,
    normal_fragment_begin: Kk,
    normal_fragment_maps: Yk,
    normal_pars_fragment: Qk,
    normal_pars_vertex: qk,
    normal_vertex: Zk,
    normalmap_pars_fragment: $k,
    clearcoat_normal_fragment_begin: eH,
    clearcoat_normal_fragment_maps: tH,
    clearcoat_pars_fragment: nH,
    iridescence_pars_fragment: iH,
    opaque_fragment: rH,
    packing: sH,
    premultiplied_alpha_fragment: oH,
    project_vertex: aH,
    dithering_fragment: lH,
    dithering_pars_fragment: cH,
    roughnessmap_fragment: uH,
    roughnessmap_pars_fragment: fH,
    shadowmap_pars_fragment: hH,
    shadowmap_pars_vertex: dH,
    shadowmap_vertex: pH,
    shadowmask_pars_fragment: mH,
    skinbase_vertex: gH,
    skinning_pars_vertex: vH,
    skinning_vertex: yH,
    skinnormal_vertex: xH,
    specularmap_fragment: _H,
    specularmap_pars_fragment: AH,
    tonemapping_fragment: SH,
    tonemapping_pars_fragment: MH,
    transmission_fragment: EH,
    transmission_pars_fragment: wH,
    uv_pars_fragment: TH,
    uv_pars_vertex: CH,
    uv_vertex: bH,
    worldpos_vertex: RH,
    background_vert: PH,
    background_frag: BH,
    backgroundCube_vert: LH,
    backgroundCube_frag: IH,
    cube_vert: DH,
    cube_frag: FH,
    depth_vert: NH,
    depth_frag: UH,
    distanceRGBA_vert: OH,
    distanceRGBA_frag: kH,
    equirect_vert: HH,
    equirect_frag: zH,
    linedashed_vert: GH,
    linedashed_frag: VH,
    meshbasic_vert: WH,
    meshbasic_frag: jH,
    meshlambert_vert: XH,
    meshlambert_frag: JH,
    meshmatcap_vert: KH,
    meshmatcap_frag: YH,
    meshnormal_vert: QH,
    meshnormal_frag: qH,
    meshphong_vert: ZH,
    meshphong_frag: $H,
    meshphysical_vert: ez,
    meshphysical_frag: tz,
    meshtoon_vert: nz,
    meshtoon_frag: iz,
    points_vert: rz,
    points_frag: sz,
    shadow_vert: oz,
    shadow_frag: az,
    sprite_vert: lz,
    sprite_frag: cz,
  },
  Ne = {
    common: {
      diffuse: { value: new Ue(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new _t() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new _t() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new _t() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new _t() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new _t() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new _t() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new _t() },
      normalScale: { value: new ve(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new _t() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new _t() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new _t() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new _t() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Ue(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Ue(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new _t() },
      alphaTest: { value: 0 },
      uvTransform: { value: new _t() },
    },
    sprite: {
      diffuse: { value: new Ue(16777215) },
      opacity: { value: 1 },
      center: { value: new ve(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new _t() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new _t() },
      alphaTest: { value: 0 },
    },
  },
  kr = {
    basic: {
      uniforms: pi([
        Ne.common,
        Ne.specularmap,
        Ne.envmap,
        Ne.aomap,
        Ne.lightmap,
        Ne.fog,
      ]),
      vertexShader: yt.meshbasic_vert,
      fragmentShader: yt.meshbasic_frag,
    },
    lambert: {
      uniforms: pi([
        Ne.common,
        Ne.specularmap,
        Ne.envmap,
        Ne.aomap,
        Ne.lightmap,
        Ne.emissivemap,
        Ne.bumpmap,
        Ne.normalmap,
        Ne.displacementmap,
        Ne.fog,
        Ne.lights,
        { emissive: { value: new Ue(0) } },
      ]),
      vertexShader: yt.meshlambert_vert,
      fragmentShader: yt.meshlambert_frag,
    },
    phong: {
      uniforms: pi([
        Ne.common,
        Ne.specularmap,
        Ne.envmap,
        Ne.aomap,
        Ne.lightmap,
        Ne.emissivemap,
        Ne.bumpmap,
        Ne.normalmap,
        Ne.displacementmap,
        Ne.fog,
        Ne.lights,
        {
          emissive: { value: new Ue(0) },
          specular: { value: new Ue(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: yt.meshphong_vert,
      fragmentShader: yt.meshphong_frag,
    },
    standard: {
      uniforms: pi([
        Ne.common,
        Ne.envmap,
        Ne.aomap,
        Ne.lightmap,
        Ne.emissivemap,
        Ne.bumpmap,
        Ne.normalmap,
        Ne.displacementmap,
        Ne.roughnessmap,
        Ne.metalnessmap,
        Ne.fog,
        Ne.lights,
        {
          emissive: { value: new Ue(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: yt.meshphysical_vert,
      fragmentShader: yt.meshphysical_frag,
    },
    toon: {
      uniforms: pi([
        Ne.common,
        Ne.aomap,
        Ne.lightmap,
        Ne.emissivemap,
        Ne.bumpmap,
        Ne.normalmap,
        Ne.displacementmap,
        Ne.gradientmap,
        Ne.fog,
        Ne.lights,
        { emissive: { value: new Ue(0) } },
      ]),
      vertexShader: yt.meshtoon_vert,
      fragmentShader: yt.meshtoon_frag,
    },
    matcap: {
      uniforms: pi([
        Ne.common,
        Ne.bumpmap,
        Ne.normalmap,
        Ne.displacementmap,
        Ne.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: yt.meshmatcap_vert,
      fragmentShader: yt.meshmatcap_frag,
    },
    points: {
      uniforms: pi([Ne.points, Ne.fog]),
      vertexShader: yt.points_vert,
      fragmentShader: yt.points_frag,
    },
    dashed: {
      uniforms: pi([
        Ne.common,
        Ne.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: yt.linedashed_vert,
      fragmentShader: yt.linedashed_frag,
    },
    depth: {
      uniforms: pi([Ne.common, Ne.displacementmap]),
      vertexShader: yt.depth_vert,
      fragmentShader: yt.depth_frag,
    },
    normal: {
      uniforms: pi([
        Ne.common,
        Ne.bumpmap,
        Ne.normalmap,
        Ne.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: yt.meshnormal_vert,
      fragmentShader: yt.meshnormal_frag,
    },
    sprite: {
      uniforms: pi([Ne.sprite, Ne.fog]),
      vertexShader: yt.sprite_vert,
      fragmentShader: yt.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new _t() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: yt.background_vert,
      fragmentShader: yt.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: yt.backgroundCube_vert,
      fragmentShader: yt.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: yt.cube_vert,
      fragmentShader: yt.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: yt.equirect_vert,
      fragmentShader: yt.equirect_frag,
    },
    distanceRGBA: {
      uniforms: pi([
        Ne.common,
        Ne.displacementmap,
        {
          referencePosition: { value: new F() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: yt.distanceRGBA_vert,
      fragmentShader: yt.distanceRGBA_frag,
    },
    shadow: {
      uniforms: pi([
        Ne.lights,
        Ne.fog,
        { color: { value: new Ue(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: yt.shadow_vert,
      fragmentShader: yt.shadow_frag,
    },
  };
kr.physical = {
  uniforms: pi([
    kr.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new _t() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new _t() },
      clearcoatNormalScale: { value: new ve(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new _t() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new _t() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new _t() },
      sheen: { value: 0 },
      sheenColor: { value: new Ue(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new _t() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new _t() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new _t() },
      transmissionSamplerSize: { value: new ve() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new _t() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Ue(0) },
      specularColor: { value: new Ue(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new _t() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new _t() },
      anisotropyVector: { value: new ve() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new _t() },
    },
  ]),
  vertexShader: yt.meshphysical_vert,
  fragmentShader: yt.meshphysical_frag,
};
const Sp = { r: 0, b: 0, g: 0 };
function uz(n, e, t, i, r, s, o) {
  const a = new Ue(0);
  let l = s === !0 ? 0 : 1,
    u,
    h,
    d = null,
    p = 0,
    m = null;
  function y(A, g) {
    let x = !1,
      _ = g.isScene === !0 ? g.background : null;
    switch (
      (_ && _.isTexture && (_ = (g.backgroundBlurriness > 0 ? t : e).get(_)),
      _ === null ? M(a, l) : _ && _.isColor && (M(_, 1), (x = !0)),
      n.xr.getEnvironmentBlendMode())
    ) {
      case "opaque":
        x = !0;
        break;
      case "additive":
        i.buffers.color.setClear(0, 0, 0, 1, o), (x = !0);
        break;
      case "alpha-blend":
        i.buffers.color.setClear(0, 0, 0, 0, o), (x = !0);
        break;
    }
    (n.autoClear || x) &&
      n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
      _ && (_.isCubeTexture || _.mapping === ou)
        ? (h === void 0 &&
            ((h = new Gn(
              new hl(1, 1, 1),
              new As({
                name: "BackgroundCubeMaterial",
                uniforms: Yc(kr.backgroundCube.uniforms),
                vertexShader: kr.backgroundCube.vertexShader,
                fragmentShader: kr.backgroundCube.fragmentShader,
                side: xi,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            h.geometry.deleteAttribute("normal"),
            h.geometry.deleteAttribute("uv"),
            (h.onBeforeRender = function (R, P, B) {
              this.matrixWorld.copyPosition(B.matrixWorld);
            }),
            Object.defineProperty(h.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            r.update(h)),
          (h.material.uniforms.envMap.value = _),
          (h.material.uniforms.flipEnvMap.value =
            _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1),
          (h.material.uniforms.backgroundBlurriness.value =
            g.backgroundBlurriness),
          (h.material.uniforms.backgroundIntensity.value =
            g.backgroundIntensity),
          (h.material.toneMapped = _.colorSpace !== mt),
          (d !== _ || p !== _.version || m !== n.toneMapping) &&
            ((h.material.needsUpdate = !0),
            (d = _),
            (p = _.version),
            (m = n.toneMapping)),
          h.layers.enableAll(),
          A.unshift(h, h.geometry, h.material, 0, 0, null))
        : _ &&
          _.isTexture &&
          (u === void 0 &&
            ((u = new Gn(
              new Ch(2, 2),
              new As({
                name: "BackgroundMaterial",
                uniforms: Yc(kr.background.uniforms),
                vertexShader: kr.background.vertexShader,
                fragmentShader: kr.background.fragmentShader,
                side: xs,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            u.geometry.deleteAttribute("normal"),
            Object.defineProperty(u.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            r.update(u)),
          (u.material.uniforms.t2D.value = _),
          (u.material.uniforms.backgroundIntensity.value =
            g.backgroundIntensity),
          (u.material.toneMapped = _.colorSpace !== mt),
          _.matrixAutoUpdate === !0 && _.updateMatrix(),
          u.material.uniforms.uvTransform.value.copy(_.matrix),
          (d !== _ || p !== _.version || m !== n.toneMapping) &&
            ((u.material.needsUpdate = !0),
            (d = _),
            (p = _.version),
            (m = n.toneMapping)),
          u.layers.enableAll(),
          A.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function M(A, g) {
    A.getRGB(Sp, cB(n)), i.buffers.color.setClear(Sp.r, Sp.g, Sp.b, g, o);
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (A, g = 1) {
      a.set(A), (l = g), M(a, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (A) {
      (l = A), M(a, l);
    },
    render: y,
  };
}
function fz(n, e, t, i) {
  const r = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    o = i.isWebGL2 || s !== null,
    a = {},
    l = A(null);
  let u = l,
    h = !1;
  function d(Y, K, ie, ee, I) {
    let G = !1;
    if (o) {
      const k = M(ee, ie, K);
      u !== k && ((u = k), m(u.object)),
        (G = g(Y, ee, ie, I)),
        G && x(Y, ee, ie, I);
    } else {
      const k = K.wireframe === !0;
      (u.geometry !== ee.id || u.program !== ie.id || u.wireframe !== k) &&
        ((u.geometry = ee.id),
        (u.program = ie.id),
        (u.wireframe = k),
        (G = !0));
    }
    I !== null && t.update(I, n.ELEMENT_ARRAY_BUFFER),
      (G || h) &&
        ((h = !1),
        B(Y, K, ie, ee),
        I !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(I).buffer));
  }
  function p() {
    return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES();
  }
  function m(Y) {
    return i.isWebGL2 ? n.bindVertexArray(Y) : s.bindVertexArrayOES(Y);
  }
  function y(Y) {
    return i.isWebGL2 ? n.deleteVertexArray(Y) : s.deleteVertexArrayOES(Y);
  }
  function M(Y, K, ie) {
    const ee = ie.wireframe === !0;
    let I = a[Y.id];
    I === void 0 && ((I = {}), (a[Y.id] = I));
    let G = I[K.id];
    G === void 0 && ((G = {}), (I[K.id] = G));
    let k = G[ee];
    return k === void 0 && ((k = A(p())), (G[ee] = k)), k;
  }
  function A(Y) {
    const K = [],
      ie = [],
      ee = [];
    for (let I = 0; I < r; I++) (K[I] = 0), (ie[I] = 0), (ee[I] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: K,
      enabledAttributes: ie,
      attributeDivisors: ee,
      object: Y,
      attributes: {},
      index: null,
    };
  }
  function g(Y, K, ie, ee) {
    const I = u.attributes,
      G = K.attributes;
    let k = 0;
    const U = ie.getAttributes();
    for (const j in U)
      if (U[j].location >= 0) {
        const ae = I[j];
        let xe = G[j];
        if (
          (xe === void 0 &&
            (j === "instanceMatrix" &&
              Y.instanceMatrix &&
              (xe = Y.instanceMatrix),
            j === "instanceColor" && Y.instanceColor && (xe = Y.instanceColor)),
          ae === void 0 || ae.attribute !== xe || (xe && ae.data !== xe.data))
        )
          return !0;
        k++;
      }
    return u.attributesNum !== k || u.index !== ee;
  }
  function x(Y, K, ie, ee) {
    const I = {},
      G = K.attributes;
    let k = 0;
    const U = ie.getAttributes();
    for (const j in U)
      if (U[j].location >= 0) {
        let ae = G[j];
        ae === void 0 &&
          (j === "instanceMatrix" &&
            Y.instanceMatrix &&
            (ae = Y.instanceMatrix),
          j === "instanceColor" && Y.instanceColor && (ae = Y.instanceColor));
        const xe = {};
        (xe.attribute = ae),
          ae && ae.data && (xe.data = ae.data),
          (I[j] = xe),
          k++;
      }
    (u.attributes = I), (u.attributesNum = k), (u.index = ee);
  }
  function _() {
    const Y = u.newAttributes;
    for (let K = 0, ie = Y.length; K < ie; K++) Y[K] = 0;
  }
  function E(Y) {
    T(Y, 0);
  }
  function T(Y, K) {
    const ie = u.newAttributes,
      ee = u.enabledAttributes,
      I = u.attributeDivisors;
    (ie[Y] = 1),
      ee[Y] === 0 && (n.enableVertexAttribArray(Y), (ee[Y] = 1)),
      I[Y] !== K &&
        ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[
          i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](Y, K),
        (I[Y] = K));
  }
  function R() {
    const Y = u.newAttributes,
      K = u.enabledAttributes;
    for (let ie = 0, ee = K.length; ie < ee; ie++)
      K[ie] !== Y[ie] && (n.disableVertexAttribArray(ie), (K[ie] = 0));
  }
  function P(Y, K, ie, ee, I, G, k) {
    k === !0
      ? n.vertexAttribIPointer(Y, K, ie, I, G)
      : n.vertexAttribPointer(Y, K, ie, ee, I, G);
  }
  function B(Y, K, ie, ee) {
    if (
      i.isWebGL2 === !1 &&
      (Y.isInstancedMesh || ee.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    _();
    const I = ee.attributes,
      G = ie.getAttributes(),
      k = K.defaultAttributeValues;
    for (const U in G) {
      const j = G[U];
      if (j.location >= 0) {
        let he = I[U];
        if (
          (he === void 0 &&
            (U === "instanceMatrix" &&
              Y.instanceMatrix &&
              (he = Y.instanceMatrix),
            U === "instanceColor" && Y.instanceColor && (he = Y.instanceColor)),
          he !== void 0)
        ) {
          const ae = he.normalized,
            xe = he.itemSize,
            Ae = t.get(he);
          if (Ae === void 0) continue;
          const Le = Ae.buffer,
            Ve = Ae.type,
            ct = Ae.bytesPerElement,
            tt =
              i.isWebGL2 === !0 &&
              (Ve === n.INT || Ve === n.UNSIGNED_INT || he.gpuType === f1);
          if (he.isInterleavedBufferAttribute) {
            const Me = he.data,
              V = Me.stride,
              ye = he.offset;
            if (Me.isInstancedInterleavedBuffer) {
              for (let me = 0; me < j.locationSize; me++)
                T(j.location + me, Me.meshPerAttribute);
              Y.isInstancedMesh !== !0 &&
                ee._maxInstanceCount === void 0 &&
                (ee._maxInstanceCount = Me.meshPerAttribute * Me.count);
            } else
              for (let me = 0; me < j.locationSize; me++) E(j.location + me);
            n.bindBuffer(n.ARRAY_BUFFER, Le);
            for (let me = 0; me < j.locationSize; me++)
              P(
                j.location + me,
                xe / j.locationSize,
                Ve,
                ae,
                V * ct,
                (ye + (xe / j.locationSize) * me) * ct,
                tt
              );
          } else {
            if (he.isInstancedBufferAttribute) {
              for (let Me = 0; Me < j.locationSize; Me++)
                T(j.location + Me, he.meshPerAttribute);
              Y.isInstancedMesh !== !0 &&
                ee._maxInstanceCount === void 0 &&
                (ee._maxInstanceCount = he.meshPerAttribute * he.count);
            } else
              for (let Me = 0; Me < j.locationSize; Me++) E(j.location + Me);
            n.bindBuffer(n.ARRAY_BUFFER, Le);
            for (let Me = 0; Me < j.locationSize; Me++)
              P(
                j.location + Me,
                xe / j.locationSize,
                Ve,
                ae,
                xe * ct,
                (xe / j.locationSize) * Me * ct,
                tt
              );
          }
        } else if (k !== void 0) {
          const ae = k[U];
          if (ae !== void 0)
            switch (ae.length) {
              case 2:
                n.vertexAttrib2fv(j.location, ae);
                break;
              case 3:
                n.vertexAttrib3fv(j.location, ae);
                break;
              case 4:
                n.vertexAttrib4fv(j.location, ae);
                break;
              default:
                n.vertexAttrib1fv(j.location, ae);
            }
        }
      }
    }
    R();
  }
  function b() {
    $();
    for (const Y in a) {
      const K = a[Y];
      for (const ie in K) {
        const ee = K[ie];
        for (const I in ee) y(ee[I].object), delete ee[I];
        delete K[ie];
      }
      delete a[Y];
    }
  }
  function L(Y) {
    if (a[Y.id] === void 0) return;
    const K = a[Y.id];
    for (const ie in K) {
      const ee = K[ie];
      for (const I in ee) y(ee[I].object), delete ee[I];
      delete K[ie];
    }
    delete a[Y.id];
  }
  function z(Y) {
    for (const K in a) {
      const ie = a[K];
      if (ie[Y.id] === void 0) continue;
      const ee = ie[Y.id];
      for (const I in ee) y(ee[I].object), delete ee[I];
      delete ie[Y.id];
    }
  }
  function $() {
    X(), (h = !0), u !== l && ((u = l), m(u.object));
  }
  function X() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: d,
    reset: $,
    resetDefaultState: X,
    dispose: b,
    releaseStatesOfGeometry: L,
    releaseStatesOfProgram: z,
    initAttributes: _,
    enableAttribute: E,
    disableUnusedAttributes: R,
  };
}
function hz(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(u) {
    s = u;
  }
  function a(u, h) {
    n.drawArrays(s, u, h), t.update(h, s, 1);
  }
  function l(u, h, d) {
    if (d === 0) return;
    let p, m;
    if (r) (p = n), (m = "drawArraysInstanced");
    else if (
      ((p = e.get("ANGLE_instanced_arrays")),
      (m = "drawArraysInstancedANGLE"),
      p === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    p[m](s, u, h, d), t.update(h, s, d);
  }
  (this.setMode = o), (this.render = a), (this.renderInstances = l);
}
function dz(n, e, t) {
  let i;
  function r() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const P = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function s(P) {
    if (P === "highp") {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      P = "mediump";
    }
    return P === "mediump" &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  const o =
    typeof WebGL2RenderingContext < "u" &&
    n.constructor.name === "WebGL2RenderingContext";
  let a = t.precision !== void 0 ? t.precision : "highp";
  const l = s(a);
  l !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      l,
      "instead."
    ),
    (a = l));
  const u = o || e.has("WEBGL_draw_buffers"),
    h = t.logarithmicDepthBuffer === !0,
    d = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    p = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    m = n.getParameter(n.MAX_TEXTURE_SIZE),
    y = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    M = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    A = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    g = n.getParameter(n.MAX_VARYING_VECTORS),
    x = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    _ = p > 0,
    E = o || e.has("OES_texture_float"),
    T = _ && E,
    R = o ? n.getParameter(n.MAX_SAMPLES) : 0;
  return {
    isWebGL2: o,
    drawBuffers: u,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: h,
    maxTextures: d,
    maxVertexTextures: p,
    maxTextureSize: m,
    maxCubemapSize: y,
    maxAttributes: M,
    maxVertexUniforms: A,
    maxVaryings: g,
    maxFragmentUniforms: x,
    vertexTextures: _,
    floatFragmentTextures: E,
    floatVertexTextures: T,
    maxSamples: R,
  };
}
function pz(n) {
  const e = this;
  let t = null,
    i = 0,
    r = !1,
    s = !1;
  const o = new Mo(),
    a = new _t(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (d, p) {
      const m = d.length !== 0 || p || i !== 0 || r;
      return (r = p), (i = d.length), m;
    }),
    (this.beginShadows = function () {
      (s = !0), h(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (d, p) {
      t = h(d, p, 0);
    }),
    (this.setState = function (d, p, m) {
      const y = d.clippingPlanes,
        M = d.clipIntersection,
        A = d.clipShadows,
        g = n.get(d);
      if (!r || y === null || y.length === 0 || (s && !A)) s ? h(null) : u();
      else {
        const x = s ? 0 : i,
          _ = x * 4;
        let E = g.clippingState || null;
        (l.value = E), (E = h(y, p, _, m));
        for (let T = 0; T !== _; ++T) E[T] = t[T];
        (g.clippingState = E),
          (this.numIntersection = M ? this.numPlanes : 0),
          (this.numPlanes += x);
      }
    });
  function u() {
    l.value !== t && ((l.value = t), (l.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0);
  }
  function h(d, p, m, y) {
    const M = d !== null ? d.length : 0;
    let A = null;
    if (M !== 0) {
      if (((A = l.value), y !== !0 || A === null)) {
        const g = m + M * 4,
          x = p.matrixWorldInverse;
        a.getNormalMatrix(x),
          (A === null || A.length < g) && (A = new Float32Array(g));
        for (let _ = 0, E = m; _ !== M; ++_, E += 4)
          o.copy(d[_]).applyMatrix4(x, a),
            o.normal.toArray(A, E),
            (A[E + 3] = o.constant);
      }
      (l.value = A), (l.needsUpdate = !0);
    }
    return (e.numPlanes = M), (e.numIntersection = 0), A;
  }
}
function mz(n) {
  let e = new WeakMap();
  function t(o, a) {
    return a === qf ? (o.mapping = Jo) : a === Zf && (o.mapping = Ko), o;
  }
  function i(o) {
    if (o && o.isTexture && o.isRenderTargetTexture === !1) {
      const a = o.mapping;
      if (a === qf || a === Zf)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const u = new C1(l.height / 2);
            return (
              u.fromEquirectangularTexture(n, o),
              e.set(o, u),
              o.addEventListener("dispose", r),
              t(u.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function r(o) {
    const a = o.target;
    a.removeEventListener("dispose", r);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: i, dispose: s };
}
class Wr extends wh {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = r),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, i, r, s, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let s = i - e,
      o = i + e,
      a = r + t,
      l = r - t;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom,
        h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += u * this.view.offsetX),
        (o = s + u * this.view.width),
        (a -= h * this.view.offsetY),
        (l = a - h * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      o,
      a,
      l,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const yc = 4,
  Hw = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Na = 20,
  my = new Wr(),
  zw = new Ue();
let gy = null;
const La = (1 + Math.sqrt(5)) / 2,
  Kl = 1 / La,
  Gw = [
    new F(1, 1, 1),
    new F(-1, 1, 1),
    new F(1, 1, -1),
    new F(-1, 1, -1),
    new F(0, La, Kl),
    new F(0, La, -Kl),
    new F(Kl, 0, La),
    new F(-Kl, 0, La),
    new F(La, Kl, 0),
    new F(-La, Kl, 0),
  ];
class D_ {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    (gy = this._renderer.getRenderTarget()), this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, i, r, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = jw()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = Ww()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(gy),
      (e.scissorTest = !1),
      Mp(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Jo || e.mapping === Ko
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (gy = this._renderer.getRenderTarget());
    const i = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: sn,
        minFilter: sn,
        generateMipmaps: !1,
        type: Xc,
        format: bi,
        colorSpace: Xr,
        depthBuffer: !1,
      },
      r = Vw(e, t, i);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = Vw(e, t, i));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = gz(s)),
        (this._blurMaterial = vz(s, e, t));
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new Gn(this._lodPlanes[0], e);
    this._renderer.compile(t, my);
  }
  _sceneToCubeUV(e, t, i, r) {
    const a = new $t(90, 1, t, i),
      l = [1, -1, 1, 1, 1, 1],
      u = [1, 1, 1, -1, -1, -1],
      h = this._renderer,
      d = h.autoClear,
      p = h.toneMapping;
    h.getClearColor(zw), (h.toneMapping = Vr), (h.autoClear = !1);
    const m = new Ji({
        name: "PMREM.Background",
        side: xi,
        depthWrite: !1,
        depthTest: !1,
      }),
      y = new Gn(new hl(), m);
    let M = !1;
    const A = e.background;
    A
      ? A.isColor && (m.color.copy(A), (e.background = null), (M = !0))
      : (m.color.copy(zw), (M = !0));
    for (let g = 0; g < 6; g++) {
      const x = g % 3;
      x === 0
        ? (a.up.set(0, l[g], 0), a.lookAt(u[g], 0, 0))
        : x === 1
        ? (a.up.set(0, 0, l[g]), a.lookAt(0, u[g], 0))
        : (a.up.set(0, l[g], 0), a.lookAt(0, 0, u[g]));
      const _ = this._cubeSize;
      Mp(r, x * _, g > 2 ? _ : 0, _, _),
        h.setRenderTarget(r),
        M && h.render(y, a),
        h.render(e, a);
    }
    y.geometry.dispose(),
      y.material.dispose(),
      (h.toneMapping = p),
      (h.autoClear = d),
      (e.background = A);
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      r = e.mapping === Jo || e.mapping === Ko;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = jw()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = Ww());
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      o = new Gn(this._lodPlanes[0], s),
      a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    Mp(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, my);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear;
    t.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(
          this._sigmas[r] * this._sigmas[r] -
            this._sigmas[r - 1] * this._sigmas[r - 1]
        ),
        o = Gw[(r - 1) % Gw.length];
      this._blur(e, r - 1, r, s, o);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, i, r, "latitudinal", s),
      this._halfBlur(o, e, i, i, r, "longitudinal", s);
  }
  _halfBlur(e, t, i, r, s, o, a) {
    const l = this._renderer,
      u = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const h = 3,
      d = new Gn(this._lodPlanes[r], u),
      p = u.uniforms,
      m = this._sizeLods[i] - 1,
      y = isFinite(s) ? Math.PI / (2 * m) : (2 * Math.PI) / (2 * Na - 1),
      M = s / y,
      A = isFinite(s) ? 1 + Math.floor(h * M) : Na;
    A > Na &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${A} samples when the maximum is set to ${Na}`
      );
    const g = [];
    let x = 0;
    for (let P = 0; P < Na; ++P) {
      const B = P / M,
        b = Math.exp((-B * B) / 2);
      g.push(b), P === 0 ? (x += b) : P < A && (x += 2 * b);
    }
    for (let P = 0; P < g.length; P++) g[P] = g[P] / x;
    (p.envMap.value = e.texture),
      (p.samples.value = A),
      (p.weights.value = g),
      (p.latitudinal.value = o === "latitudinal"),
      a && (p.poleAxis.value = a);
    const { _lodMax: _ } = this;
    (p.dTheta.value = y), (p.mipInt.value = _ - i);
    const E = this._sizeLods[r],
      T = 3 * E * (r > _ - yc ? r - _ + yc : 0),
      R = 4 * (this._cubeSize - E);
    Mp(t, T, R, 3 * E, 2 * E), l.setRenderTarget(t), l.render(d, my);
  }
}
function gz(n) {
  const e = [],
    t = [],
    i = [];
  let r = n;
  const s = n - yc + 1 + Hw.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r);
    t.push(a);
    let l = 1 / a;
    o > n - yc ? (l = Hw[o - n + yc - 1]) : o === 0 && (l = 0), i.push(l);
    const u = 1 / (a - 2),
      h = -u,
      d = 1 + u,
      p = [h, h, d, h, d, d, h, h, d, d, h, d],
      m = 6,
      y = 6,
      M = 3,
      A = 2,
      g = 1,
      x = new Float32Array(M * y * m),
      _ = new Float32Array(A * y * m),
      E = new Float32Array(g * y * m);
    for (let R = 0; R < m; R++) {
      const P = ((R % 3) * 2) / 3 - 1,
        B = R > 2 ? 0 : -1,
        b = [
          P,
          B,
          0,
          P + 2 / 3,
          B,
          0,
          P + 2 / 3,
          B + 1,
          0,
          P,
          B,
          0,
          P + 2 / 3,
          B + 1,
          0,
          P,
          B + 1,
          0,
        ];
      x.set(b, M * y * R), _.set(p, A * y * R);
      const L = [R, R, R, R, R, R];
      E.set(L, g * y * R);
    }
    const T = new gt();
    T.setAttribute("position", new Ft(x, M)),
      T.setAttribute("uv", new Ft(_, A)),
      T.setAttribute("faceIndex", new Ft(E, g)),
      e.push(T),
      r > yc && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function Vw(n, e, t) {
  const i = new Jr(n, e, t);
  return (
    (i.texture.mapping = ou),
    (i.texture.name = "PMREM.cubeUv"),
    (i.scissorTest = !0),
    i
  );
}
function Mp(n, e, t, i, r) {
  n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
}
function vz(n, e, t) {
  const i = new Float32Array(Na),
    r = new F(0, 1, 0);
  return new As({
    name: "SphericalGaussianBlur",
    defines: {
      n: Na,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: b1(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Xs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Ww() {
  return new As({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: b1(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Xs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function jw() {
  return new As({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: b1(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Xs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function b1() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function yz(n) {
  let e = new WeakMap(),
    t = null;
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        u = l === qf || l === Zf,
        h = l === Jo || l === Ko;
      if (u || h)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let d = e.get(a);
          return (
            t === null && (t = new D_(n)),
            (d = u ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d)),
            e.set(a, d),
            d.texture
          );
        } else {
          if (e.has(a)) return e.get(a).texture;
          {
            const d = a.image;
            if ((u && d && d.height > 0) || (h && d && r(d))) {
              t === null && (t = new D_(n));
              const p = u ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return e.set(a, p), a.addEventListener("dispose", s), p.texture;
            } else return null;
          }
        }
    }
    return a;
  }
  function r(a) {
    let l = 0;
    const u = 6;
    for (let h = 0; h < u; h++) a[h] !== void 0 && l++;
    return l === u;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const u = e.get(l);
    u !== void 0 && (e.delete(l), u.dispose());
  }
  function o() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: i, dispose: o };
}
function xz(n) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0) return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n.getExtension(i);
    }
    return (e[i] = r), r;
  }
  return {
    has: function (i) {
      return t(i) !== null;
    },
    init: function (i) {
      i.isWebGL2
        ? t("EXT_color_buffer_float")
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture");
    },
    get: function (i) {
      const r = t(i);
      return (
        r === null &&
          console.warn(
            "THREE.WebGLRenderer: " + i + " extension not supported."
          ),
        r
      );
    },
  };
}
function _z(n, e, t, i) {
  const r = {},
    s = new WeakMap();
  function o(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const y in p.attributes) e.remove(p.attributes[y]);
    for (const y in p.morphAttributes) {
      const M = p.morphAttributes[y];
      for (let A = 0, g = M.length; A < g; A++) e.remove(M[A]);
    }
    p.removeEventListener("dispose", o), delete r[p.id];
    const m = s.get(p);
    m && (e.remove(m), s.delete(p)),
      i.releaseStatesOfGeometry(p),
      p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(d, p) {
    return (
      r[p.id] === !0 ||
        (p.addEventListener("dispose", o),
        (r[p.id] = !0),
        t.memory.geometries++),
      p
    );
  }
  function l(d) {
    const p = d.attributes;
    for (const y in p) e.update(p[y], n.ARRAY_BUFFER);
    const m = d.morphAttributes;
    for (const y in m) {
      const M = m[y];
      for (let A = 0, g = M.length; A < g; A++) e.update(M[A], n.ARRAY_BUFFER);
    }
  }
  function u(d) {
    const p = [],
      m = d.index,
      y = d.attributes.position;
    let M = 0;
    if (m !== null) {
      const x = m.array;
      M = m.version;
      for (let _ = 0, E = x.length; _ < E; _ += 3) {
        const T = x[_ + 0],
          R = x[_ + 1],
          P = x[_ + 2];
        p.push(T, R, R, P, P, T);
      }
    } else {
      const x = y.array;
      M = y.version;
      for (let _ = 0, E = x.length / 3 - 1; _ < E; _ += 3) {
        const T = _ + 0,
          R = _ + 1,
          P = _ + 2;
        p.push(T, R, R, P, P, T);
      }
    }
    const A = new (aB(p) ? w1 : E1)(p, 1);
    A.version = M;
    const g = s.get(d);
    g && e.remove(g), s.set(d, A);
  }
  function h(d) {
    const p = s.get(d);
    if (p) {
      const m = d.index;
      m !== null && p.version < m.version && u(d);
    } else u(d);
    return s.get(d);
  }
  return { get: a, update: l, getWireframeAttribute: h };
}
function Az(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(p) {
    s = p;
  }
  let a, l;
  function u(p) {
    (a = p.type), (l = p.bytesPerElement);
  }
  function h(p, m) {
    n.drawElements(s, m, a, p * l), t.update(m, s, 1);
  }
  function d(p, m, y) {
    if (y === 0) return;
    let M, A;
    if (r) (M = n), (A = "drawElementsInstanced");
    else if (
      ((M = e.get("ANGLE_instanced_arrays")),
      (A = "drawElementsInstancedANGLE"),
      M === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    M[A](s, m, a, p * l, y), t.update(m, s, y);
  }
  (this.setMode = o),
    (this.setIndex = u),
    (this.render = h),
    (this.renderInstances = d);
}
function Sz(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(s, o, a) {
    switch ((t.calls++, o)) {
      case n.TRIANGLES:
        t.triangles += a * (s / 3);
        break;
      case n.LINES:
        t.lines += a * (s / 2);
        break;
      case n.LINE_STRIP:
        t.lines += a * (s - 1);
        break;
      case n.LINE_LOOP:
        t.lines += a * s;
        break;
      case n.POINTS:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  };
}
function Mz(n, e) {
  return n[0] - e[0];
}
function Ez(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1]);
}
function wz(n, e, t) {
  const i = {},
    r = new Float32Array(8),
    s = new WeakMap(),
    o = new Ut(),
    a = [];
  for (let u = 0; u < 8; u++) a[u] = [u, 0];
  function l(u, h, d) {
    const p = u.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const y =
          h.morphAttributes.position ||
          h.morphAttributes.normal ||
          h.morphAttributes.color,
        M = y !== void 0 ? y.length : 0;
      let A = s.get(h);
      if (A === void 0 || A.count !== M) {
        let K = function () {
          X.dispose(), s.delete(h), h.removeEventListener("dispose", K);
        };
        var m = K;
        A !== void 0 && A.texture.dispose();
        const _ = h.morphAttributes.position !== void 0,
          E = h.morphAttributes.normal !== void 0,
          T = h.morphAttributes.color !== void 0,
          R = h.morphAttributes.position || [],
          P = h.morphAttributes.normal || [],
          B = h.morphAttributes.color || [];
        let b = 0;
        _ === !0 && (b = 1), E === !0 && (b = 2), T === !0 && (b = 3);
        let L = h.attributes.position.count * b,
          z = 1;
        L > e.maxTextureSize &&
          ((z = Math.ceil(L / e.maxTextureSize)), (L = e.maxTextureSize));
        const $ = new Float32Array(L * z * 4 * M),
          X = new Ug($, L, z, M);
        (X.type = fs), (X.needsUpdate = !0);
        const Y = b * 4;
        for (let ie = 0; ie < M; ie++) {
          const ee = R[ie],
            I = P[ie],
            G = B[ie],
            k = L * z * 4 * ie;
          for (let U = 0; U < ee.count; U++) {
            const j = U * Y;
            _ === !0 &&
              (o.fromBufferAttribute(ee, U),
              ($[k + j + 0] = o.x),
              ($[k + j + 1] = o.y),
              ($[k + j + 2] = o.z),
              ($[k + j + 3] = 0)),
              E === !0 &&
                (o.fromBufferAttribute(I, U),
                ($[k + j + 4] = o.x),
                ($[k + j + 5] = o.y),
                ($[k + j + 6] = o.z),
                ($[k + j + 7] = 0)),
              T === !0 &&
                (o.fromBufferAttribute(G, U),
                ($[k + j + 8] = o.x),
                ($[k + j + 9] = o.y),
                ($[k + j + 10] = o.z),
                ($[k + j + 11] = G.itemSize === 4 ? o.w : 1));
          }
        }
        (A = { count: M, texture: X, size: new ve(L, z) }),
          s.set(h, A),
          h.addEventListener("dispose", K);
      }
      let g = 0;
      for (let _ = 0; _ < p.length; _++) g += p[_];
      const x = h.morphTargetsRelative ? 1 : 1 - g;
      d.getUniforms().setValue(n, "morphTargetBaseInfluence", x),
        d.getUniforms().setValue(n, "morphTargetInfluences", p),
        d.getUniforms().setValue(n, "morphTargetsTexture", A.texture, t),
        d.getUniforms().setValue(n, "morphTargetsTextureSize", A.size);
    } else {
      const y = p === void 0 ? 0 : p.length;
      let M = i[h.id];
      if (M === void 0 || M.length !== y) {
        M = [];
        for (let E = 0; E < y; E++) M[E] = [E, 0];
        i[h.id] = M;
      }
      for (let E = 0; E < y; E++) {
        const T = M[E];
        (T[0] = E), (T[1] = p[E]);
      }
      M.sort(Ez);
      for (let E = 0; E < 8; E++)
        E < y && M[E][1]
          ? ((a[E][0] = M[E][0]), (a[E][1] = M[E][1]))
          : ((a[E][0] = Number.MAX_SAFE_INTEGER), (a[E][1] = 0));
      a.sort(Mz);
      const A = h.morphAttributes.position,
        g = h.morphAttributes.normal;
      let x = 0;
      for (let E = 0; E < 8; E++) {
        const T = a[E],
          R = T[0],
          P = T[1];
        R !== Number.MAX_SAFE_INTEGER && P
          ? (A &&
              h.getAttribute("morphTarget" + E) !== A[R] &&
              h.setAttribute("morphTarget" + E, A[R]),
            g &&
              h.getAttribute("morphNormal" + E) !== g[R] &&
              h.setAttribute("morphNormal" + E, g[R]),
            (r[E] = P),
            (x += P))
          : (A &&
              h.hasAttribute("morphTarget" + E) === !0 &&
              h.deleteAttribute("morphTarget" + E),
            g &&
              h.hasAttribute("morphNormal" + E) === !0 &&
              h.deleteAttribute("morphNormal" + E),
            (r[E] = 0));
      }
      const _ = h.morphTargetsRelative ? 1 : 1 - x;
      d.getUniforms().setValue(n, "morphTargetBaseInfluence", _),
        d.getUniforms().setValue(n, "morphTargetInfluences", r);
    }
  }
  return { update: l };
}
function Tz(n, e, t, i) {
  let r = new WeakMap();
  function s(l) {
    const u = i.render.frame,
      h = l.geometry,
      d = e.get(l, h);
    if (
      (r.get(d) !== u && (e.update(d), r.set(d, u)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", a) === !1 &&
          l.addEventListener("dispose", a),
        r.get(l) !== u &&
          (t.update(l.instanceMatrix, n.ARRAY_BUFFER),
          l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER),
          r.set(l, u))),
      l.isSkinnedMesh)
    ) {
      const p = l.skeleton;
      r.get(p) !== u && (p.update(), r.set(p, u));
    }
    return d;
  }
  function o() {
    r = new WeakMap();
  }
  function a(l) {
    const u = l.target;
    u.removeEventListener("dispose", a),
      t.remove(u.instanceMatrix),
      u.instanceColor !== null && t.remove(u.instanceColor);
  }
  return { update: s, dispose: o };
}
const hB = new en(),
  dB = new Ug(),
  pB = new M1(),
  mB = new Th(),
  Xw = [],
  Jw = [],
  Kw = new Float32Array(16),
  Yw = new Float32Array(9),
  Qw = new Float32Array(4);
function lu(n, e, t) {
  const i = n[0];
  if (i <= 0 || i > 0) return n;
  const r = e * t;
  let s = Xw[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (Xw[r] = s)), e !== 0)) {
    i.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += t), n[o].toArray(s, a);
  }
  return s;
}
function Dn(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function Fn(n, e) {
  for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
}
function kg(n, e) {
  let t = Jw[e];
  t === void 0 && ((t = new Int32Array(e)), (Jw[e] = t));
  for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
  return t;
}
function Cz(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function bz(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Dn(t, e)) return;
    n.uniform2fv(this.addr, e), Fn(t, e);
  }
}
function Rz(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Dn(t, e)) return;
    n.uniform3fv(this.addr, e), Fn(t, e);
  }
}
function Pz(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Dn(t, e)) return;
    n.uniform4fv(this.addr, e), Fn(t, e);
  }
}
function Bz(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Dn(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), Fn(t, e);
  } else {
    if (Dn(t, i)) return;
    Qw.set(i), n.uniformMatrix2fv(this.addr, !1, Qw), Fn(t, i);
  }
}
function Lz(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Dn(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), Fn(t, e);
  } else {
    if (Dn(t, i)) return;
    Yw.set(i), n.uniformMatrix3fv(this.addr, !1, Yw), Fn(t, i);
  }
}
function Iz(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Dn(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), Fn(t, e);
  } else {
    if (Dn(t, i)) return;
    Kw.set(i), n.uniformMatrix4fv(this.addr, !1, Kw), Fn(t, i);
  }
}
function Dz(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function Fz(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Dn(t, e)) return;
    n.uniform2iv(this.addr, e), Fn(t, e);
  }
}
function Nz(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Dn(t, e)) return;
    n.uniform3iv(this.addr, e), Fn(t, e);
  }
}
function Uz(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Dn(t, e)) return;
    n.uniform4iv(this.addr, e), Fn(t, e);
  }
}
function Oz(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function kz(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Dn(t, e)) return;
    n.uniform2uiv(this.addr, e), Fn(t, e);
  }
}
function Hz(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Dn(t, e)) return;
    n.uniform3uiv(this.addr, e), Fn(t, e);
  }
}
function zz(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Dn(t, e)) return;
    n.uniform4uiv(this.addr, e), Fn(t, e);
  }
}
function Gz(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2D(e || hB, r);
}
function Vz(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture3D(e || pB, r);
}
function Wz(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTextureCube(e || mB, r);
}
function jz(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2DArray(e || dB, r);
}
function Xz(n) {
  switch (n) {
    case 5126:
      return Cz;
    case 35664:
      return bz;
    case 35665:
      return Rz;
    case 35666:
      return Pz;
    case 35674:
      return Bz;
    case 35675:
      return Lz;
    case 35676:
      return Iz;
    case 5124:
    case 35670:
      return Dz;
    case 35667:
    case 35671:
      return Fz;
    case 35668:
    case 35672:
      return Nz;
    case 35669:
    case 35673:
      return Uz;
    case 5125:
      return Oz;
    case 36294:
      return kz;
    case 36295:
      return Hz;
    case 36296:
      return zz;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Gz;
    case 35679:
    case 36299:
    case 36307:
      return Vz;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Wz;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return jz;
  }
}
function Jz(n, e) {
  n.uniform1fv(this.addr, e);
}
function Kz(n, e) {
  const t = lu(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function Yz(n, e) {
  const t = lu(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function Qz(n, e) {
  const t = lu(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function qz(n, e) {
  const t = lu(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function Zz(n, e) {
  const t = lu(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function $z(n, e) {
  const t = lu(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function eG(n, e) {
  n.uniform1iv(this.addr, e);
}
function tG(n, e) {
  n.uniform2iv(this.addr, e);
}
function nG(n, e) {
  n.uniform3iv(this.addr, e);
}
function iG(n, e) {
  n.uniform4iv(this.addr, e);
}
function rG(n, e) {
  n.uniform1uiv(this.addr, e);
}
function sG(n, e) {
  n.uniform2uiv(this.addr, e);
}
function oG(n, e) {
  n.uniform3uiv(this.addr, e);
}
function aG(n, e) {
  n.uniform4uiv(this.addr, e);
}
function lG(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = kg(t, r);
  Dn(i, s) || (n.uniform1iv(this.addr, s), Fn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || hB, s[o]);
}
function cG(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = kg(t, r);
  Dn(i, s) || (n.uniform1iv(this.addr, s), Fn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || pB, s[o]);
}
function uG(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = kg(t, r);
  Dn(i, s) || (n.uniform1iv(this.addr, s), Fn(i, s));
  for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || mB, s[o]);
}
function fG(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = kg(t, r);
  Dn(i, s) || (n.uniform1iv(this.addr, s), Fn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || dB, s[o]);
}
function hG(n) {
  switch (n) {
    case 5126:
      return Jz;
    case 35664:
      return Kz;
    case 35665:
      return Yz;
    case 35666:
      return Qz;
    case 35674:
      return qz;
    case 35675:
      return Zz;
    case 35676:
      return $z;
    case 5124:
    case 35670:
      return eG;
    case 35667:
    case 35671:
      return tG;
    case 35668:
    case 35672:
      return nG;
    case 35669:
    case 35673:
      return iG;
    case 5125:
      return rG;
    case 36294:
      return sG;
    case 36295:
      return oG;
    case 36296:
      return aG;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return lG;
    case 35679:
    case 36299:
    case 36307:
      return cG;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return uG;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return fG;
  }
}
class dG {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.setValue = Xz(t.type));
  }
}
class pG {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = hG(t.type));
  }
}
class mG {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s];
      a.setValue(e, t[a.id], i);
    }
  }
}
const vy = /(\w+)(\])?(\[|\.)?/g;
function qw(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function gG(n, e, t) {
  const i = n.name,
    r = i.length;
  for (vy.lastIndex = 0; ; ) {
    const s = vy.exec(i),
      o = vy.lastIndex;
    let a = s[1];
    const l = s[2] === "]",
      u = s[3];
    if ((l && (a = a | 0), u === void 0 || (u === "[" && o + 2 === r))) {
      qw(t, u === void 0 ? new dG(a, n, e) : new pG(a, n, e));
      break;
    } else {
      let d = t.map[a];
      d === void 0 && ((d = new mG(a)), qw(t, d)), (t = d);
    }
  }
}
class xm {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r),
        o = e.getUniformLocation(t, s.name);
      gG(s, o, this);
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s],
        l = i[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in t && i.push(o);
    }
    return i;
  }
}
function Zw(n, e, t) {
  const i = n.createShader(e);
  return n.shaderSource(i, t), n.compileShader(i), i;
}
let vG = 0;
function yG(n, e) {
  const t = n.split(`
`),
    i = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let o = r; o < s; o++) {
    const a = o + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return i.join(`
`);
}
function xG(n) {
  switch (n) {
    case Xr:
      return ["Linear", "( value )"];
    case mt:
      return ["sRGB", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        ["Linear", "( value )"]
      );
  }
}
function $w(n, e, t) {
  const i = n.getShaderParameter(e, n.COMPILE_STATUS),
    r = n.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const o = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      r +
      `

` +
      yG(n.getShaderSource(e), o)
    );
  } else return r;
}
function _G(n, e) {
  const t = xG(e);
  return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function AG(n, e) {
  let t;
  switch (e) {
    case P2:
      t = "Linear";
      break;
    case B2:
      t = "Reinhard";
      break;
    case L2:
      t = "OptimizedCineon";
      break;
    case u1:
      t = "ACESFilmic";
      break;
    case I2:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function SG(n) {
  return [
    n.extensionDerivatives ||
    n.envMapCubeUVHeight ||
    n.bumpMap ||
    n.normalMapTangentSpace ||
    n.clearcoatNormalMap ||
    n.flatShading ||
    n.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) &&
    n.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
    n.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(hf).join(`
`);
}
function MG(n) {
  const e = [];
  for (const t in n) {
    const i = n[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function EG(n, e) {
  const t = {},
    i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(e, r),
      o = s.name;
    let a = 1;
    s.type === n.FLOAT_MAT2 && (a = 2),
      s.type === n.FLOAT_MAT3 && (a = 3),
      s.type === n.FLOAT_MAT4 && (a = 4),
      (t[o] = {
        type: s.type,
        location: n.getAttribLocation(e, o),
        locationSize: a,
      });
  }
  return t;
}
function hf(n) {
  return n !== "";
}
function eT(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function tT(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const wG = /^[ \t]*#include +<([\w\d./]+)>/gm;
function F_(n) {
  return n.replace(wG, CG);
}
const TG = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"],
]);
function CG(n, e) {
  let t = yt[e];
  if (t === void 0) {
    const i = TG.get(e);
    if (i !== void 0)
      (t = yt[i]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          i
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return F_(t);
}
const bG =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function nT(n) {
  return n.replace(bG, RG);
}
function RG(n, e, t, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function iT(n) {
  let e =
    "precision " +
    n.precision +
    ` float;
precision ` +
    n.precision +
    " int;";
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function PG(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === Lg
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === Mf
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === Nr && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function BG(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case Jo:
      case Ko:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case ou:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function LG(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case Ko:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function IG(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case Mh:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case b2:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case R2:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function DG(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    i = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: i,
    maxMip: t,
  };
}
function FG(n, e, t, i) {
  const r = n.getContext(),
    s = t.defines;
  let o = t.vertexShader,
    a = t.fragmentShader;
  const l = PG(t),
    u = BG(t),
    h = LG(t),
    d = IG(t),
    p = DG(t),
    m = t.isWebGL2 ? "" : SG(t),
    y = MG(s),
    M = r.createProgram();
  let A,
    g,
    x = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((A = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        y,
      ].filter(hf).join(`
`)),
      A.length > 0 &&
        (A += `
`),
      (g = [
        m,
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        y,
      ].filter(hf).join(`
`)),
      g.length > 0 &&
        (g += `
`))
    : ((A = [
        iT(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        y,
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + h : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(hf).join(`
`)),
      (g = [
        m,
        iT(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        y,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + h : "",
        t.envMap ? "#define " + d : "",
        p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
        p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
        p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Vr ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Vr ? yt.tonemapping_pars_fragment : "",
        t.toneMapping !== Vr ? AG("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        yt.colorspace_pars_fragment,
        _G("linearToOutputTexel", t.outputColorSpace),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(hf).join(`
`))),
    (o = F_(o)),
    (o = eT(o, t)),
    (o = tT(o, t)),
    (a = F_(a)),
    (a = eT(a, t)),
    (a = tT(a, t)),
    (o = nT(o)),
    (a = nT(a)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((x = `#version 300 es
`),
      (A =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        A),
      (g =
        [
          "#define varying in",
          t.glslVersion === L_
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === L_ ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        g));
  const _ = x + A + o,
    E = x + g + a,
    T = Zw(r, r.VERTEX_SHADER, _),
    R = Zw(r, r.FRAGMENT_SHADER, E);
  if (
    (r.attachShader(M, T),
    r.attachShader(M, R),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(M, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(M, 0, "position"),
    r.linkProgram(M),
    n.debug.checkShaderErrors)
  ) {
    const b = r.getProgramInfoLog(M).trim(),
      L = r.getShaderInfoLog(T).trim(),
      z = r.getShaderInfoLog(R).trim();
    let $ = !0,
      X = !0;
    if (r.getProgramParameter(M, r.LINK_STATUS) === !1)
      if ((($ = !1), typeof n.debug.onShaderError == "function"))
        n.debug.onShaderError(r, M, T, R);
      else {
        const Y = $w(r, T, "vertex"),
          K = $w(r, R, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " +
            r.getError() +
            " - VALIDATE_STATUS " +
            r.getProgramParameter(M, r.VALIDATE_STATUS) +
            `

Program Info Log: ` +
            b +
            `
` +
            Y +
            `
` +
            K
        );
      }
    else
      b !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", b)
        : (L === "" || z === "") && (X = !1);
    X &&
      (this.diagnostics = {
        runnable: $,
        programLog: b,
        vertexShader: { log: L, prefix: A },
        fragmentShader: { log: z, prefix: g },
      });
  }
  r.deleteShader(T), r.deleteShader(R);
  let P;
  this.getUniforms = function () {
    return P === void 0 && (P = new xm(r, M)), P;
  };
  let B;
  return (
    (this.getAttributes = function () {
      return B === void 0 && (B = EG(r, M)), B;
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        r.deleteProgram(M),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = vG++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = M),
    (this.vertexShader = T),
    (this.fragmentShader = R),
    this
  );
}
let NG = 0;
class UG {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(t),
      s = this._getShaderStage(i),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && ((i = new Set()), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && ((i = new OG(e)), t.set(e, i)), i;
  }
}
class OG {
  constructor(e) {
    (this.id = NG++), (this.code = e), (this.usedTimes = 0);
  }
}
function kG(n, e, t, i, r, s, o) {
  const a = new Za(),
    l = new UG(),
    u = [],
    h = r.isWebGL2,
    d = r.logarithmicDepthBuffer,
    p = r.vertexTextures;
  let m = r.precision;
  const y = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function M(b) {
    return b === 0 ? "uv" : `uv${b}`;
  }
  function A(b, L, z, $, X) {
    const Y = $.fog,
      K = X.geometry,
      ie = b.isMeshStandardMaterial ? $.environment : null,
      ee = (b.isMeshStandardMaterial ? t : e).get(b.envMap || ie),
      I = ee && ee.mapping === ou ? ee.image.height : null,
      G = y[b.type];
    b.precision !== null &&
      ((m = r.getMaxPrecision(b.precision)),
      m !== b.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          b.precision,
          "not supported, using",
          m,
          "instead."
        ));
    const k =
        K.morphAttributes.position ||
        K.morphAttributes.normal ||
        K.morphAttributes.color,
      U = k !== void 0 ? k.length : 0;
    let j = 0;
    K.morphAttributes.position !== void 0 && (j = 1),
      K.morphAttributes.normal !== void 0 && (j = 2),
      K.morphAttributes.color !== void 0 && (j = 3);
    let he, ae, xe, Ae;
    if (G) {
      const Di = kr[G];
      (he = Di.vertexShader), (ae = Di.fragmentShader);
    } else
      (he = b.vertexShader),
        (ae = b.fragmentShader),
        l.update(b),
        (xe = l.getVertexShaderID(b)),
        (Ae = l.getFragmentShaderID(b));
    const Le = n.getRenderTarget(),
      Ve = X.isInstancedMesh === !0,
      ct = !!b.map,
      tt = !!b.matcap,
      Me = !!ee,
      V = !!b.aoMap,
      ye = !!b.lightMap,
      me = !!b.bumpMap,
      Ee = !!b.normalMap,
      _e = !!b.displacementMap,
      We = !!b.emissiveMap,
      Oe = !!b.metalnessMap,
      Ge = !!b.roughnessMap,
      Ze = b.anisotropy > 0,
      vt = b.clearcoat > 0,
      kt = b.iridescence > 0,
      H = b.sheen > 0,
      D = b.transmission > 0,
      ce = Ze && !!b.anisotropyMap,
      we = vt && !!b.clearcoatMap,
      Se = vt && !!b.clearcoatNormalMap,
      Fe = vt && !!b.clearcoatRoughnessMap,
      Ke = kt && !!b.iridescenceMap,
      Ie = kt && !!b.iridescenceThicknessMap,
      de = H && !!b.sheenColorMap,
      J = H && !!b.sheenRoughnessMap,
      fe = !!b.specularMap,
      Te = !!b.specularColorMap,
      be = !!b.specularIntensityMap,
      De = D && !!b.transmissionMap,
      nt = D && !!b.thicknessMap,
      Pt = !!b.gradientMap,
      Q = !!b.alphaMap,
      Pe = b.alphaTest > 0,
      oe = !!b.alphaHash,
      Be = !!b.extensions,
      He = !!K.attributes.uv1,
      Tt = !!K.attributes.uv2,
      Vt = !!K.attributes.uv3;
    return {
      isWebGL2: h,
      shaderID: G,
      shaderType: b.type,
      shaderName: b.name,
      vertexShader: he,
      fragmentShader: ae,
      defines: b.defines,
      customVertexShaderID: xe,
      customFragmentShaderID: Ae,
      isRawShaderMaterial: b.isRawShaderMaterial === !0,
      glslVersion: b.glslVersion,
      precision: m,
      instancing: Ve,
      instancingColor: Ve && X.instanceColor !== null,
      supportsVertexTextures: p,
      outputColorSpace:
        Le === null
          ? n.outputColorSpace
          : Le.isXRRenderTarget === !0
          ? Le.texture.colorSpace
          : Xr,
      map: ct,
      matcap: tt,
      envMap: Me,
      envMapMode: Me && ee.mapping,
      envMapCubeUVHeight: I,
      aoMap: V,
      lightMap: ye,
      bumpMap: me,
      normalMap: Ee,
      displacementMap: p && _e,
      emissiveMap: We,
      normalMapObjectSpace: Ee && b.normalMapType === Y2,
      normalMapTangentSpace: Ee && b.normalMapType === ia,
      metalnessMap: Oe,
      roughnessMap: Ge,
      anisotropy: Ze,
      anisotropyMap: ce,
      clearcoat: vt,
      clearcoatMap: we,
      clearcoatNormalMap: Se,
      clearcoatRoughnessMap: Fe,
      iridescence: kt,
      iridescenceMap: Ke,
      iridescenceThicknessMap: Ie,
      sheen: H,
      sheenColorMap: de,
      sheenRoughnessMap: J,
      specularMap: fe,
      specularColorMap: Te,
      specularIntensityMap: be,
      transmission: D,
      transmissionMap: De,
      thicknessMap: nt,
      gradientMap: Pt,
      opaque: b.transparent === !1 && b.blending === Ya,
      alphaMap: Q,
      alphaTest: Pe,
      alphaHash: oe,
      combine: b.combine,
      mapUv: ct && M(b.map.channel),
      aoMapUv: V && M(b.aoMap.channel),
      lightMapUv: ye && M(b.lightMap.channel),
      bumpMapUv: me && M(b.bumpMap.channel),
      normalMapUv: Ee && M(b.normalMap.channel),
      displacementMapUv: _e && M(b.displacementMap.channel),
      emissiveMapUv: We && M(b.emissiveMap.channel),
      metalnessMapUv: Oe && M(b.metalnessMap.channel),
      roughnessMapUv: Ge && M(b.roughnessMap.channel),
      anisotropyMapUv: ce && M(b.anisotropyMap.channel),
      clearcoatMapUv: we && M(b.clearcoatMap.channel),
      clearcoatNormalMapUv: Se && M(b.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Fe && M(b.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Ke && M(b.iridescenceMap.channel),
      iridescenceThicknessMapUv: Ie && M(b.iridescenceThicknessMap.channel),
      sheenColorMapUv: de && M(b.sheenColorMap.channel),
      sheenRoughnessMapUv: J && M(b.sheenRoughnessMap.channel),
      specularMapUv: fe && M(b.specularMap.channel),
      specularColorMapUv: Te && M(b.specularColorMap.channel),
      specularIntensityMapUv: be && M(b.specularIntensityMap.channel),
      transmissionMapUv: De && M(b.transmissionMap.channel),
      thicknessMapUv: nt && M(b.thicknessMap.channel),
      alphaMapUv: Q && M(b.alphaMap.channel),
      vertexTangents: !!K.attributes.tangent && (Ee || Ze),
      vertexColors: b.vertexColors,
      vertexAlphas:
        b.vertexColors === !0 &&
        !!K.attributes.color &&
        K.attributes.color.itemSize === 4,
      vertexUv1s: He,
      vertexUv2s: Tt,
      vertexUv3s: Vt,
      pointsUvs: X.isPoints === !0 && !!K.attributes.uv && (ct || Q),
      fog: !!Y,
      useFog: b.fog === !0,
      fogExp2: Y && Y.isFogExp2,
      flatShading: b.flatShading === !0,
      sizeAttenuation: b.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      skinning: X.isSkinnedMesh === !0,
      morphTargets: K.morphAttributes.position !== void 0,
      morphNormals: K.morphAttributes.normal !== void 0,
      morphColors: K.morphAttributes.color !== void 0,
      morphTargetsCount: U,
      morphTextureStride: j,
      numDirLights: L.directional.length,
      numPointLights: L.point.length,
      numSpotLights: L.spot.length,
      numSpotLightMaps: L.spotLightMap.length,
      numRectAreaLights: L.rectArea.length,
      numHemiLights: L.hemi.length,
      numDirLightShadows: L.directionalShadowMap.length,
      numPointLightShadows: L.pointShadowMap.length,
      numSpotLightShadows: L.spotShadowMap.length,
      numSpotLightShadowsWithMaps: L.numSpotLightShadowsWithMaps,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: b.dithering,
      shadowMapEnabled: n.shadowMap.enabled && z.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: b.toneMapped ? n.toneMapping : Vr,
      useLegacyLights: n.useLegacyLights,
      premultipliedAlpha: b.premultipliedAlpha,
      doubleSided: b.side === Ar,
      flipSided: b.side === xi,
      useDepthPacking: b.depthPacking >= 0,
      depthPacking: b.depthPacking || 0,
      index0AttributeName: b.index0AttributeName,
      extensionDerivatives: Be && b.extensions.derivatives === !0,
      extensionFragDepth: Be && b.extensions.fragDepth === !0,
      extensionDrawBuffers: Be && b.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: Be && b.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
      customProgramCacheKey: b.customProgramCacheKey(),
    };
  }
  function g(b) {
    const L = [];
    if (
      (b.shaderID
        ? L.push(b.shaderID)
        : (L.push(b.customVertexShaderID), L.push(b.customFragmentShaderID)),
      b.defines !== void 0)
    )
      for (const z in b.defines) L.push(z), L.push(b.defines[z]);
    return (
      b.isRawShaderMaterial === !1 &&
        (x(L, b), _(L, b), L.push(n.outputColorSpace)),
      L.push(b.customProgramCacheKey),
      L.join()
    );
  }
  function x(b, L) {
    b.push(L.precision),
      b.push(L.outputColorSpace),
      b.push(L.envMapMode),
      b.push(L.envMapCubeUVHeight),
      b.push(L.mapUv),
      b.push(L.alphaMapUv),
      b.push(L.lightMapUv),
      b.push(L.aoMapUv),
      b.push(L.bumpMapUv),
      b.push(L.normalMapUv),
      b.push(L.displacementMapUv),
      b.push(L.emissiveMapUv),
      b.push(L.metalnessMapUv),
      b.push(L.roughnessMapUv),
      b.push(L.anisotropyMapUv),
      b.push(L.clearcoatMapUv),
      b.push(L.clearcoatNormalMapUv),
      b.push(L.clearcoatRoughnessMapUv),
      b.push(L.iridescenceMapUv),
      b.push(L.iridescenceThicknessMapUv),
      b.push(L.sheenColorMapUv),
      b.push(L.sheenRoughnessMapUv),
      b.push(L.specularMapUv),
      b.push(L.specularColorMapUv),
      b.push(L.specularIntensityMapUv),
      b.push(L.transmissionMapUv),
      b.push(L.thicknessMapUv),
      b.push(L.combine),
      b.push(L.fogExp2),
      b.push(L.sizeAttenuation),
      b.push(L.morphTargetsCount),
      b.push(L.morphAttributeCount),
      b.push(L.numDirLights),
      b.push(L.numPointLights),
      b.push(L.numSpotLights),
      b.push(L.numSpotLightMaps),
      b.push(L.numHemiLights),
      b.push(L.numRectAreaLights),
      b.push(L.numDirLightShadows),
      b.push(L.numPointLightShadows),
      b.push(L.numSpotLightShadows),
      b.push(L.numSpotLightShadowsWithMaps),
      b.push(L.shadowMapType),
      b.push(L.toneMapping),
      b.push(L.numClippingPlanes),
      b.push(L.numClipIntersection),
      b.push(L.depthPacking);
  }
  function _(b, L) {
    a.disableAll(),
      L.isWebGL2 && a.enable(0),
      L.supportsVertexTextures && a.enable(1),
      L.instancing && a.enable(2),
      L.instancingColor && a.enable(3),
      L.matcap && a.enable(4),
      L.envMap && a.enable(5),
      L.normalMapObjectSpace && a.enable(6),
      L.normalMapTangentSpace && a.enable(7),
      L.clearcoat && a.enable(8),
      L.iridescence && a.enable(9),
      L.alphaTest && a.enable(10),
      L.vertexColors && a.enable(11),
      L.vertexAlphas && a.enable(12),
      L.vertexUv1s && a.enable(13),
      L.vertexUv2s && a.enable(14),
      L.vertexUv3s && a.enable(15),
      L.vertexTangents && a.enable(16),
      L.anisotropy && a.enable(17),
      b.push(a.mask),
      a.disableAll(),
      L.fog && a.enable(0),
      L.useFog && a.enable(1),
      L.flatShading && a.enable(2),
      L.logarithmicDepthBuffer && a.enable(3),
      L.skinning && a.enable(4),
      L.morphTargets && a.enable(5),
      L.morphNormals && a.enable(6),
      L.morphColors && a.enable(7),
      L.premultipliedAlpha && a.enable(8),
      L.shadowMapEnabled && a.enable(9),
      L.useLegacyLights && a.enable(10),
      L.doubleSided && a.enable(11),
      L.flipSided && a.enable(12),
      L.useDepthPacking && a.enable(13),
      L.dithering && a.enable(14),
      L.transmission && a.enable(15),
      L.sheen && a.enable(16),
      L.opaque && a.enable(17),
      L.pointsUvs && a.enable(18),
      b.push(a.mask);
  }
  function E(b) {
    const L = y[b.type];
    let z;
    if (L) {
      const $ = kr[L];
      z = uB.clone($.uniforms);
    } else z = b.uniforms;
    return z;
  }
  function T(b, L) {
    let z;
    for (let $ = 0, X = u.length; $ < X; $++) {
      const Y = u[$];
      if (Y.cacheKey === L) {
        (z = Y), ++z.usedTimes;
        break;
      }
    }
    return z === void 0 && ((z = new FG(n, L, b, s)), u.push(z)), z;
  }
  function R(b) {
    if (--b.usedTimes === 0) {
      const L = u.indexOf(b);
      (u[L] = u[u.length - 1]), u.pop(), b.destroy();
    }
  }
  function P(b) {
    l.remove(b);
  }
  function B() {
    l.dispose();
  }
  return {
    getParameters: A,
    getProgramCacheKey: g,
    getUniforms: E,
    acquireProgram: T,
    releaseProgram: R,
    releaseShaderCache: P,
    programs: u,
    dispose: B,
  };
}
function HG() {
  let n = new WeakMap();
  function e(s) {
    let o = n.get(s);
    return o === void 0 && ((o = {}), n.set(s, o)), o;
  }
  function t(s) {
    n.delete(s);
  }
  function i(s, o, a) {
    n.get(s)[o] = a;
  }
  function r() {
    n = new WeakMap();
  }
  return { get: e, remove: t, update: i, dispose: r };
}
function zG(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function rT(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function sT() {
  const n = [];
  let e = 0;
  const t = [],
    i = [],
    r = [];
  function s() {
    (e = 0), (t.length = 0), (i.length = 0), (r.length = 0);
  }
  function o(d, p, m, y, M, A) {
    let g = n[e];
    return (
      g === void 0
        ? ((g = {
            id: d.id,
            object: d,
            geometry: p,
            material: m,
            groupOrder: y,
            renderOrder: d.renderOrder,
            z: M,
            group: A,
          }),
          (n[e] = g))
        : ((g.id = d.id),
          (g.object = d),
          (g.geometry = p),
          (g.material = m),
          (g.groupOrder = y),
          (g.renderOrder = d.renderOrder),
          (g.z = M),
          (g.group = A)),
      e++,
      g
    );
  }
  function a(d, p, m, y, M, A) {
    const g = o(d, p, m, y, M, A);
    m.transmission > 0
      ? i.push(g)
      : m.transparent === !0
      ? r.push(g)
      : t.push(g);
  }
  function l(d, p, m, y, M, A) {
    const g = o(d, p, m, y, M, A);
    m.transmission > 0
      ? i.unshift(g)
      : m.transparent === !0
      ? r.unshift(g)
      : t.unshift(g);
  }
  function u(d, p) {
    t.length > 1 && t.sort(d || zG),
      i.length > 1 && i.sort(p || rT),
      r.length > 1 && r.sort(p || rT);
  }
  function h() {
    for (let d = e, p = n.length; d < p; d++) {
      const m = n[d];
      if (m.id === null) break;
      (m.id = null),
        (m.object = null),
        (m.geometry = null),
        (m.material = null),
        (m.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: s,
    push: a,
    unshift: l,
    finish: h,
    sort: u,
  };
}
function GG() {
  let n = new WeakMap();
  function e(i, r) {
    const s = n.get(i);
    let o;
    return (
      s === void 0
        ? ((o = new sT()), n.set(i, [o]))
        : r >= s.length
        ? ((o = new sT()), s.push(o))
        : (o = s[r]),
      o
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function VG() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new F(), color: new Ue() };
          break;
        case "SpotLight":
          t = {
            position: new F(),
            direction: new F(),
            color: new Ue(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new F(), color: new Ue(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new F(), skyColor: new Ue(), groundColor: new Ue() };
          break;
        case "RectAreaLight":
          t = {
            color: new Ue(),
            position: new F(),
            halfWidth: new F(),
            halfHeight: new F(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function WG() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ve(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ve(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ve(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let jG = 0;
function XG(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function JG(n, e) {
  const t = new VG(),
    i = WG(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
    };
  for (let h = 0; h < 9; h++) r.probe.push(new F());
  const s = new F(),
    o = new rt(),
    a = new rt();
  function l(h, d) {
    let p = 0,
      m = 0,
      y = 0;
    for (let z = 0; z < 9; z++) r.probe[z].set(0, 0, 0);
    let M = 0,
      A = 0,
      g = 0,
      x = 0,
      _ = 0,
      E = 0,
      T = 0,
      R = 0,
      P = 0,
      B = 0;
    h.sort(XG);
    const b = d === !0 ? Math.PI : 1;
    for (let z = 0, $ = h.length; z < $; z++) {
      const X = h[z],
        Y = X.color,
        K = X.intensity,
        ie = X.distance,
        ee = X.shadow && X.shadow.map ? X.shadow.map.texture : null;
      if (X.isAmbientLight)
        (p += Y.r * K * b), (m += Y.g * K * b), (y += Y.b * K * b);
      else if (X.isLightProbe)
        for (let I = 0; I < 9; I++)
          r.probe[I].addScaledVector(X.sh.coefficients[I], K);
      else if (X.isDirectionalLight) {
        const I = t.get(X);
        if (
          (I.color.copy(X.color).multiplyScalar(X.intensity * b), X.castShadow)
        ) {
          const G = X.shadow,
            k = i.get(X);
          (k.shadowBias = G.bias),
            (k.shadowNormalBias = G.normalBias),
            (k.shadowRadius = G.radius),
            (k.shadowMapSize = G.mapSize),
            (r.directionalShadow[M] = k),
            (r.directionalShadowMap[M] = ee),
            (r.directionalShadowMatrix[M] = X.shadow.matrix),
            E++;
        }
        (r.directional[M] = I), M++;
      } else if (X.isSpotLight) {
        const I = t.get(X);
        I.position.setFromMatrixPosition(X.matrixWorld),
          I.color.copy(Y).multiplyScalar(K * b),
          (I.distance = ie),
          (I.coneCos = Math.cos(X.angle)),
          (I.penumbraCos = Math.cos(X.angle * (1 - X.penumbra))),
          (I.decay = X.decay),
          (r.spot[g] = I);
        const G = X.shadow;
        if (
          (X.map &&
            ((r.spotLightMap[P] = X.map),
            P++,
            G.updateMatrices(X),
            X.castShadow && B++),
          (r.spotLightMatrix[g] = G.matrix),
          X.castShadow)
        ) {
          const k = i.get(X);
          (k.shadowBias = G.bias),
            (k.shadowNormalBias = G.normalBias),
            (k.shadowRadius = G.radius),
            (k.shadowMapSize = G.mapSize),
            (r.spotShadow[g] = k),
            (r.spotShadowMap[g] = ee),
            R++;
        }
        g++;
      } else if (X.isRectAreaLight) {
        const I = t.get(X);
        I.color.copy(Y).multiplyScalar(K),
          I.halfWidth.set(X.width * 0.5, 0, 0),
          I.halfHeight.set(0, X.height * 0.5, 0),
          (r.rectArea[x] = I),
          x++;
      } else if (X.isPointLight) {
        const I = t.get(X);
        if (
          (I.color.copy(X.color).multiplyScalar(X.intensity * b),
          (I.distance = X.distance),
          (I.decay = X.decay),
          X.castShadow)
        ) {
          const G = X.shadow,
            k = i.get(X);
          (k.shadowBias = G.bias),
            (k.shadowNormalBias = G.normalBias),
            (k.shadowRadius = G.radius),
            (k.shadowMapSize = G.mapSize),
            (k.shadowCameraNear = G.camera.near),
            (k.shadowCameraFar = G.camera.far),
            (r.pointShadow[A] = k),
            (r.pointShadowMap[A] = ee),
            (r.pointShadowMatrix[A] = X.shadow.matrix),
            T++;
        }
        (r.point[A] = I), A++;
      } else if (X.isHemisphereLight) {
        const I = t.get(X);
        I.skyColor.copy(X.color).multiplyScalar(K * b),
          I.groundColor.copy(X.groundColor).multiplyScalar(K * b),
          (r.hemi[_] = I),
          _++;
      }
    }
    x > 0 &&
      (e.isWebGL2 || n.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = Ne.LTC_FLOAT_1), (r.rectAreaLTC2 = Ne.LTC_FLOAT_2))
        : n.has("OES_texture_half_float_linear") === !0
        ? ((r.rectAreaLTC1 = Ne.LTC_HALF_1), (r.rectAreaLTC2 = Ne.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (r.ambient[0] = p),
      (r.ambient[1] = m),
      (r.ambient[2] = y);
    const L = r.hash;
    (L.directionalLength !== M ||
      L.pointLength !== A ||
      L.spotLength !== g ||
      L.rectAreaLength !== x ||
      L.hemiLength !== _ ||
      L.numDirectionalShadows !== E ||
      L.numPointShadows !== T ||
      L.numSpotShadows !== R ||
      L.numSpotMaps !== P) &&
      ((r.directional.length = M),
      (r.spot.length = g),
      (r.rectArea.length = x),
      (r.point.length = A),
      (r.hemi.length = _),
      (r.directionalShadow.length = E),
      (r.directionalShadowMap.length = E),
      (r.pointShadow.length = T),
      (r.pointShadowMap.length = T),
      (r.spotShadow.length = R),
      (r.spotShadowMap.length = R),
      (r.directionalShadowMatrix.length = E),
      (r.pointShadowMatrix.length = T),
      (r.spotLightMatrix.length = R + P - B),
      (r.spotLightMap.length = P),
      (r.numSpotLightShadowsWithMaps = B),
      (L.directionalLength = M),
      (L.pointLength = A),
      (L.spotLength = g),
      (L.rectAreaLength = x),
      (L.hemiLength = _),
      (L.numDirectionalShadows = E),
      (L.numPointShadows = T),
      (L.numSpotShadows = R),
      (L.numSpotMaps = P),
      (r.version = jG++));
  }
  function u(h, d) {
    let p = 0,
      m = 0,
      y = 0,
      M = 0,
      A = 0;
    const g = d.matrixWorldInverse;
    for (let x = 0, _ = h.length; x < _; x++) {
      const E = h[x];
      if (E.isDirectionalLight) {
        const T = r.directional[p];
        T.direction.setFromMatrixPosition(E.matrixWorld),
          s.setFromMatrixPosition(E.target.matrixWorld),
          T.direction.sub(s),
          T.direction.transformDirection(g),
          p++;
      } else if (E.isSpotLight) {
        const T = r.spot[y];
        T.position.setFromMatrixPosition(E.matrixWorld),
          T.position.applyMatrix4(g),
          T.direction.setFromMatrixPosition(E.matrixWorld),
          s.setFromMatrixPosition(E.target.matrixWorld),
          T.direction.sub(s),
          T.direction.transformDirection(g),
          y++;
      } else if (E.isRectAreaLight) {
        const T = r.rectArea[M];
        T.position.setFromMatrixPosition(E.matrixWorld),
          T.position.applyMatrix4(g),
          a.identity(),
          o.copy(E.matrixWorld),
          o.premultiply(g),
          a.extractRotation(o),
          T.halfWidth.set(E.width * 0.5, 0, 0),
          T.halfHeight.set(0, E.height * 0.5, 0),
          T.halfWidth.applyMatrix4(a),
          T.halfHeight.applyMatrix4(a),
          M++;
      } else if (E.isPointLight) {
        const T = r.point[m];
        T.position.setFromMatrixPosition(E.matrixWorld),
          T.position.applyMatrix4(g),
          m++;
      } else if (E.isHemisphereLight) {
        const T = r.hemi[A];
        T.direction.setFromMatrixPosition(E.matrixWorld),
          T.direction.transformDirection(g),
          A++;
      }
    }
  }
  return { setup: l, setupView: u, state: r };
}
function oT(n, e) {
  const t = new JG(n, e),
    i = [],
    r = [];
  function s() {
    (i.length = 0), (r.length = 0);
  }
  function o(d) {
    i.push(d);
  }
  function a(d) {
    r.push(d);
  }
  function l(d) {
    t.setup(i, d);
  }
  function u(d) {
    t.setupView(i, d);
  }
  return {
    init: s,
    state: { lightsArray: i, shadowsArray: r, lights: t },
    setupLights: l,
    setupLightsView: u,
    pushLight: o,
    pushShadow: a,
  };
}
function KG(n, e) {
  let t = new WeakMap();
  function i(s, o = 0) {
    const a = t.get(s);
    let l;
    return (
      a === void 0
        ? ((l = new oT(n, e)), t.set(s, [l]))
        : o >= a.length
        ? ((l = new oT(n, e)), a.push(l))
        : (l = a[o]),
      l
    );
  }
  function r() {
    t = new WeakMap();
  }
  return { get: i, dispose: r };
}
class R1 extends bn {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = J2),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class P1 extends bn {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const YG = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  QG = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function qG(n, e, t) {
  let i = new Og();
  const r = new ve(),
    s = new ve(),
    o = new Ut(),
    a = new R1({ depthPacking: K2 }),
    l = new P1(),
    u = {},
    h = t.maxTextureSize,
    d = { [xs]: xi, [xi]: xs, [Ar]: Ar },
    p = new As({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new ve() },
        radius: { value: 4 },
      },
      vertexShader: YG,
      fragmentShader: QG,
    }),
    m = p.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const y = new gt();
  y.setAttribute(
    "position",
    new Ft(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const M = new Gn(y, p),
    A = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Lg);
  let g = this.type;
  this.render = function (T, R, P) {
    if (
      A.enabled === !1 ||
      (A.autoUpdate === !1 && A.needsUpdate === !1) ||
      T.length === 0
    )
      return;
    const B = n.getRenderTarget(),
      b = n.getActiveCubeFace(),
      L = n.getActiveMipmapLevel(),
      z = n.state;
    z.setBlending(Xs),
      z.buffers.color.setClear(1, 1, 1, 1),
      z.buffers.depth.setTest(!0),
      z.setScissorTest(!1);
    const $ = g !== Nr && this.type === Nr,
      X = g === Nr && this.type !== Nr;
    for (let Y = 0, K = T.length; Y < K; Y++) {
      const ie = T[Y],
        ee = ie.shadow;
      if (ee === void 0) {
        console.warn("THREE.WebGLShadowMap:", ie, "has no shadow.");
        continue;
      }
      if (ee.autoUpdate === !1 && ee.needsUpdate === !1) continue;
      r.copy(ee.mapSize);
      const I = ee.getFrameExtents();
      if (
        (r.multiply(I),
        s.copy(ee.mapSize),
        (r.x > h || r.y > h) &&
          (r.x > h &&
            ((s.x = Math.floor(h / I.x)),
            (r.x = s.x * I.x),
            (ee.mapSize.x = s.x)),
          r.y > h &&
            ((s.y = Math.floor(h / I.y)),
            (r.y = s.y * I.y),
            (ee.mapSize.y = s.y))),
        ee.map === null || $ === !0 || X === !0)
      ) {
        const k = this.type !== Nr ? { minFilter: gn, magFilter: gn } : {};
        ee.map !== null && ee.map.dispose(),
          (ee.map = new Jr(r.x, r.y, k)),
          (ee.map.texture.name = ie.name + ".shadowMap"),
          ee.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(ee.map), n.clear();
      const G = ee.getViewportCount();
      for (let k = 0; k < G; k++) {
        const U = ee.getViewport(k);
        o.set(s.x * U.x, s.y * U.y, s.x * U.z, s.y * U.w),
          z.viewport(o),
          ee.updateMatrices(ie, k),
          (i = ee.getFrustum()),
          E(R, P, ee.camera, ie, this.type);
      }
      ee.isPointLightShadow !== !0 && this.type === Nr && x(ee, P),
        (ee.needsUpdate = !1);
    }
    (g = this.type), (A.needsUpdate = !1), n.setRenderTarget(B, b, L);
  };
  function x(T, R) {
    const P = e.update(M);
    p.defines.VSM_SAMPLES !== T.blurSamples &&
      ((p.defines.VSM_SAMPLES = T.blurSamples),
      (m.defines.VSM_SAMPLES = T.blurSamples),
      (p.needsUpdate = !0),
      (m.needsUpdate = !0)),
      T.mapPass === null && (T.mapPass = new Jr(r.x, r.y)),
      (p.uniforms.shadow_pass.value = T.map.texture),
      (p.uniforms.resolution.value = T.mapSize),
      (p.uniforms.radius.value = T.radius),
      n.setRenderTarget(T.mapPass),
      n.clear(),
      n.renderBufferDirect(R, null, P, p, M, null),
      (m.uniforms.shadow_pass.value = T.mapPass.texture),
      (m.uniforms.resolution.value = T.mapSize),
      (m.uniforms.radius.value = T.radius),
      n.setRenderTarget(T.map),
      n.clear(),
      n.renderBufferDirect(R, null, P, m, M, null);
  }
  function _(T, R, P, B) {
    let b = null;
    const L =
      P.isPointLight === !0 ? T.customDistanceMaterial : T.customDepthMaterial;
    if (L !== void 0) b = L;
    else if (
      ((b = P.isPointLight === !0 ? l : a),
      (n.localClippingEnabled &&
        R.clipShadows === !0 &&
        Array.isArray(R.clippingPlanes) &&
        R.clippingPlanes.length !== 0) ||
        (R.displacementMap && R.displacementScale !== 0) ||
        (R.alphaMap && R.alphaTest > 0) ||
        (R.map && R.alphaTest > 0))
    ) {
      const z = b.uuid,
        $ = R.uuid;
      let X = u[z];
      X === void 0 && ((X = {}), (u[z] = X));
      let Y = X[$];
      Y === void 0 && ((Y = b.clone()), (X[$] = Y)), (b = Y);
    }
    if (
      ((b.visible = R.visible),
      (b.wireframe = R.wireframe),
      B === Nr
        ? (b.side = R.shadowSide !== null ? R.shadowSide : R.side)
        : (b.side = R.shadowSide !== null ? R.shadowSide : d[R.side]),
      (b.alphaMap = R.alphaMap),
      (b.alphaTest = R.alphaTest),
      (b.map = R.map),
      (b.clipShadows = R.clipShadows),
      (b.clippingPlanes = R.clippingPlanes),
      (b.clipIntersection = R.clipIntersection),
      (b.displacementMap = R.displacementMap),
      (b.displacementScale = R.displacementScale),
      (b.displacementBias = R.displacementBias),
      (b.wireframeLinewidth = R.wireframeLinewidth),
      (b.linewidth = R.linewidth),
      P.isPointLight === !0 && b.isMeshDistanceMaterial === !0)
    ) {
      const z = n.properties.get(b);
      z.light = P;
    }
    return b;
  }
  function E(T, R, P, B, b) {
    if (T.visible === !1) return;
    if (
      T.layers.test(R.layers) &&
      (T.isMesh || T.isLine || T.isPoints) &&
      (T.castShadow || (T.receiveShadow && b === Nr)) &&
      (!T.frustumCulled || i.intersectsObject(T))
    ) {
      T.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, T.matrixWorld);
      const $ = e.update(T),
        X = T.material;
      if (Array.isArray(X)) {
        const Y = $.groups;
        for (let K = 0, ie = Y.length; K < ie; K++) {
          const ee = Y[K],
            I = X[ee.materialIndex];
          if (I && I.visible) {
            const G = _(T, I, B, b);
            n.renderBufferDirect(P, null, $, G, T, ee);
          }
        }
      } else if (X.visible) {
        const Y = _(T, X, B, b);
        n.renderBufferDirect(P, null, $, Y, T, null);
      }
    }
    const z = T.children;
    for (let $ = 0, X = z.length; $ < X; $++) E(z[$], R, P, B, b);
  }
}
function ZG(n, e, t) {
  const i = t.isWebGL2;
  function r() {
    let Q = !1;
    const Pe = new Ut();
    let oe = null;
    const Be = new Ut(0, 0, 0, 0);
    return {
      setMask: function (He) {
        oe !== He && !Q && (n.colorMask(He, He, He, He), (oe = He));
      },
      setLocked: function (He) {
        Q = He;
      },
      setClear: function (He, Tt, Vt, An, Di) {
        Di === !0 && ((He *= An), (Tt *= An), (Vt *= An)),
          Pe.set(He, Tt, Vt, An),
          Be.equals(Pe) === !1 && (n.clearColor(He, Tt, Vt, An), Be.copy(Pe));
      },
      reset: function () {
        (Q = !1), (oe = null), Be.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let Q = !1,
      Pe = null,
      oe = null,
      Be = null;
    return {
      setTest: function (He) {
        He ? Le(n.DEPTH_TEST) : Ve(n.DEPTH_TEST);
      },
      setMask: function (He) {
        Pe !== He && !Q && (n.depthMask(He), (Pe = He));
      },
      setFunc: function (He) {
        if (oe !== He) {
          switch (He) {
            case A2:
              n.depthFunc(n.NEVER);
              break;
            case S2:
              n.depthFunc(n.ALWAYS);
              break;
            case M2:
              n.depthFunc(n.LESS);
              break;
            case Ym:
              n.depthFunc(n.LEQUAL);
              break;
            case E2:
              n.depthFunc(n.EQUAL);
              break;
            case w2:
              n.depthFunc(n.GEQUAL);
              break;
            case T2:
              n.depthFunc(n.GREATER);
              break;
            case C2:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          oe = He;
        }
      },
      setLocked: function (He) {
        Q = He;
      },
      setClear: function (He) {
        Be !== He && (n.clearDepth(He), (Be = He));
      },
      reset: function () {
        (Q = !1), (Pe = null), (oe = null), (Be = null);
      },
    };
  }
  function o() {
    let Q = !1,
      Pe = null,
      oe = null,
      Be = null,
      He = null,
      Tt = null,
      Vt = null,
      An = null,
      Di = null;
    return {
      setTest: function (Xt) {
        Q || (Xt ? Le(n.STENCIL_TEST) : Ve(n.STENCIL_TEST));
      },
      setMask: function (Xt) {
        Pe !== Xt && !Q && (n.stencilMask(Xt), (Pe = Xt));
      },
      setFunc: function (Xt, Fi, jn) {
        (oe !== Xt || Be !== Fi || He !== jn) &&
          (n.stencilFunc(Xt, Fi, jn), (oe = Xt), (Be = Fi), (He = jn));
      },
      setOp: function (Xt, Fi, jn) {
        (Tt !== Xt || Vt !== Fi || An !== jn) &&
          (n.stencilOp(Xt, Fi, jn), (Tt = Xt), (Vt = Fi), (An = jn));
      },
      setLocked: function (Xt) {
        Q = Xt;
      },
      setClear: function (Xt) {
        Di !== Xt && (n.clearStencil(Xt), (Di = Xt));
      },
      reset: function () {
        (Q = !1),
          (Pe = null),
          (oe = null),
          (Be = null),
          (He = null),
          (Tt = null),
          (Vt = null),
          (An = null),
          (Di = null);
      },
    };
  }
  const a = new r(),
    l = new s(),
    u = new o(),
    h = new WeakMap(),
    d = new WeakMap();
  let p = {},
    m = {},
    y = new WeakMap(),
    M = [],
    A = null,
    g = !1,
    x = null,
    _ = null,
    E = null,
    T = null,
    R = null,
    P = null,
    B = null,
    b = !1,
    L = null,
    z = null,
    $ = null,
    X = null,
    Y = null;
  const K = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let ie = !1,
    ee = 0;
  const I = n.getParameter(n.VERSION);
  I.indexOf("WebGL") !== -1
    ? ((ee = parseFloat(/^WebGL (\d)/.exec(I)[1])), (ie = ee >= 1))
    : I.indexOf("OpenGL ES") !== -1 &&
      ((ee = parseFloat(/^OpenGL ES (\d)/.exec(I)[1])), (ie = ee >= 2));
  let G = null,
    k = {};
  const U = n.getParameter(n.SCISSOR_BOX),
    j = n.getParameter(n.VIEWPORT),
    he = new Ut().fromArray(U),
    ae = new Ut().fromArray(j);
  function xe(Q, Pe, oe, Be) {
    const He = new Uint8Array(4),
      Tt = n.createTexture();
    n.bindTexture(Q, Tt),
      n.texParameteri(Q, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(Q, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let Vt = 0; Vt < oe; Vt++)
      i && (Q === n.TEXTURE_3D || Q === n.TEXTURE_2D_ARRAY)
        ? n.texImage3D(Pe, 0, n.RGBA, 1, 1, Be, 0, n.RGBA, n.UNSIGNED_BYTE, He)
        : n.texImage2D(
            Pe + Vt,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            He
          );
    return Tt;
  }
  const Ae = {};
  (Ae[n.TEXTURE_2D] = xe(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (Ae[n.TEXTURE_CUBE_MAP] = xe(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    i &&
      ((Ae[n.TEXTURE_2D_ARRAY] = xe(
        n.TEXTURE_2D_ARRAY,
        n.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (Ae[n.TEXTURE_3D] = xe(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1))),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    u.setClear(0),
    Le(n.DEPTH_TEST),
    l.setFunc(Ym),
    _e(!1),
    We(i_),
    Le(n.CULL_FACE),
    me(Xs);
  function Le(Q) {
    p[Q] !== !0 && (n.enable(Q), (p[Q] = !0));
  }
  function Ve(Q) {
    p[Q] !== !1 && (n.disable(Q), (p[Q] = !1));
  }
  function ct(Q, Pe) {
    return m[Q] !== Pe
      ? (n.bindFramebuffer(Q, Pe),
        (m[Q] = Pe),
        i &&
          (Q === n.DRAW_FRAMEBUFFER && (m[n.FRAMEBUFFER] = Pe),
          Q === n.FRAMEBUFFER && (m[n.DRAW_FRAMEBUFFER] = Pe)),
        !0)
      : !1;
  }
  function tt(Q, Pe) {
    let oe = M,
      Be = !1;
    if (Q)
      if (
        ((oe = y.get(Pe)),
        oe === void 0 && ((oe = []), y.set(Pe, oe)),
        Q.isWebGLMultipleRenderTargets)
      ) {
        const He = Q.texture;
        if (oe.length !== He.length || oe[0] !== n.COLOR_ATTACHMENT0) {
          for (let Tt = 0, Vt = He.length; Tt < Vt; Tt++)
            oe[Tt] = n.COLOR_ATTACHMENT0 + Tt;
          (oe.length = He.length), (Be = !0);
        }
      } else
        oe[0] !== n.COLOR_ATTACHMENT0 &&
          ((oe[0] = n.COLOR_ATTACHMENT0), (Be = !0));
    else oe[0] !== n.BACK && ((oe[0] = n.BACK), (Be = !0));
    Be &&
      (t.isWebGL2
        ? n.drawBuffers(oe)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(oe));
  }
  function Me(Q) {
    return A !== Q ? (n.useProgram(Q), (A = Q), !0) : !1;
  }
  const V = {
    [Fa]: n.FUNC_ADD,
    [u2]: n.FUNC_SUBTRACT,
    [f2]: n.FUNC_REVERSE_SUBTRACT,
  };
  if (i) (V[a_] = n.MIN), (V[l_] = n.MAX);
  else {
    const Q = e.get("EXT_blend_minmax");
    Q !== null && ((V[a_] = Q.MIN_EXT), (V[l_] = Q.MAX_EXT));
  }
  const ye = {
    [h2]: n.ZERO,
    [d2]: n.ONE,
    [p2]: n.SRC_COLOR,
    [l1]: n.SRC_ALPHA,
    [_2]: n.SRC_ALPHA_SATURATE,
    [y2]: n.DST_COLOR,
    [g2]: n.DST_ALPHA,
    [m2]: n.ONE_MINUS_SRC_COLOR,
    [c1]: n.ONE_MINUS_SRC_ALPHA,
    [x2]: n.ONE_MINUS_DST_COLOR,
    [v2]: n.ONE_MINUS_DST_ALPHA,
  };
  function me(Q, Pe, oe, Be, He, Tt, Vt, An) {
    if (Q === Xs) {
      g === !0 && (Ve(n.BLEND), (g = !1));
      return;
    }
    if ((g === !1 && (Le(n.BLEND), (g = !0)), Q !== c2)) {
      if (Q !== x || An !== b) {
        if (
          ((_ !== Fa || R !== Fa) &&
            (n.blendEquation(n.FUNC_ADD), (_ = Fa), (R = Fa)),
          An)
        )
          switch (Q) {
            case Ya:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case r_:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case s_:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case o_:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Q);
              break;
          }
        else
          switch (Q) {
            case Ya:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case r_:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case s_:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case o_:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Q);
              break;
          }
        (E = null), (T = null), (P = null), (B = null), (x = Q), (b = An);
      }
      return;
    }
    (He = He || Pe),
      (Tt = Tt || oe),
      (Vt = Vt || Be),
      (Pe !== _ || He !== R) &&
        (n.blendEquationSeparate(V[Pe], V[He]), (_ = Pe), (R = He)),
      (oe !== E || Be !== T || Tt !== P || Vt !== B) &&
        (n.blendFuncSeparate(ye[oe], ye[Be], ye[Tt], ye[Vt]),
        (E = oe),
        (T = Be),
        (P = Tt),
        (B = Vt)),
      (x = Q),
      (b = !1);
  }
  function Ee(Q, Pe) {
    Q.side === Ar ? Ve(n.CULL_FACE) : Le(n.CULL_FACE);
    let oe = Q.side === xi;
    Pe && (oe = !oe),
      _e(oe),
      Q.blending === Ya && Q.transparent === !1
        ? me(Xs)
        : me(
            Q.blending,
            Q.blendEquation,
            Q.blendSrc,
            Q.blendDst,
            Q.blendEquationAlpha,
            Q.blendSrcAlpha,
            Q.blendDstAlpha,
            Q.premultipliedAlpha
          ),
      l.setFunc(Q.depthFunc),
      l.setTest(Q.depthTest),
      l.setMask(Q.depthWrite),
      a.setMask(Q.colorWrite);
    const Be = Q.stencilWrite;
    u.setTest(Be),
      Be &&
        (u.setMask(Q.stencilWriteMask),
        u.setFunc(Q.stencilFunc, Q.stencilRef, Q.stencilFuncMask),
        u.setOp(Q.stencilFail, Q.stencilZFail, Q.stencilZPass)),
      Ge(Q.polygonOffset, Q.polygonOffsetFactor, Q.polygonOffsetUnits),
      Q.alphaToCoverage === !0
        ? Le(n.SAMPLE_ALPHA_TO_COVERAGE)
        : Ve(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function _e(Q) {
    L !== Q && (Q ? n.frontFace(n.CW) : n.frontFace(n.CCW), (L = Q));
  }
  function We(Q) {
    Q !== o2
      ? (Le(n.CULL_FACE),
        Q !== z &&
          (Q === i_
            ? n.cullFace(n.BACK)
            : Q === a2
            ? n.cullFace(n.FRONT)
            : n.cullFace(n.FRONT_AND_BACK)))
      : Ve(n.CULL_FACE),
      (z = Q);
  }
  function Oe(Q) {
    Q !== $ && (ie && n.lineWidth(Q), ($ = Q));
  }
  function Ge(Q, Pe, oe) {
    Q
      ? (Le(n.POLYGON_OFFSET_FILL),
        (X !== Pe || Y !== oe) && (n.polygonOffset(Pe, oe), (X = Pe), (Y = oe)))
      : Ve(n.POLYGON_OFFSET_FILL);
  }
  function Ze(Q) {
    Q ? Le(n.SCISSOR_TEST) : Ve(n.SCISSOR_TEST);
  }
  function vt(Q) {
    Q === void 0 && (Q = n.TEXTURE0 + K - 1),
      G !== Q && (n.activeTexture(Q), (G = Q));
  }
  function kt(Q, Pe, oe) {
    oe === void 0 && (G === null ? (oe = n.TEXTURE0 + K - 1) : (oe = G));
    let Be = k[oe];
    Be === void 0 && ((Be = { type: void 0, texture: void 0 }), (k[oe] = Be)),
      (Be.type !== Q || Be.texture !== Pe) &&
        (G !== oe && (n.activeTexture(oe), (G = oe)),
        n.bindTexture(Q, Pe || Ae[Q]),
        (Be.type = Q),
        (Be.texture = Pe));
  }
  function H() {
    const Q = k[G];
    Q !== void 0 &&
      Q.type !== void 0 &&
      (n.bindTexture(Q.type, null), (Q.type = void 0), (Q.texture = void 0));
  }
  function D() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (Q) {
      console.error("THREE.WebGLState:", Q);
    }
  }
  function ce() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (Q) {
      console.error("THREE.WebGLState:", Q);
    }
  }
  function we() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (Q) {
      console.error("THREE.WebGLState:", Q);
    }
  }
  function Se() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (Q) {
      console.error("THREE.WebGLState:", Q);
    }
  }
  function Fe() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (Q) {
      console.error("THREE.WebGLState:", Q);
    }
  }
  function Ke() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (Q) {
      console.error("THREE.WebGLState:", Q);
    }
  }
  function Ie() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (Q) {
      console.error("THREE.WebGLState:", Q);
    }
  }
  function de() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (Q) {
      console.error("THREE.WebGLState:", Q);
    }
  }
  function J() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (Q) {
      console.error("THREE.WebGLState:", Q);
    }
  }
  function fe() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (Q) {
      console.error("THREE.WebGLState:", Q);
    }
  }
  function Te(Q) {
    he.equals(Q) === !1 && (n.scissor(Q.x, Q.y, Q.z, Q.w), he.copy(Q));
  }
  function be(Q) {
    ae.equals(Q) === !1 && (n.viewport(Q.x, Q.y, Q.z, Q.w), ae.copy(Q));
  }
  function De(Q, Pe) {
    let oe = d.get(Pe);
    oe === void 0 && ((oe = new WeakMap()), d.set(Pe, oe));
    let Be = oe.get(Q);
    Be === void 0 && ((Be = n.getUniformBlockIndex(Pe, Q.name)), oe.set(Q, Be));
  }
  function nt(Q, Pe) {
    const Be = d.get(Pe).get(Q);
    h.get(Pe) !== Be &&
      (n.uniformBlockBinding(Pe, Be, Q.__bindingPointIndex), h.set(Pe, Be));
  }
  function Pt() {
    n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      i === !0 &&
        (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        n.bindFramebuffer(n.READ_FRAMEBUFFER, null)),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (p = {}),
      (G = null),
      (k = {}),
      (m = {}),
      (y = new WeakMap()),
      (M = []),
      (A = null),
      (g = !1),
      (x = null),
      (_ = null),
      (E = null),
      (T = null),
      (R = null),
      (P = null),
      (B = null),
      (b = !1),
      (L = null),
      (z = null),
      ($ = null),
      (X = null),
      (Y = null),
      he.set(0, 0, n.canvas.width, n.canvas.height),
      ae.set(0, 0, n.canvas.width, n.canvas.height),
      a.reset(),
      l.reset(),
      u.reset();
  }
  return {
    buffers: { color: a, depth: l, stencil: u },
    enable: Le,
    disable: Ve,
    bindFramebuffer: ct,
    drawBuffers: tt,
    useProgram: Me,
    setBlending: me,
    setMaterial: Ee,
    setFlipSided: _e,
    setCullFace: We,
    setLineWidth: Oe,
    setPolygonOffset: Ge,
    setScissorTest: Ze,
    activeTexture: vt,
    bindTexture: kt,
    unbindTexture: H,
    compressedTexImage2D: D,
    compressedTexImage3D: ce,
    texImage2D: J,
    texImage3D: fe,
    updateUBOMapping: De,
    uniformBlockBinding: nt,
    texStorage2D: Ie,
    texStorage3D: de,
    texSubImage2D: we,
    texSubImage3D: Se,
    compressedTexSubImage2D: Fe,
    compressedTexSubImage3D: Ke,
    scissor: Te,
    viewport: be,
    reset: Pt,
  };
}
function $G(n, e, t, i, r, s, o) {
  const a = r.isWebGL2,
    l = r.maxTextures,
    u = r.maxCubemapSize,
    h = r.maxTextureSize,
    d = r.maxSamples,
    p = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    m =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    y = new WeakMap();
  let M;
  const A = new WeakMap();
  let g = !1;
  try {
    g =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function x(H, D) {
    return g ? new OffscreenCanvas(H, D) : ih("canvas");
  }
  function _(H, D, ce, we) {
    let Se = 1;
    if (
      ((H.width > we || H.height > we) &&
        (Se = we / Math.max(H.width, H.height)),
      Se < 1 || D === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && H instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && H instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && H instanceof ImageBitmap)
      ) {
        const Fe = D ? Zm : Math.floor,
          Ke = Fe(Se * H.width),
          Ie = Fe(Se * H.height);
        M === void 0 && (M = x(Ke, Ie));
        const de = ce ? x(Ke, Ie) : M;
        return (
          (de.width = Ke),
          (de.height = Ie),
          de.getContext("2d").drawImage(H, 0, 0, Ke, Ie),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              H.width +
              "x" +
              H.height +
              ") to (" +
              Ke +
              "x" +
              Ie +
              ")."
          ),
          de
        );
      } else
        return (
          "data" in H &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                H.width +
                "x" +
                H.height +
                ")."
            ),
          H
        );
    return H;
  }
  function E(H) {
    return I_(H.width) && I_(H.height);
  }
  function T(H) {
    return a
      ? !1
      : H.wrapS !== Kn ||
          H.wrapT !== Kn ||
          (H.minFilter !== gn && H.minFilter !== sn);
  }
  function R(H, D) {
    return H.generateMipmaps && D && H.minFilter !== gn && H.minFilter !== sn;
  }
  function P(H) {
    n.generateMipmap(H);
  }
  function B(H, D, ce, we, Se = !1) {
    if (a === !1) return D;
    if (H !== null) {
      if (n[H] !== void 0) return n[H];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          H +
          "'"
      );
    }
    let Fe = D;
    return (
      D === n.RED &&
        (ce === n.FLOAT && (Fe = n.R32F),
        ce === n.HALF_FLOAT && (Fe = n.R16F),
        ce === n.UNSIGNED_BYTE && (Fe = n.R8)),
      D === n.RG &&
        (ce === n.FLOAT && (Fe = n.RG32F),
        ce === n.HALF_FLOAT && (Fe = n.RG16F),
        ce === n.UNSIGNED_BYTE && (Fe = n.RG8)),
      D === n.RGBA &&
        (ce === n.FLOAT && (Fe = n.RGBA32F),
        ce === n.HALF_FLOAT && (Fe = n.RGBA16F),
        ce === n.UNSIGNED_BYTE &&
          (Fe = we === mt && Se === !1 ? n.SRGB8_ALPHA8 : n.RGBA8),
        ce === n.UNSIGNED_SHORT_4_4_4_4 && (Fe = n.RGBA4),
        ce === n.UNSIGNED_SHORT_5_5_5_1 && (Fe = n.RGB5_A1)),
      (Fe === n.R16F ||
        Fe === n.R32F ||
        Fe === n.RG16F ||
        Fe === n.RG32F ||
        Fe === n.RGBA16F ||
        Fe === n.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      Fe
    );
  }
  function b(H, D, ce) {
    return R(H, ce) === !0 ||
      (H.isFramebufferTexture && H.minFilter !== gn && H.minFilter !== sn)
      ? Math.log2(Math.max(D.width, D.height)) + 1
      : H.mipmaps !== void 0 && H.mipmaps.length > 0
      ? H.mipmaps.length
      : H.isCompressedTexture && Array.isArray(H.image)
      ? D.mipmaps.length
      : 1;
  }
  function L(H) {
    return H === gn || H === $f || H === Lc ? n.NEAREST : n.LINEAR;
  }
  function z(H) {
    const D = H.target;
    D.removeEventListener("dispose", z), X(D), D.isVideoTexture && y.delete(D);
  }
  function $(H) {
    const D = H.target;
    D.removeEventListener("dispose", $), K(D);
  }
  function X(H) {
    const D = i.get(H);
    if (D.__webglInit === void 0) return;
    const ce = H.source,
      we = A.get(ce);
    if (we) {
      const Se = we[D.__cacheKey];
      Se.usedTimes--,
        Se.usedTimes === 0 && Y(H),
        Object.keys(we).length === 0 && A.delete(ce);
    }
    i.remove(H);
  }
  function Y(H) {
    const D = i.get(H);
    n.deleteTexture(D.__webglTexture);
    const ce = H.source,
      we = A.get(ce);
    delete we[D.__cacheKey], o.memory.textures--;
  }
  function K(H) {
    const D = H.texture,
      ce = i.get(H),
      we = i.get(D);
    if (
      (we.__webglTexture !== void 0 &&
        (n.deleteTexture(we.__webglTexture), o.memory.textures--),
      H.depthTexture && H.depthTexture.dispose(),
      H.isWebGLCubeRenderTarget)
    )
      for (let Se = 0; Se < 6; Se++)
        n.deleteFramebuffer(ce.__webglFramebuffer[Se]),
          ce.__webglDepthbuffer &&
            n.deleteRenderbuffer(ce.__webglDepthbuffer[Se]);
    else {
      if (
        (n.deleteFramebuffer(ce.__webglFramebuffer),
        ce.__webglDepthbuffer && n.deleteRenderbuffer(ce.__webglDepthbuffer),
        ce.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(ce.__webglMultisampledFramebuffer),
        ce.__webglColorRenderbuffer)
      )
        for (let Se = 0; Se < ce.__webglColorRenderbuffer.length; Se++)
          ce.__webglColorRenderbuffer[Se] &&
            n.deleteRenderbuffer(ce.__webglColorRenderbuffer[Se]);
      ce.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(ce.__webglDepthRenderbuffer);
    }
    if (H.isWebGLMultipleRenderTargets)
      for (let Se = 0, Fe = D.length; Se < Fe; Se++) {
        const Ke = i.get(D[Se]);
        Ke.__webglTexture &&
          (n.deleteTexture(Ke.__webglTexture), o.memory.textures--),
          i.remove(D[Se]);
      }
    i.remove(D), i.remove(H);
  }
  let ie = 0;
  function ee() {
    ie = 0;
  }
  function I() {
    const H = ie;
    return (
      H >= l &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            H +
            " texture units while this GPU supports only " +
            l
        ),
      (ie += 1),
      H
    );
  }
  function G(H) {
    const D = [];
    return (
      D.push(H.wrapS),
      D.push(H.wrapT),
      D.push(H.wrapR || 0),
      D.push(H.magFilter),
      D.push(H.minFilter),
      D.push(H.anisotropy),
      D.push(H.internalFormat),
      D.push(H.format),
      D.push(H.type),
      D.push(H.generateMipmaps),
      D.push(H.premultiplyAlpha),
      D.push(H.flipY),
      D.push(H.unpackAlignment),
      D.push(H.colorSpace),
      D.join()
    );
  }
  function k(H, D) {
    const ce = i.get(H);
    if (
      (H.isVideoTexture && vt(H),
      H.isRenderTargetTexture === !1 &&
        H.version > 0 &&
        ce.__version !== H.version)
    ) {
      const we = H.image;
      if (we === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (we.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        ct(ce, H, D);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, ce.__webglTexture, n.TEXTURE0 + D);
  }
  function U(H, D) {
    const ce = i.get(H);
    if (H.version > 0 && ce.__version !== H.version) {
      ct(ce, H, D);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, ce.__webglTexture, n.TEXTURE0 + D);
  }
  function j(H, D) {
    const ce = i.get(H);
    if (H.version > 0 && ce.__version !== H.version) {
      ct(ce, H, D);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, ce.__webglTexture, n.TEXTURE0 + D);
  }
  function he(H, D) {
    const ce = i.get(H);
    if (H.version > 0 && ce.__version !== H.version) {
      tt(ce, H, D);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, ce.__webglTexture, n.TEXTURE0 + D);
  }
  const ae = { [Yo]: n.REPEAT, [Kn]: n.CLAMP_TO_EDGE, [jc]: n.MIRRORED_REPEAT },
    xe = {
      [gn]: n.NEAREST,
      [$f]: n.NEAREST_MIPMAP_NEAREST,
      [Lc]: n.NEAREST_MIPMAP_LINEAR,
      [sn]: n.LINEAR,
      [Dg]: n.LINEAR_MIPMAP_NEAREST,
      [_s]: n.LINEAR_MIPMAP_LINEAR,
    },
    Ae = {
      [q2]: n.NEVER,
      [rB]: n.ALWAYS,
      [Z2]: n.LESS,
      [eB]: n.LEQUAL,
      [$2]: n.EQUAL,
      [iB]: n.GEQUAL,
      [tB]: n.GREATER,
      [nB]: n.NOTEQUAL,
    };
  function Le(H, D, ce) {
    if (
      (ce
        ? (n.texParameteri(H, n.TEXTURE_WRAP_S, ae[D.wrapS]),
          n.texParameteri(H, n.TEXTURE_WRAP_T, ae[D.wrapT]),
          (H === n.TEXTURE_3D || H === n.TEXTURE_2D_ARRAY) &&
            n.texParameteri(H, n.TEXTURE_WRAP_R, ae[D.wrapR]),
          n.texParameteri(H, n.TEXTURE_MAG_FILTER, xe[D.magFilter]),
          n.texParameteri(H, n.TEXTURE_MIN_FILTER, xe[D.minFilter]))
        : (n.texParameteri(H, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
          n.texParameteri(H, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
          (H === n.TEXTURE_3D || H === n.TEXTURE_2D_ARRAY) &&
            n.texParameteri(H, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE),
          (D.wrapS !== Kn || D.wrapT !== Kn) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          n.texParameteri(H, n.TEXTURE_MAG_FILTER, L(D.magFilter)),
          n.texParameteri(H, n.TEXTURE_MIN_FILTER, L(D.minFilter)),
          D.minFilter !== gn &&
            D.minFilter !== sn &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      D.compareFunction &&
        (n.texParameteri(H, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(H, n.TEXTURE_COMPARE_FUNC, Ae[D.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const we = e.get("EXT_texture_filter_anisotropic");
      if (
        D.magFilter === gn ||
        (D.minFilter !== Lc && D.minFilter !== _s) ||
        (D.type === fs && e.has("OES_texture_float_linear") === !1) ||
        (a === !1 &&
          D.type === Xc &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (D.anisotropy > 1 || i.get(D).__currentAnisotropy) &&
        (n.texParameterf(
          H,
          we.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(D.anisotropy, r.getMaxAnisotropy())
        ),
        (i.get(D).__currentAnisotropy = D.anisotropy));
    }
  }
  function Ve(H, D) {
    let ce = !1;
    H.__webglInit === void 0 &&
      ((H.__webglInit = !0), D.addEventListener("dispose", z));
    const we = D.source;
    let Se = A.get(we);
    Se === void 0 && ((Se = {}), A.set(we, Se));
    const Fe = G(D);
    if (Fe !== H.__cacheKey) {
      Se[Fe] === void 0 &&
        ((Se[Fe] = { texture: n.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (ce = !0)),
        Se[Fe].usedTimes++;
      const Ke = Se[H.__cacheKey];
      Ke !== void 0 &&
        (Se[H.__cacheKey].usedTimes--, Ke.usedTimes === 0 && Y(D)),
        (H.__cacheKey = Fe),
        (H.__webglTexture = Se[Fe].texture);
    }
    return ce;
  }
  function ct(H, D, ce) {
    let we = n.TEXTURE_2D;
    (D.isDataArrayTexture || D.isCompressedArrayTexture) &&
      (we = n.TEXTURE_2D_ARRAY),
      D.isData3DTexture && (we = n.TEXTURE_3D);
    const Se = Ve(H, D),
      Fe = D.source;
    t.bindTexture(we, H.__webglTexture, n.TEXTURE0 + ce);
    const Ke = i.get(Fe);
    if (Fe.version !== Ke.__version || Se === !0) {
      t.activeTexture(n.TEXTURE0 + ce),
        n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, D.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, D.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, D.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
      const Ie = T(D) && E(D.image) === !1;
      let de = _(D.image, Ie, !1, h);
      de = kt(D, de);
      const J = E(de) || a,
        fe = s.convert(D.format, D.colorSpace);
      let Te = s.convert(D.type),
        be = B(D.internalFormat, fe, Te, D.colorSpace);
      Le(we, D, J);
      let De;
      const nt = D.mipmaps,
        Pt = a && D.isVideoTexture !== !0,
        Q = Ke.__version === void 0 || Se === !0,
        Pe = b(D, de, J);
      if (D.isDepthTexture)
        (be = n.DEPTH_COMPONENT),
          a
            ? D.type === fs
              ? (be = n.DEPTH_COMPONENT32F)
              : D.type === Gs
              ? (be = n.DEPTH_COMPONENT24)
              : D.type === ko
              ? (be = n.DEPTH24_STENCIL8)
              : (be = n.DEPTH_COMPONENT16)
            : D.type === fs &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          D.format === Ho &&
            be === n.DEPTH_COMPONENT &&
            D.type !== Fg &&
            D.type !== Gs &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (D.type = Gs),
            (Te = s.convert(D.type))),
          D.format === ol &&
            be === n.DEPTH_COMPONENT &&
            ((be = n.DEPTH_STENCIL),
            D.type !== ko &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (D.type = ko),
              (Te = s.convert(D.type)))),
          Q &&
            (Pt
              ? t.texStorage2D(n.TEXTURE_2D, 1, be, de.width, de.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  be,
                  de.width,
                  de.height,
                  0,
                  fe,
                  Te,
                  null
                ));
      else if (D.isDataTexture)
        if (nt.length > 0 && J) {
          Pt &&
            Q &&
            t.texStorage2D(n.TEXTURE_2D, Pe, be, nt[0].width, nt[0].height);
          for (let oe = 0, Be = nt.length; oe < Be; oe++)
            (De = nt[oe]),
              Pt
                ? t.texSubImage2D(
                    n.TEXTURE_2D,
                    oe,
                    0,
                    0,
                    De.width,
                    De.height,
                    fe,
                    Te,
                    De.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    oe,
                    be,
                    De.width,
                    De.height,
                    0,
                    fe,
                    Te,
                    De.data
                  );
          D.generateMipmaps = !1;
        } else
          Pt
            ? (Q && t.texStorage2D(n.TEXTURE_2D, Pe, be, de.width, de.height),
              t.texSubImage2D(
                n.TEXTURE_2D,
                0,
                0,
                0,
                de.width,
                de.height,
                fe,
                Te,
                de.data
              ))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                be,
                de.width,
                de.height,
                0,
                fe,
                Te,
                de.data
              );
      else if (D.isCompressedTexture)
        if (D.isCompressedArrayTexture) {
          Pt &&
            Q &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              Pe,
              be,
              nt[0].width,
              nt[0].height,
              de.depth
            );
          for (let oe = 0, Be = nt.length; oe < Be; oe++)
            (De = nt[oe]),
              D.format !== bi
                ? fe !== null
                  ? Pt
                    ? t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        oe,
                        0,
                        0,
                        0,
                        De.width,
                        De.height,
                        de.depth,
                        fe,
                        De.data,
                        0,
                        0
                      )
                    : t.compressedTexImage3D(
                        n.TEXTURE_2D_ARRAY,
                        oe,
                        be,
                        De.width,
                        De.height,
                        de.depth,
                        0,
                        De.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Pt
                ? t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    oe,
                    0,
                    0,
                    0,
                    De.width,
                    De.height,
                    de.depth,
                    fe,
                    Te,
                    De.data
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    oe,
                    be,
                    De.width,
                    De.height,
                    de.depth,
                    0,
                    fe,
                    Te,
                    De.data
                  );
        } else {
          Pt &&
            Q &&
            t.texStorage2D(n.TEXTURE_2D, Pe, be, nt[0].width, nt[0].height);
          for (let oe = 0, Be = nt.length; oe < Be; oe++)
            (De = nt[oe]),
              D.format !== bi
                ? fe !== null
                  ? Pt
                    ? t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        oe,
                        0,
                        0,
                        De.width,
                        De.height,
                        fe,
                        De.data
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        oe,
                        be,
                        De.width,
                        De.height,
                        0,
                        De.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Pt
                ? t.texSubImage2D(
                    n.TEXTURE_2D,
                    oe,
                    0,
                    0,
                    De.width,
                    De.height,
                    fe,
                    Te,
                    De.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    oe,
                    be,
                    De.width,
                    De.height,
                    0,
                    fe,
                    Te,
                    De.data
                  );
        }
      else if (D.isDataArrayTexture)
        Pt
          ? (Q &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                Pe,
                be,
                de.width,
                de.height,
                de.depth
              ),
            t.texSubImage3D(
              n.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              de.width,
              de.height,
              de.depth,
              fe,
              Te,
              de.data
            ))
          : t.texImage3D(
              n.TEXTURE_2D_ARRAY,
              0,
              be,
              de.width,
              de.height,
              de.depth,
              0,
              fe,
              Te,
              de.data
            );
      else if (D.isData3DTexture)
        Pt
          ? (Q &&
              t.texStorage3D(
                n.TEXTURE_3D,
                Pe,
                be,
                de.width,
                de.height,
                de.depth
              ),
            t.texSubImage3D(
              n.TEXTURE_3D,
              0,
              0,
              0,
              0,
              de.width,
              de.height,
              de.depth,
              fe,
              Te,
              de.data
            ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              be,
              de.width,
              de.height,
              de.depth,
              0,
              fe,
              Te,
              de.data
            );
      else if (D.isFramebufferTexture) {
        if (Q)
          if (Pt) t.texStorage2D(n.TEXTURE_2D, Pe, be, de.width, de.height);
          else {
            let oe = de.width,
              Be = de.height;
            for (let He = 0; He < Pe; He++)
              t.texImage2D(n.TEXTURE_2D, He, be, oe, Be, 0, fe, Te, null),
                (oe >>= 1),
                (Be >>= 1);
          }
      } else if (nt.length > 0 && J) {
        Pt &&
          Q &&
          t.texStorage2D(n.TEXTURE_2D, Pe, be, nt[0].width, nt[0].height);
        for (let oe = 0, Be = nt.length; oe < Be; oe++)
          (De = nt[oe]),
            Pt
              ? t.texSubImage2D(n.TEXTURE_2D, oe, 0, 0, fe, Te, De)
              : t.texImage2D(n.TEXTURE_2D, oe, be, fe, Te, De);
        D.generateMipmaps = !1;
      } else
        Pt
          ? (Q && t.texStorage2D(n.TEXTURE_2D, Pe, be, de.width, de.height),
            t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, fe, Te, de))
          : t.texImage2D(n.TEXTURE_2D, 0, be, fe, Te, de);
      R(D, J) && P(we),
        (Ke.__version = Fe.version),
        D.onUpdate && D.onUpdate(D);
    }
    H.__version = D.version;
  }
  function tt(H, D, ce) {
    if (D.image.length !== 6) return;
    const we = Ve(H, D),
      Se = D.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, H.__webglTexture, n.TEXTURE0 + ce);
    const Fe = i.get(Se);
    if (Se.version !== Fe.__version || we === !0) {
      t.activeTexture(n.TEXTURE0 + ce),
        n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, D.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, D.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, D.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
      const Ke = D.isCompressedTexture || D.image[0].isCompressedTexture,
        Ie = D.image[0] && D.image[0].isDataTexture,
        de = [];
      for (let oe = 0; oe < 6; oe++)
        !Ke && !Ie
          ? (de[oe] = _(D.image[oe], !1, !0, u))
          : (de[oe] = Ie ? D.image[oe].image : D.image[oe]),
          (de[oe] = kt(D, de[oe]));
      const J = de[0],
        fe = E(J) || a,
        Te = s.convert(D.format, D.colorSpace),
        be = s.convert(D.type),
        De = B(D.internalFormat, Te, be, D.colorSpace),
        nt = a && D.isVideoTexture !== !0,
        Pt = Fe.__version === void 0 || we === !0;
      let Q = b(D, J, fe);
      Le(n.TEXTURE_CUBE_MAP, D, fe);
      let Pe;
      if (Ke) {
        nt &&
          Pt &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, Q, De, J.width, J.height);
        for (let oe = 0; oe < 6; oe++) {
          Pe = de[oe].mipmaps;
          for (let Be = 0; Be < Pe.length; Be++) {
            const He = Pe[Be];
            D.format !== bi
              ? Te !== null
                ? nt
                  ? t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                      Be,
                      0,
                      0,
                      He.width,
                      He.height,
                      Te,
                      He.data
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                      Be,
                      De,
                      He.width,
                      He.height,
                      0,
                      He.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : nt
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                  Be,
                  0,
                  0,
                  He.width,
                  He.height,
                  Te,
                  be,
                  He.data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                  Be,
                  De,
                  He.width,
                  He.height,
                  0,
                  Te,
                  be,
                  He.data
                );
          }
        }
      } else {
        (Pe = D.mipmaps),
          nt &&
            Pt &&
            (Pe.length > 0 && Q++,
            t.texStorage2D(
              n.TEXTURE_CUBE_MAP,
              Q,
              De,
              de[0].width,
              de[0].height
            ));
        for (let oe = 0; oe < 6; oe++)
          if (Ie) {
            nt
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                  0,
                  0,
                  0,
                  de[oe].width,
                  de[oe].height,
                  Te,
                  be,
                  de[oe].data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                  0,
                  De,
                  de[oe].width,
                  de[oe].height,
                  0,
                  Te,
                  be,
                  de[oe].data
                );
            for (let Be = 0; Be < Pe.length; Be++) {
              const Tt = Pe[Be].image[oe].image;
              nt
                ? t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                    Be + 1,
                    0,
                    0,
                    Tt.width,
                    Tt.height,
                    Te,
                    be,
                    Tt.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                    Be + 1,
                    De,
                    Tt.width,
                    Tt.height,
                    0,
                    Te,
                    be,
                    Tt.data
                  );
            }
          } else {
            nt
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                  0,
                  0,
                  0,
                  Te,
                  be,
                  de[oe]
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                  0,
                  De,
                  Te,
                  be,
                  de[oe]
                );
            for (let Be = 0; Be < Pe.length; Be++) {
              const He = Pe[Be];
              nt
                ? t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                    Be + 1,
                    0,
                    0,
                    Te,
                    be,
                    He.image[oe]
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                    Be + 1,
                    De,
                    Te,
                    be,
                    He.image[oe]
                  );
            }
          }
      }
      R(D, fe) && P(n.TEXTURE_CUBE_MAP),
        (Fe.__version = Se.version),
        D.onUpdate && D.onUpdate(D);
    }
    H.__version = D.version;
  }
  function Me(H, D, ce, we, Se) {
    const Fe = s.convert(ce.format, ce.colorSpace),
      Ke = s.convert(ce.type),
      Ie = B(ce.internalFormat, Fe, Ke, ce.colorSpace);
    i.get(D).__hasExternalTextures ||
      (Se === n.TEXTURE_3D || Se === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(Se, 0, Ie, D.width, D.height, D.depth, 0, Fe, Ke, null)
        : t.texImage2D(Se, 0, Ie, D.width, D.height, 0, Fe, Ke, null)),
      t.bindFramebuffer(n.FRAMEBUFFER, H),
      Ze(D)
        ? p.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            we,
            Se,
            i.get(ce).__webglTexture,
            0,
            Ge(D)
          )
        : (Se === n.TEXTURE_2D ||
            (Se >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              Se <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(
            n.FRAMEBUFFER,
            we,
            Se,
            i.get(ce).__webglTexture,
            0
          ),
      t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function V(H, D, ce) {
    if (
      (n.bindRenderbuffer(n.RENDERBUFFER, H), D.depthBuffer && !D.stencilBuffer)
    ) {
      let we = n.DEPTH_COMPONENT16;
      if (ce || Ze(D)) {
        const Se = D.depthTexture;
        Se &&
          Se.isDepthTexture &&
          (Se.type === fs
            ? (we = n.DEPTH_COMPONENT32F)
            : Se.type === Gs && (we = n.DEPTH_COMPONENT24));
        const Fe = Ge(D);
        Ze(D)
          ? p.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              Fe,
              we,
              D.width,
              D.height
            )
          : n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              Fe,
              we,
              D.width,
              D.height
            );
      } else n.renderbufferStorage(n.RENDERBUFFER, we, D.width, D.height);
      n.framebufferRenderbuffer(
        n.FRAMEBUFFER,
        n.DEPTH_ATTACHMENT,
        n.RENDERBUFFER,
        H
      );
    } else if (D.depthBuffer && D.stencilBuffer) {
      const we = Ge(D);
      ce && Ze(D) === !1
        ? n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            we,
            n.DEPTH24_STENCIL8,
            D.width,
            D.height
          )
        : Ze(D)
        ? p.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            we,
            n.DEPTH24_STENCIL8,
            D.width,
            D.height
          )
        : n.renderbufferStorage(
            n.RENDERBUFFER,
            n.DEPTH_STENCIL,
            D.width,
            D.height
          ),
        n.framebufferRenderbuffer(
          n.FRAMEBUFFER,
          n.DEPTH_STENCIL_ATTACHMENT,
          n.RENDERBUFFER,
          H
        );
    } else {
      const we =
        D.isWebGLMultipleRenderTargets === !0 ? D.texture : [D.texture];
      for (let Se = 0; Se < we.length; Se++) {
        const Fe = we[Se],
          Ke = s.convert(Fe.format, Fe.colorSpace),
          Ie = s.convert(Fe.type),
          de = B(Fe.internalFormat, Ke, Ie, Fe.colorSpace),
          J = Ge(D);
        ce && Ze(D) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              J,
              de,
              D.width,
              D.height
            )
          : Ze(D)
          ? p.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              J,
              de,
              D.width,
              D.height
            )
          : n.renderbufferStorage(n.RENDERBUFFER, de, D.width, D.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function ye(H, D) {
    if (D && D.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, H),
      !(D.depthTexture && D.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!i.get(D.depthTexture).__webglTexture ||
      D.depthTexture.image.width !== D.width ||
      D.depthTexture.image.height !== D.height) &&
      ((D.depthTexture.image.width = D.width),
      (D.depthTexture.image.height = D.height),
      (D.depthTexture.needsUpdate = !0)),
      k(D.depthTexture, 0);
    const we = i.get(D.depthTexture).__webglTexture,
      Se = Ge(D);
    if (D.depthTexture.format === Ho)
      Ze(D)
        ? p.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            we,
            0,
            Se
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            we,
            0
          );
    else if (D.depthTexture.format === ol)
      Ze(D)
        ? p.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            we,
            0,
            Se
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            we,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function me(H) {
    const D = i.get(H),
      ce = H.isWebGLCubeRenderTarget === !0;
    if (H.depthTexture && !D.__autoAllocateDepthBuffer) {
      if (ce)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      ye(D.__webglFramebuffer, H);
    } else if (ce) {
      D.__webglDepthbuffer = [];
      for (let we = 0; we < 6; we++)
        t.bindFramebuffer(n.FRAMEBUFFER, D.__webglFramebuffer[we]),
          (D.__webglDepthbuffer[we] = n.createRenderbuffer()),
          V(D.__webglDepthbuffer[we], H, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, D.__webglFramebuffer),
        (D.__webglDepthbuffer = n.createRenderbuffer()),
        V(D.__webglDepthbuffer, H, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Ee(H, D, ce) {
    const we = i.get(H);
    D !== void 0 &&
      Me(
        we.__webglFramebuffer,
        H,
        H.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D
      ),
      ce !== void 0 && me(H);
  }
  function _e(H) {
    const D = H.texture,
      ce = i.get(H),
      we = i.get(D);
    H.addEventListener("dispose", $),
      H.isWebGLMultipleRenderTargets !== !0 &&
        (we.__webglTexture === void 0 &&
          (we.__webglTexture = n.createTexture()),
        (we.__version = D.version),
        o.memory.textures++);
    const Se = H.isWebGLCubeRenderTarget === !0,
      Fe = H.isWebGLMultipleRenderTargets === !0,
      Ke = E(H) || a;
    if (Se) {
      ce.__webglFramebuffer = [];
      for (let Ie = 0; Ie < 6; Ie++)
        ce.__webglFramebuffer[Ie] = n.createFramebuffer();
    } else {
      if (((ce.__webglFramebuffer = n.createFramebuffer()), Fe))
        if (r.drawBuffers) {
          const Ie = H.texture;
          for (let de = 0, J = Ie.length; de < J; de++) {
            const fe = i.get(Ie[de]);
            fe.__webglTexture === void 0 &&
              ((fe.__webglTexture = n.createTexture()), o.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (a && H.samples > 0 && Ze(H) === !1) {
        const Ie = Fe ? D : [D];
        (ce.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (ce.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, ce.__webglMultisampledFramebuffer);
        for (let de = 0; de < Ie.length; de++) {
          const J = Ie[de];
          (ce.__webglColorRenderbuffer[de] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, ce.__webglColorRenderbuffer[de]);
          const fe = s.convert(J.format, J.colorSpace),
            Te = s.convert(J.type),
            be = B(
              J.internalFormat,
              fe,
              Te,
              J.colorSpace,
              H.isXRRenderTarget === !0
            ),
            De = Ge(H);
          n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            De,
            be,
            H.width,
            H.height
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + de,
              n.RENDERBUFFER,
              ce.__webglColorRenderbuffer[de]
            );
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null),
          H.depthBuffer &&
            ((ce.__webglDepthRenderbuffer = n.createRenderbuffer()),
            V(ce.__webglDepthRenderbuffer, H, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (Se) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, we.__webglTexture),
        Le(n.TEXTURE_CUBE_MAP, D, Ke);
      for (let Ie = 0; Ie < 6; Ie++)
        Me(
          ce.__webglFramebuffer[Ie],
          H,
          D,
          n.COLOR_ATTACHMENT0,
          n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie
        );
      R(D, Ke) && P(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Fe) {
      const Ie = H.texture;
      for (let de = 0, J = Ie.length; de < J; de++) {
        const fe = Ie[de],
          Te = i.get(fe);
        t.bindTexture(n.TEXTURE_2D, Te.__webglTexture),
          Le(n.TEXTURE_2D, fe, Ke),
          Me(
            ce.__webglFramebuffer,
            H,
            fe,
            n.COLOR_ATTACHMENT0 + de,
            n.TEXTURE_2D
          ),
          R(fe, Ke) && P(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Ie = n.TEXTURE_2D;
      (H.isWebGL3DRenderTarget || H.isWebGLArrayRenderTarget) &&
        (a
          ? (Ie = H.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY)
          : console.error(
              "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
            )),
        t.bindTexture(Ie, we.__webglTexture),
        Le(Ie, D, Ke),
        Me(ce.__webglFramebuffer, H, D, n.COLOR_ATTACHMENT0, Ie),
        R(D, Ke) && P(Ie),
        t.unbindTexture();
    }
    H.depthBuffer && me(H);
  }
  function We(H) {
    const D = E(H) || a,
      ce = H.isWebGLMultipleRenderTargets === !0 ? H.texture : [H.texture];
    for (let we = 0, Se = ce.length; we < Se; we++) {
      const Fe = ce[we];
      if (R(Fe, D)) {
        const Ke = H.isWebGLCubeRenderTarget
            ? n.TEXTURE_CUBE_MAP
            : n.TEXTURE_2D,
          Ie = i.get(Fe).__webglTexture;
        t.bindTexture(Ke, Ie), P(Ke), t.unbindTexture();
      }
    }
  }
  function Oe(H) {
    if (a && H.samples > 0 && Ze(H) === !1) {
      const D = H.isWebGLMultipleRenderTargets ? H.texture : [H.texture],
        ce = H.width,
        we = H.height;
      let Se = n.COLOR_BUFFER_BIT;
      const Fe = [],
        Ke = H.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        Ie = i.get(H),
        de = H.isWebGLMultipleRenderTargets === !0;
      if (de)
        for (let J = 0; J < D.length; J++)
          t.bindFramebuffer(n.FRAMEBUFFER, Ie.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + J,
              n.RENDERBUFFER,
              null
            ),
            t.bindFramebuffer(n.FRAMEBUFFER, Ie.__webglFramebuffer),
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + J,
              n.TEXTURE_2D,
              null,
              0
            );
      t.bindFramebuffer(n.READ_FRAMEBUFFER, Ie.__webglMultisampledFramebuffer),
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ie.__webglFramebuffer);
      for (let J = 0; J < D.length; J++) {
        Fe.push(n.COLOR_ATTACHMENT0 + J), H.depthBuffer && Fe.push(Ke);
        const fe =
          Ie.__ignoreDepthValues !== void 0 ? Ie.__ignoreDepthValues : !1;
        if (
          (fe === !1 &&
            (H.depthBuffer && (Se |= n.DEPTH_BUFFER_BIT),
            H.stencilBuffer && (Se |= n.STENCIL_BUFFER_BIT)),
          de &&
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              Ie.__webglColorRenderbuffer[J]
            ),
          fe === !0 &&
            (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [Ke]),
            n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [Ke])),
          de)
        ) {
          const Te = i.get(D[J]).__webglTexture;
          n.framebufferTexture2D(
            n.DRAW_FRAMEBUFFER,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_2D,
            Te,
            0
          );
        }
        n.blitFramebuffer(0, 0, ce, we, 0, 0, ce, we, Se, n.NEAREST),
          m && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, Fe);
      }
      if (
        (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        de)
      )
        for (let J = 0; J < D.length; J++) {
          t.bindFramebuffer(n.FRAMEBUFFER, Ie.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + J,
              n.RENDERBUFFER,
              Ie.__webglColorRenderbuffer[J]
            );
          const fe = i.get(D[J]).__webglTexture;
          t.bindFramebuffer(n.FRAMEBUFFER, Ie.__webglFramebuffer),
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + J,
              n.TEXTURE_2D,
              fe,
              0
            );
        }
      t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ie.__webglMultisampledFramebuffer);
    }
  }
  function Ge(H) {
    return Math.min(d, H.samples);
  }
  function Ze(H) {
    const D = i.get(H);
    return (
      a &&
      H.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      D.__useRenderToTexture !== !1
    );
  }
  function vt(H) {
    const D = o.render.frame;
    y.get(H) !== D && (y.set(H, D), H.update());
  }
  function kt(H, D) {
    const ce = H.colorSpace,
      we = H.format,
      Se = H.type;
    return (
      H.isCompressedTexture === !0 ||
        H.format === qm ||
        (ce !== Xr &&
          ce !== Go &&
          (ce === mt
            ? a === !1
              ? e.has("EXT_sRGB") === !0 && we === bi
                ? ((H.format = qm),
                  (H.minFilter = sn),
                  (H.generateMipmaps = !1))
                : (D = S1.sRGBToLinear(D))
              : (we !== bi || Se !== ms) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                ce
              ))),
      D
    );
  }
  (this.allocateTextureUnit = I),
    (this.resetTextureUnits = ee),
    (this.setTexture2D = k),
    (this.setTexture2DArray = U),
    (this.setTexture3D = j),
    (this.setTextureCube = he),
    (this.rebindTextures = Ee),
    (this.setupRenderTarget = _e),
    (this.updateRenderTargetMipmap = We),
    (this.updateMultisampleRenderTarget = Oe),
    (this.setupDepthRenderbuffer = me),
    (this.setupFrameBufferTexture = Me),
    (this.useMultisampledRTT = Ze);
}
function gB(n, e, t) {
  const i = t.isWebGL2;
  function r(s, o = Go) {
    let a;
    if (s === ms) return n.UNSIGNED_BYTE;
    if (s === h1) return n.UNSIGNED_SHORT_4_4_4_4;
    if (s === d1) return n.UNSIGNED_SHORT_5_5_5_1;
    if (s === D2) return n.BYTE;
    if (s === F2) return n.SHORT;
    if (s === Fg) return n.UNSIGNED_SHORT;
    if (s === f1) return n.INT;
    if (s === Gs) return n.UNSIGNED_INT;
    if (s === fs) return n.FLOAT;
    if (s === Xc)
      return i
        ? n.HALF_FLOAT
        : ((a = e.get("OES_texture_half_float")),
          a !== null ? a.HALF_FLOAT_OES : null);
    if (s === N2) return n.ALPHA;
    if (s === bi) return n.RGBA;
    if (s === U2) return n.LUMINANCE;
    if (s === O2) return n.LUMINANCE_ALPHA;
    if (s === Ho) return n.DEPTH_COMPONENT;
    if (s === ol) return n.DEPTH_STENCIL;
    if (s === qm)
      return (a = e.get("EXT_sRGB")), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (s === k2) return n.RED;
    if (s === p1) return n.RED_INTEGER;
    if (s === H2) return n.RG;
    if (s === m1) return n.RG_INTEGER;
    if (s === g1) return n.RGBA_INTEGER;
    if (s === hm || s === dm || s === pm || s === mm)
      if (o === mt)
        if (((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)) {
          if (s === hm) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === dm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === pm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === mm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)) {
        if (s === hm) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === dm) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === pm) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === mm) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === c_ || s === u_ || s === f_ || s === h_)
      if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
        if (s === c_) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === u_) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === f_) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === h_) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === z2)
      return (
        (a = e.get("WEBGL_compressed_texture_etc1")),
        a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (s === d_ || s === p_)
      if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
        if (s === d_)
          return o === mt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (s === p_)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === m_ ||
      s === g_ ||
      s === v_ ||
      s === y_ ||
      s === x_ ||
      s === __ ||
      s === A_ ||
      s === S_ ||
      s === M_ ||
      s === E_ ||
      s === w_ ||
      s === T_ ||
      s === C_ ||
      s === b_
    )
      if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
        if (s === m_)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === g_)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === v_)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === y_)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === x_)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === __)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === A_)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === S_)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === M_)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === E_)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === w_)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === T_)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === C_)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === b_)
          return o === mt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === gm)
      if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
        if (s === gm)
          return o === mt
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else return null;
    if (s === G2 || s === R_ || s === P_ || s === B_)
      if (((a = e.get("EXT_texture_compression_rgtc")), a !== null)) {
        if (s === gm) return a.COMPRESSED_RED_RGTC1_EXT;
        if (s === R_) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === P_) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === B_) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return s === ko
      ? i
        ? n.UNSIGNED_INT_24_8
        : ((a = e.get("WEBGL_depth_texture")),
          a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
      : n[s] !== void 0
      ? n[s]
      : null;
  }
  return { convert: r };
}
class vB extends $t {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class Vs extends Rt {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const e4 = { type: "move" };
class yy {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Vs()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Vs()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new F()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new F())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Vs()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new F()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new F())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, i) {
    let r = null,
      s = null,
      o = null;
    const a = this._targetRay,
      l = this._grip,
      u = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (u && e.hand) {
        o = !0;
        for (const M of e.hand.values()) {
          const A = t.getJointPose(M, i),
            g = this._getHandJoint(u, M);
          A !== null &&
            (g.matrix.fromArray(A.transform.matrix),
            g.matrix.decompose(g.position, g.rotation, g.scale),
            (g.matrixWorldNeedsUpdate = !0),
            (g.jointRadius = A.radius)),
            (g.visible = A !== null);
        }
        const h = u.joints["index-finger-tip"],
          d = u.joints["thumb-tip"],
          p = h.position.distanceTo(d.position),
          m = 0.02,
          y = 0.005;
        u.inputState.pinching && p > m + y
          ? ((u.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !u.inputState.pinching &&
            p <= m - y &&
            ((u.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, i)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      a !== null &&
        ((r = t.getPose(e.targetRaySpace, i)),
        r === null && s !== null && (r = s),
        r !== null &&
          (a.matrix.fromArray(r.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(r.linearVelocity))
            : (a.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(r.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(e4)));
    }
    return (
      a !== null && (a.visible = r !== null),
      l !== null && (l.visible = s !== null),
      u !== null && (u.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new Vs();
      (i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[t.jointName] = i),
        e.add(i);
    }
    return e.joints[t.jointName];
  }
}
class yB extends en {
  constructor(e, t, i, r, s, o, a, l, u, h) {
    if (((h = h !== void 0 ? h : Ho), h !== Ho && h !== ol))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    i === void 0 && h === Ho && (i = Gs),
      i === void 0 && h === ol && (i = ko),
      super(null, r, s, o, a, l, h, i, u),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : gn),
      (this.minFilter = l !== void 0 ? l : gn),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class t4 extends Ss {
  constructor(e, t) {
    super();
    const i = this;
    let r = null,
      s = 1,
      o = null,
      a = "local-floor",
      l = 1,
      u = null,
      h = null,
      d = null,
      p = null,
      m = null,
      y = null;
    const M = t.getContextAttributes();
    let A = null,
      g = null;
    const x = [],
      _ = [],
      E = new $t();
    E.layers.enable(1), (E.viewport = new Ut());
    const T = new $t();
    T.layers.enable(2), (T.viewport = new Ut());
    const R = [E, T],
      P = new vB();
    P.layers.enable(1), P.layers.enable(2);
    let B = null,
      b = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (U) {
        let j = x[U];
        return (
          j === void 0 && ((j = new yy()), (x[U] = j)), j.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (U) {
        let j = x[U];
        return j === void 0 && ((j = new yy()), (x[U] = j)), j.getGripSpace();
      }),
      (this.getHand = function (U) {
        let j = x[U];
        return j === void 0 && ((j = new yy()), (x[U] = j)), j.getHandSpace();
      });
    function L(U) {
      const j = _.indexOf(U.inputSource);
      if (j === -1) return;
      const he = x[j];
      he !== void 0 &&
        (he.update(U.inputSource, U.frame, u || o),
        he.dispatchEvent({ type: U.type, data: U.inputSource }));
    }
    function z() {
      r.removeEventListener("select", L),
        r.removeEventListener("selectstart", L),
        r.removeEventListener("selectend", L),
        r.removeEventListener("squeeze", L),
        r.removeEventListener("squeezestart", L),
        r.removeEventListener("squeezeend", L),
        r.removeEventListener("end", z),
        r.removeEventListener("inputsourceschange", $);
      for (let U = 0; U < x.length; U++) {
        const j = _[U];
        j !== null && ((_[U] = null), x[U].disconnect(j));
      }
      (B = null),
        (b = null),
        e.setRenderTarget(A),
        (m = null),
        (p = null),
        (d = null),
        (r = null),
        (g = null),
        k.stop(),
        (i.isPresenting = !1),
        i.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (U) {
      (s = U),
        i.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (U) {
        (a = U),
          i.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return u || o;
      }),
      (this.setReferenceSpace = function (U) {
        u = U;
      }),
      (this.getBaseLayer = function () {
        return p !== null ? p : m;
      }),
      (this.getBinding = function () {
        return d;
      }),
      (this.getFrame = function () {
        return y;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (U) {
        if (((r = U), r !== null)) {
          if (
            ((A = e.getRenderTarget()),
            r.addEventListener("select", L),
            r.addEventListener("selectstart", L),
            r.addEventListener("selectend", L),
            r.addEventListener("squeeze", L),
            r.addEventListener("squeezestart", L),
            r.addEventListener("squeezeend", L),
            r.addEventListener("end", z),
            r.addEventListener("inputsourceschange", $),
            M.xrCompatible !== !0 && (await t.makeXRCompatible()),
            r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const j = {
              antialias: r.renderState.layers === void 0 ? M.antialias : !0,
              alpha: !0,
              depth: M.depth,
              stencil: M.stencil,
              framebufferScaleFactor: s,
            };
            (m = new XRWebGLLayer(r, t, j)),
              r.updateRenderState({ baseLayer: m }),
              (g = new Jr(m.framebufferWidth, m.framebufferHeight, {
                format: bi,
                type: ms,
                colorSpace: e.outputColorSpace,
                stencilBuffer: M.stencil,
              }));
          } else {
            let j = null,
              he = null,
              ae = null;
            M.depth &&
              ((ae = M.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (j = M.stencil ? ol : Ho),
              (he = M.stencil ? ko : Gs));
            const xe = {
              colorFormat: t.RGBA8,
              depthFormat: ae,
              scaleFactor: s,
            };
            (d = new XRWebGLBinding(r, t)),
              (p = d.createProjectionLayer(xe)),
              r.updateRenderState({ layers: [p] }),
              (g = new Jr(p.textureWidth, p.textureHeight, {
                format: bi,
                type: ms,
                depthTexture: new yB(
                  p.textureWidth,
                  p.textureHeight,
                  he,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  j
                ),
                stencilBuffer: M.stencil,
                colorSpace: e.outputColorSpace,
                samples: M.antialias ? 4 : 0,
              }));
            const Ae = e.properties.get(g);
            Ae.__ignoreDepthValues = p.ignoreDepthValues;
          }
          (g.isXRRenderTarget = !0),
            this.setFoveation(l),
            (u = null),
            (o = await r.requestReferenceSpace(a)),
            k.setContext(r),
            k.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (r !== null) return r.environmentBlendMode;
      });
    function $(U) {
      for (let j = 0; j < U.removed.length; j++) {
        const he = U.removed[j],
          ae = _.indexOf(he);
        ae >= 0 && ((_[ae] = null), x[ae].disconnect(he));
      }
      for (let j = 0; j < U.added.length; j++) {
        const he = U.added[j];
        let ae = _.indexOf(he);
        if (ae === -1) {
          for (let Ae = 0; Ae < x.length; Ae++)
            if (Ae >= _.length) {
              _.push(he), (ae = Ae);
              break;
            } else if (_[Ae] === null) {
              (_[Ae] = he), (ae = Ae);
              break;
            }
          if (ae === -1) break;
        }
        const xe = x[ae];
        xe && xe.connect(he);
      }
    }
    const X = new F(),
      Y = new F();
    function K(U, j, he) {
      X.setFromMatrixPosition(j.matrixWorld),
        Y.setFromMatrixPosition(he.matrixWorld);
      const ae = X.distanceTo(Y),
        xe = j.projectionMatrix.elements,
        Ae = he.projectionMatrix.elements,
        Le = xe[14] / (xe[10] - 1),
        Ve = xe[14] / (xe[10] + 1),
        ct = (xe[9] + 1) / xe[5],
        tt = (xe[9] - 1) / xe[5],
        Me = (xe[8] - 1) / xe[0],
        V = (Ae[8] + 1) / Ae[0],
        ye = Le * Me,
        me = Le * V,
        Ee = ae / (-Me + V),
        _e = Ee * -Me;
      j.matrixWorld.decompose(U.position, U.quaternion, U.scale),
        U.translateX(_e),
        U.translateZ(Ee),
        U.matrixWorld.compose(U.position, U.quaternion, U.scale),
        U.matrixWorldInverse.copy(U.matrixWorld).invert();
      const We = Le + Ee,
        Oe = Ve + Ee,
        Ge = ye - _e,
        Ze = me + (ae - _e),
        vt = ((ct * Ve) / Oe) * We,
        kt = ((tt * Ve) / Oe) * We;
      U.projectionMatrix.makePerspective(Ge, Ze, vt, kt, We, Oe),
        U.projectionMatrixInverse.copy(U.projectionMatrix).invert();
    }
    function ie(U, j) {
      j === null
        ? U.matrixWorld.copy(U.matrix)
        : U.matrixWorld.multiplyMatrices(j.matrixWorld, U.matrix),
        U.matrixWorldInverse.copy(U.matrixWorld).invert();
    }
    this.updateCamera = function (U) {
      if (r === null) return;
      (P.near = T.near = E.near = U.near),
        (P.far = T.far = E.far = U.far),
        (B !== P.near || b !== P.far) &&
          (r.updateRenderState({ depthNear: P.near, depthFar: P.far }),
          (B = P.near),
          (b = P.far));
      const j = U.parent,
        he = P.cameras;
      ie(P, j);
      for (let ae = 0; ae < he.length; ae++) ie(he[ae], j);
      he.length === 2
        ? K(P, E, T)
        : P.projectionMatrix.copy(E.projectionMatrix),
        ee(U, P, j);
    };
    function ee(U, j, he) {
      he === null
        ? U.matrix.copy(j.matrixWorld)
        : (U.matrix.copy(he.matrixWorld),
          U.matrix.invert(),
          U.matrix.multiply(j.matrixWorld)),
        U.matrix.decompose(U.position, U.quaternion, U.scale),
        U.updateMatrixWorld(!0);
      const ae = U.children;
      for (let xe = 0, Ae = ae.length; xe < Ae; xe++)
        ae[xe].updateMatrixWorld(!0);
      U.projectionMatrix.copy(j.projectionMatrix),
        U.projectionMatrixInverse.copy(j.projectionMatrixInverse),
        U.isPerspectiveCamera &&
          ((U.fov = Kc * 2 * Math.atan(1 / U.projectionMatrix.elements[5])),
          (U.zoom = 1));
    }
    (this.getCamera = function () {
      return P;
    }),
      (this.getFoveation = function () {
        if (!(p === null && m === null)) return l;
      }),
      (this.setFoveation = function (U) {
        (l = U),
          p !== null && (p.fixedFoveation = U),
          m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = U);
      });
    let I = null;
    function G(U, j) {
      if (((h = j.getViewerPose(u || o)), (y = j), h !== null)) {
        const he = h.views;
        m !== null &&
          (e.setRenderTargetFramebuffer(g, m.framebuffer),
          e.setRenderTarget(g));
        let ae = !1;
        he.length !== P.cameras.length && ((P.cameras.length = 0), (ae = !0));
        for (let xe = 0; xe < he.length; xe++) {
          const Ae = he[xe];
          let Le = null;
          if (m !== null) Le = m.getViewport(Ae);
          else {
            const ct = d.getViewSubImage(p, Ae);
            (Le = ct.viewport),
              xe === 0 &&
                (e.setRenderTargetTextures(
                  g,
                  ct.colorTexture,
                  p.ignoreDepthValues ? void 0 : ct.depthStencilTexture
                ),
                e.setRenderTarget(g));
          }
          let Ve = R[xe];
          Ve === void 0 &&
            ((Ve = new $t()),
            Ve.layers.enable(xe),
            (Ve.viewport = new Ut()),
            (R[xe] = Ve)),
            Ve.matrix.fromArray(Ae.transform.matrix),
            Ve.matrix.decompose(Ve.position, Ve.quaternion, Ve.scale),
            Ve.projectionMatrix.fromArray(Ae.projectionMatrix),
            Ve.projectionMatrixInverse.copy(Ve.projectionMatrix).invert(),
            Ve.viewport.set(Le.x, Le.y, Le.width, Le.height),
            xe === 0 &&
              (P.matrix.copy(Ve.matrix),
              P.matrix.decompose(P.position, P.quaternion, P.scale)),
            ae === !0 && P.cameras.push(Ve);
        }
      }
      for (let he = 0; he < x.length; he++) {
        const ae = _[he],
          xe = x[he];
        ae !== null && xe !== void 0 && xe.update(ae, j, u || o);
      }
      I && I(U, j),
        j.detectedPlanes &&
          i.dispatchEvent({ type: "planesdetected", data: j }),
        (y = null);
    }
    const k = new fB();
    k.setAnimationLoop(G),
      (this.setAnimationLoop = function (U) {
        I = U;
      }),
      (this.dispose = function () {});
  }
}
function n4(n, e) {
  function t(A, g) {
    A.matrixAutoUpdate === !0 && A.updateMatrix(), g.value.copy(A.matrix);
  }
  function i(A, g) {
    g.color.getRGB(A.fogColor.value, cB(n)),
      g.isFog
        ? ((A.fogNear.value = g.near), (A.fogFar.value = g.far))
        : g.isFogExp2 && (A.fogDensity.value = g.density);
  }
  function r(A, g, x, _, E) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial
      ? s(A, g)
      : g.isMeshToonMaterial
      ? (s(A, g), d(A, g))
      : g.isMeshPhongMaterial
      ? (s(A, g), h(A, g))
      : g.isMeshStandardMaterial
      ? (s(A, g), p(A, g), g.isMeshPhysicalMaterial && m(A, g, E))
      : g.isMeshMatcapMaterial
      ? (s(A, g), y(A, g))
      : g.isMeshDepthMaterial
      ? s(A, g)
      : g.isMeshDistanceMaterial
      ? (s(A, g), M(A, g))
      : g.isMeshNormalMaterial
      ? s(A, g)
      : g.isLineBasicMaterial
      ? (o(A, g), g.isLineDashedMaterial && a(A, g))
      : g.isPointsMaterial
      ? l(A, g, x, _)
      : g.isSpriteMaterial
      ? u(A, g)
      : g.isShadowMaterial
      ? (A.color.value.copy(g.color), (A.opacity.value = g.opacity))
      : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function s(A, g) {
    (A.opacity.value = g.opacity),
      g.color && A.diffuse.value.copy(g.color),
      g.emissive &&
        A.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
      g.map && ((A.map.value = g.map), t(g.map, A.mapTransform)),
      g.alphaMap &&
        ((A.alphaMap.value = g.alphaMap), t(g.alphaMap, A.alphaMapTransform)),
      g.bumpMap &&
        ((A.bumpMap.value = g.bumpMap),
        t(g.bumpMap, A.bumpMapTransform),
        (A.bumpScale.value = g.bumpScale),
        g.side === xi && (A.bumpScale.value *= -1)),
      g.normalMap &&
        ((A.normalMap.value = g.normalMap),
        t(g.normalMap, A.normalMapTransform),
        A.normalScale.value.copy(g.normalScale),
        g.side === xi && A.normalScale.value.negate()),
      g.displacementMap &&
        ((A.displacementMap.value = g.displacementMap),
        t(g.displacementMap, A.displacementMapTransform),
        (A.displacementScale.value = g.displacementScale),
        (A.displacementBias.value = g.displacementBias)),
      g.emissiveMap &&
        ((A.emissiveMap.value = g.emissiveMap),
        t(g.emissiveMap, A.emissiveMapTransform)),
      g.specularMap &&
        ((A.specularMap.value = g.specularMap),
        t(g.specularMap, A.specularMapTransform)),
      g.alphaTest > 0 && (A.alphaTest.value = g.alphaTest);
    const x = e.get(g).envMap;
    if (
      (x &&
        ((A.envMap.value = x),
        (A.flipEnvMap.value =
          x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1),
        (A.reflectivity.value = g.reflectivity),
        (A.ior.value = g.ior),
        (A.refractionRatio.value = g.refractionRatio)),
      g.lightMap)
    ) {
      A.lightMap.value = g.lightMap;
      const _ = n.useLegacyLights === !0 ? Math.PI : 1;
      (A.lightMapIntensity.value = g.lightMapIntensity * _),
        t(g.lightMap, A.lightMapTransform);
    }
    g.aoMap &&
      ((A.aoMap.value = g.aoMap),
      (A.aoMapIntensity.value = g.aoMapIntensity),
      t(g.aoMap, A.aoMapTransform));
  }
  function o(A, g) {
    A.diffuse.value.copy(g.color),
      (A.opacity.value = g.opacity),
      g.map && ((A.map.value = g.map), t(g.map, A.mapTransform));
  }
  function a(A, g) {
    (A.dashSize.value = g.dashSize),
      (A.totalSize.value = g.dashSize + g.gapSize),
      (A.scale.value = g.scale);
  }
  function l(A, g, x, _) {
    A.diffuse.value.copy(g.color),
      (A.opacity.value = g.opacity),
      (A.size.value = g.size * x),
      (A.scale.value = _ * 0.5),
      g.map && ((A.map.value = g.map), t(g.map, A.uvTransform)),
      g.alphaMap &&
        ((A.alphaMap.value = g.alphaMap), t(g.alphaMap, A.alphaMapTransform)),
      g.alphaTest > 0 && (A.alphaTest.value = g.alphaTest);
  }
  function u(A, g) {
    A.diffuse.value.copy(g.color),
      (A.opacity.value = g.opacity),
      (A.rotation.value = g.rotation),
      g.map && ((A.map.value = g.map), t(g.map, A.mapTransform)),
      g.alphaMap &&
        ((A.alphaMap.value = g.alphaMap), t(g.alphaMap, A.alphaMapTransform)),
      g.alphaTest > 0 && (A.alphaTest.value = g.alphaTest);
  }
  function h(A, g) {
    A.specular.value.copy(g.specular),
      (A.shininess.value = Math.max(g.shininess, 1e-4));
  }
  function d(A, g) {
    g.gradientMap && (A.gradientMap.value = g.gradientMap);
  }
  function p(A, g) {
    (A.metalness.value = g.metalness),
      g.metalnessMap &&
        ((A.metalnessMap.value = g.metalnessMap),
        t(g.metalnessMap, A.metalnessMapTransform)),
      (A.roughness.value = g.roughness),
      g.roughnessMap &&
        ((A.roughnessMap.value = g.roughnessMap),
        t(g.roughnessMap, A.roughnessMapTransform)),
      e.get(g).envMap && (A.envMapIntensity.value = g.envMapIntensity);
  }
  function m(A, g, x) {
    (A.ior.value = g.ior),
      g.sheen > 0 &&
        (A.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
        (A.sheenRoughness.value = g.sheenRoughness),
        g.sheenColorMap &&
          ((A.sheenColorMap.value = g.sheenColorMap),
          t(g.sheenColorMap, A.sheenColorMapTransform)),
        g.sheenRoughnessMap &&
          ((A.sheenRoughnessMap.value = g.sheenRoughnessMap),
          t(g.sheenRoughnessMap, A.sheenRoughnessMapTransform))),
      g.clearcoat > 0 &&
        ((A.clearcoat.value = g.clearcoat),
        (A.clearcoatRoughness.value = g.clearcoatRoughness),
        g.clearcoatMap &&
          ((A.clearcoatMap.value = g.clearcoatMap),
          t(g.clearcoatMap, A.clearcoatMapTransform)),
        g.clearcoatRoughnessMap &&
          ((A.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
          t(g.clearcoatRoughnessMap, A.clearcoatRoughnessMapTransform)),
        g.clearcoatNormalMap &&
          ((A.clearcoatNormalMap.value = g.clearcoatNormalMap),
          t(g.clearcoatNormalMap, A.clearcoatNormalMapTransform),
          A.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
          g.side === xi && A.clearcoatNormalScale.value.negate())),
      g.iridescence > 0 &&
        ((A.iridescence.value = g.iridescence),
        (A.iridescenceIOR.value = g.iridescenceIOR),
        (A.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0]),
        (A.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1]),
        g.iridescenceMap &&
          ((A.iridescenceMap.value = g.iridescenceMap),
          t(g.iridescenceMap, A.iridescenceMapTransform)),
        g.iridescenceThicknessMap &&
          ((A.iridescenceThicknessMap.value = g.iridescenceThicknessMap),
          t(g.iridescenceThicknessMap, A.iridescenceThicknessMapTransform))),
      g.transmission > 0 &&
        ((A.transmission.value = g.transmission),
        (A.transmissionSamplerMap.value = x.texture),
        A.transmissionSamplerSize.value.set(x.width, x.height),
        g.transmissionMap &&
          ((A.transmissionMap.value = g.transmissionMap),
          t(g.transmissionMap, A.transmissionMapTransform)),
        (A.thickness.value = g.thickness),
        g.thicknessMap &&
          ((A.thicknessMap.value = g.thicknessMap),
          t(g.thicknessMap, A.thicknessMapTransform)),
        (A.attenuationDistance.value = g.attenuationDistance),
        A.attenuationColor.value.copy(g.attenuationColor)),
      g.anisotropy > 0 &&
        (A.anisotropyVector.value.set(
          g.anisotropy * Math.cos(g.anisotropyRotation),
          g.anisotropy * Math.sin(g.anisotropyRotation)
        ),
        g.anisotropyMap &&
          ((A.anisotropyMap.value = g.anisotropyMap),
          t(g.anisotropyMap, A.anisotropyMapTransform))),
      (A.specularIntensity.value = g.specularIntensity),
      A.specularColor.value.copy(g.specularColor),
      g.specularColorMap &&
        ((A.specularColorMap.value = g.specularColorMap),
        t(g.specularColorMap, A.specularColorMapTransform)),
      g.specularIntensityMap &&
        ((A.specularIntensityMap.value = g.specularIntensityMap),
        t(g.specularIntensityMap, A.specularIntensityMapTransform));
  }
  function y(A, g) {
    g.matcap && (A.matcap.value = g.matcap);
  }
  function M(A, g) {
    const x = e.get(g).light;
    A.referencePosition.value.setFromMatrixPosition(x.matrixWorld),
      (A.nearDistance.value = x.shadow.camera.near),
      (A.farDistance.value = x.shadow.camera.far);
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r };
}
function i4(n, e, t, i) {
  let r = {},
    s = {},
    o = [];
  const a = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(x, _) {
    const E = _.program;
    i.uniformBlockBinding(x, E);
  }
  function u(x, _) {
    let E = r[x.id];
    E === void 0 &&
      (y(x), (E = h(x)), (r[x.id] = E), x.addEventListener("dispose", A));
    const T = _.program;
    i.updateUBOMapping(x, T);
    const R = e.render.frame;
    s[x.id] !== R && (p(x), (s[x.id] = R));
  }
  function h(x) {
    const _ = d();
    x.__bindingPointIndex = _;
    const E = n.createBuffer(),
      T = x.__size,
      R = x.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, E),
      n.bufferData(n.UNIFORM_BUFFER, T, R),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, _, E),
      E
    );
  }
  function d() {
    for (let x = 0; x < a; x++) if (o.indexOf(x) === -1) return o.push(x), x;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function p(x) {
    const _ = r[x.id],
      E = x.uniforms,
      T = x.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, _);
    for (let R = 0, P = E.length; R < P; R++) {
      const B = E[R];
      if (m(B, R, T) === !0) {
        const b = B.__offset,
          L = Array.isArray(B.value) ? B.value : [B.value];
        let z = 0;
        for (let $ = 0; $ < L.length; $++) {
          const X = L[$],
            Y = M(X);
          typeof X == "number"
            ? ((B.__data[0] = X),
              n.bufferSubData(n.UNIFORM_BUFFER, b + z, B.__data))
            : X.isMatrix3
            ? ((B.__data[0] = X.elements[0]),
              (B.__data[1] = X.elements[1]),
              (B.__data[2] = X.elements[2]),
              (B.__data[3] = X.elements[0]),
              (B.__data[4] = X.elements[3]),
              (B.__data[5] = X.elements[4]),
              (B.__data[6] = X.elements[5]),
              (B.__data[7] = X.elements[0]),
              (B.__data[8] = X.elements[6]),
              (B.__data[9] = X.elements[7]),
              (B.__data[10] = X.elements[8]),
              (B.__data[11] = X.elements[0]))
            : (X.toArray(B.__data, z),
              (z += Y.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        n.bufferSubData(n.UNIFORM_BUFFER, b, B.__data);
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function m(x, _, E) {
    const T = x.value;
    if (E[_] === void 0) {
      if (typeof T == "number") E[_] = T;
      else {
        const R = Array.isArray(T) ? T : [T],
          P = [];
        for (let B = 0; B < R.length; B++) P.push(R[B].clone());
        E[_] = P;
      }
      return !0;
    } else if (typeof T == "number") {
      if (E[_] !== T) return (E[_] = T), !0;
    } else {
      const R = Array.isArray(E[_]) ? E[_] : [E[_]],
        P = Array.isArray(T) ? T : [T];
      for (let B = 0; B < R.length; B++) {
        const b = R[B];
        if (b.equals(P[B]) === !1) return b.copy(P[B]), !0;
      }
    }
    return !1;
  }
  function y(x) {
    const _ = x.uniforms;
    let E = 0;
    const T = 16;
    let R = 0;
    for (let P = 0, B = _.length; P < B; P++) {
      const b = _[P],
        L = { boundary: 0, storage: 0 },
        z = Array.isArray(b.value) ? b.value : [b.value];
      for (let $ = 0, X = z.length; $ < X; $++) {
        const Y = z[$],
          K = M(Y);
        (L.boundary += K.boundary), (L.storage += K.storage);
      }
      if (
        ((b.__data = new Float32Array(
          L.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (b.__offset = E),
        P > 0)
      ) {
        R = E % T;
        const $ = T - R;
        R !== 0 && $ - L.boundary < 0 && ((E += T - R), (b.__offset = E));
      }
      E += L.storage;
    }
    return (
      (R = E % T), R > 0 && (E += T - R), (x.__size = E), (x.__cache = {}), this
    );
  }
  function M(x) {
    const _ = { boundary: 0, storage: 0 };
    return (
      typeof x == "number"
        ? ((_.boundary = 4), (_.storage = 4))
        : x.isVector2
        ? ((_.boundary = 8), (_.storage = 8))
        : x.isVector3 || x.isColor
        ? ((_.boundary = 16), (_.storage = 12))
        : x.isVector4
        ? ((_.boundary = 16), (_.storage = 16))
        : x.isMatrix3
        ? ((_.boundary = 48), (_.storage = 48))
        : x.isMatrix4
        ? ((_.boundary = 64), (_.storage = 64))
        : x.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            x
          ),
      _
    );
  }
  function A(x) {
    const _ = x.target;
    _.removeEventListener("dispose", A);
    const E = o.indexOf(_.__bindingPointIndex);
    o.splice(E, 1), n.deleteBuffer(r[_.id]), delete r[_.id], delete s[_.id];
  }
  function g() {
    for (const x in r) n.deleteBuffer(r[x]);
    (o = []), (r = {}), (s = {});
  }
  return { bind: l, update: u, dispose: g };
}
function r4() {
  const n = ih("canvas");
  return (n.style.display = "block"), n;
}
class B1 {
  constructor(e = {}) {
    const {
      canvas: t = r4(),
      context: i = null,
      depth: r = !0,
      stencil: s = !0,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: d = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let p;
    i !== null ? (p = i.getContextAttributes().alpha) : (p = o);
    const m = new Uint32Array(4),
      y = new Int32Array(4);
    let M = null,
      A = null;
    const g = [],
      x = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.outputColorSpace = mt),
      (this.useLegacyLights = !0),
      (this.toneMapping = Vr),
      (this.toneMappingExposure = 1);
    const _ = this;
    let E = !1,
      T = 0,
      R = 0,
      P = null,
      B = -1,
      b = null;
    const L = new Ut(),
      z = new Ut();
    let $ = null;
    const X = new Ue(0);
    let Y = 0,
      K = t.width,
      ie = t.height,
      ee = 1,
      I = null,
      G = null;
    const k = new Ut(0, 0, K, ie),
      U = new Ut(0, 0, K, ie);
    let j = !1;
    const he = new Og();
    let ae = !1,
      xe = !1,
      Ae = null;
    const Le = new rt(),
      Ve = new ve(),
      ct = new F(),
      tt = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function Me() {
      return P === null ? ee : 1;
    }
    let V = i;
    function ye(N, se) {
      for (let pe = 0; pe < N.length; pe++) {
        const ne = N[pe],
          ge = t.getContext(ne, se);
        if (ge !== null) return ge;
      }
      return null;
    }
    try {
      const N = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: u,
        powerPreference: h,
        failIfMajorPerformanceCaveat: d,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${Sh}`),
        t.addEventListener("webglcontextlost", Pe, !1),
        t.addEventListener("webglcontextrestored", oe, !1),
        t.addEventListener("webglcontextcreationerror", Be, !1),
        V === null)
      ) {
        const se = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (_.isWebGL1Renderer === !0 && se.shift(), (V = ye(se, N)), V === null)
        )
          throw ye(se)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" &&
        V instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
        ),
        V.getShaderPrecisionFormat === void 0 &&
          (V.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
    } catch (N) {
      throw (console.error("THREE.WebGLRenderer: " + N.message), N);
    }
    let me,
      Ee,
      _e,
      We,
      Oe,
      Ge,
      Ze,
      vt,
      kt,
      H,
      D,
      ce,
      we,
      Se,
      Fe,
      Ke,
      Ie,
      de,
      J,
      fe,
      Te,
      be,
      De,
      nt;
    function Pt() {
      (me = new xz(V)),
        (Ee = new dz(V, me, e)),
        me.init(Ee),
        (be = new gB(V, me, Ee)),
        (_e = new ZG(V, me, Ee)),
        (We = new Sz(V)),
        (Oe = new HG()),
        (Ge = new $G(V, me, _e, Oe, Ee, be, We)),
        (Ze = new mz(_)),
        (vt = new yz(_)),
        (kt = new LO(V, Ee)),
        (De = new fz(V, me, kt, Ee)),
        (H = new _z(V, kt, We, De)),
        (D = new Tz(V, H, kt, We)),
        (J = new wz(V, Ee, Ge)),
        (Ke = new pz(Oe)),
        (ce = new kG(_, Ze, vt, me, Ee, De, Ke)),
        (we = new n4(_, Oe)),
        (Se = new GG()),
        (Fe = new KG(me, Ee)),
        (de = new uz(_, Ze, vt, _e, D, p, l)),
        (Ie = new qG(_, D, Ee)),
        (nt = new i4(V, We, Ee, _e)),
        (fe = new hz(V, me, We, Ee)),
        (Te = new Az(V, me, We, Ee)),
        (We.programs = ce.programs),
        (_.capabilities = Ee),
        (_.extensions = me),
        (_.properties = Oe),
        (_.renderLists = Se),
        (_.shadowMap = Ie),
        (_.state = _e),
        (_.info = We);
    }
    Pt();
    const Q = new t4(_, V);
    (this.xr = Q),
      (this.getContext = function () {
        return V;
      }),
      (this.getContextAttributes = function () {
        return V.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const N = me.get("WEBGL_lose_context");
        N && N.loseContext();
      }),
      (this.forceContextRestore = function () {
        const N = me.get("WEBGL_lose_context");
        N && N.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return ee;
      }),
      (this.setPixelRatio = function (N) {
        N !== void 0 && ((ee = N), this.setSize(K, ie, !1));
      }),
      (this.getSize = function (N) {
        return N.set(K, ie);
      }),
      (this.setSize = function (N, se, pe = !0) {
        if (Q.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (K = N),
          (ie = se),
          (t.width = Math.floor(N * ee)),
          (t.height = Math.floor(se * ee)),
          pe === !0 &&
            ((t.style.width = N + "px"), (t.style.height = se + "px")),
          this.setViewport(0, 0, N, se);
      }),
      (this.getDrawingBufferSize = function (N) {
        return N.set(K * ee, ie * ee).floor();
      }),
      (this.setDrawingBufferSize = function (N, se, pe) {
        (K = N),
          (ie = se),
          (ee = pe),
          (t.width = Math.floor(N * pe)),
          (t.height = Math.floor(se * pe)),
          this.setViewport(0, 0, N, se);
      }),
      (this.getCurrentViewport = function (N) {
        return N.copy(L);
      }),
      (this.getViewport = function (N) {
        return N.copy(k);
      }),
      (this.setViewport = function (N, se, pe, ne) {
        N.isVector4 ? k.set(N.x, N.y, N.z, N.w) : k.set(N, se, pe, ne),
          _e.viewport(L.copy(k).multiplyScalar(ee).floor());
      }),
      (this.getScissor = function (N) {
        return N.copy(U);
      }),
      (this.setScissor = function (N, se, pe, ne) {
        N.isVector4 ? U.set(N.x, N.y, N.z, N.w) : U.set(N, se, pe, ne),
          _e.scissor(z.copy(U).multiplyScalar(ee).floor());
      }),
      (this.getScissorTest = function () {
        return j;
      }),
      (this.setScissorTest = function (N) {
        _e.setScissorTest((j = N));
      }),
      (this.setOpaqueSort = function (N) {
        I = N;
      }),
      (this.setTransparentSort = function (N) {
        G = N;
      }),
      (this.getClearColor = function (N) {
        return N.copy(de.getClearColor());
      }),
      (this.setClearColor = function () {
        de.setClearColor.apply(de, arguments);
      }),
      (this.getClearAlpha = function () {
        return de.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        de.setClearAlpha.apply(de, arguments);
      }),
      (this.clear = function (N = !0, se = !0, pe = !0) {
        let ne = 0;
        if (N) {
          let ge = !1;
          if (P !== null) {
            const Xe = P.texture.format;
            ge = Xe === g1 || Xe === m1 || Xe === p1;
          }
          if (ge) {
            const Xe = P.texture.type,
              $e =
                Xe === ms ||
                Xe === Gs ||
                Xe === Fg ||
                Xe === ko ||
                Xe === h1 ||
                Xe === d1,
              st = de.getClearColor(),
              ot = de.getClearAlpha(),
              St = st.r,
              at = st.g,
              lt = st.b;
            $e
              ? ((m[0] = St),
                (m[1] = at),
                (m[2] = lt),
                (m[3] = ot),
                V.clearBufferuiv(V.COLOR, 0, m))
              : ((y[0] = St),
                (y[1] = at),
                (y[2] = lt),
                (y[3] = ot),
                V.clearBufferiv(V.COLOR, 0, y));
          } else ne |= V.COLOR_BUFFER_BIT;
        }
        se && (ne |= V.DEPTH_BUFFER_BIT),
          pe && (ne |= V.STENCIL_BUFFER_BIT),
          V.clear(ne);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", Pe, !1),
          t.removeEventListener("webglcontextrestored", oe, !1),
          t.removeEventListener("webglcontextcreationerror", Be, !1),
          Se.dispose(),
          Fe.dispose(),
          Oe.dispose(),
          Ze.dispose(),
          vt.dispose(),
          D.dispose(),
          De.dispose(),
          nt.dispose(),
          ce.dispose(),
          Q.dispose(),
          Q.removeEventListener("sessionstart", Xt),
          Q.removeEventListener("sessionend", Fi),
          Ae && (Ae.dispose(), (Ae = null)),
          jn.stop();
      });
    function Pe(N) {
      N.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (E = !0);
    }
    function oe() {
      console.log("THREE.WebGLRenderer: Context Restored."), (E = !1);
      const N = We.autoReset,
        se = Ie.enabled,
        pe = Ie.autoUpdate,
        ne = Ie.needsUpdate,
        ge = Ie.type;
      Pt(),
        (We.autoReset = N),
        (Ie.enabled = se),
        (Ie.autoUpdate = pe),
        (Ie.needsUpdate = ne),
        (Ie.type = ge);
    }
    function Be(N) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        N.statusMessage
      );
    }
    function He(N) {
      const se = N.target;
      se.removeEventListener("dispose", He), Tt(se);
    }
    function Tt(N) {
      Vt(N), Oe.remove(N);
    }
    function Vt(N) {
      const se = Oe.get(N).programs;
      se !== void 0 &&
        (se.forEach(function (pe) {
          ce.releaseProgram(pe);
        }),
        N.isShaderMaterial && ce.releaseShaderCache(N));
    }
    (this.renderBufferDirect = function (N, se, pe, ne, ge, Xe) {
      se === null && (se = tt);
      const $e = ge.isMesh && ge.matrixWorld.determinant() < 0,
        st = y0(N, se, pe, ne, ge);
      _e.setMaterial(ne, $e);
      let ot = pe.index,
        St = 1;
      ne.wireframe === !0 && ((ot = H.getWireframeAttribute(pe)), (St = 2));
      const at = pe.drawRange,
        lt = pe.attributes.position;
      let Wt = at.start * St,
        Jt = (at.start + at.count) * St;
      Xe !== null &&
        ((Wt = Math.max(Wt, Xe.start * St)),
        (Jt = Math.min(Jt, (Xe.start + Xe.count) * St))),
        ot !== null
          ? ((Wt = Math.max(Wt, 0)), (Jt = Math.min(Jt, ot.count)))
          : lt != null &&
            ((Wt = Math.max(Wt, 0)), (Jt = Math.min(Jt, lt.count)));
      const Ni = Jt - Wt;
      if (Ni < 0 || Ni === 1 / 0) return;
      De.setup(ge, ne, st, pe, ot);
      let Ui,
        zt = fe;
      if (
        (ot !== null && ((Ui = kt.get(ot)), (zt = Te), zt.setIndex(Ui)),
        ge.isMesh)
      )
        ne.wireframe === !0
          ? (_e.setLineWidth(ne.wireframeLinewidth * Me()), zt.setMode(V.LINES))
          : zt.setMode(V.TRIANGLES);
      else if (ge.isLine) {
        let ft = ne.linewidth;
        ft === void 0 && (ft = 1),
          _e.setLineWidth(ft * Me()),
          ge.isLineSegments
            ? zt.setMode(V.LINES)
            : ge.isLineLoop
            ? zt.setMode(V.LINE_LOOP)
            : zt.setMode(V.LINE_STRIP);
      } else
        ge.isPoints
          ? zt.setMode(V.POINTS)
          : ge.isSprite && zt.setMode(V.TRIANGLES);
      if (ge.isInstancedMesh) zt.renderInstances(Wt, Ni, ge.count);
      else if (pe.isInstancedBufferGeometry) {
        const ft =
            pe._maxInstanceCount !== void 0 ? pe._maxInstanceCount : 1 / 0,
          Nt = Math.min(pe.instanceCount, ft);
        zt.renderInstances(Wt, Ni, Nt);
      } else zt.render(Wt, Ni);
    }),
      (this.compile = function (N, se) {
        function pe(ne, ge, Xe) {
          ne.transparent === !0 && ne.side === Ar && ne.forceSinglePass === !1
            ? ((ne.side = xi),
              (ne.needsUpdate = !0),
              $r(ne, ge, Xe),
              (ne.side = xs),
              (ne.needsUpdate = !0),
              $r(ne, ge, Xe),
              (ne.side = Ar))
            : $r(ne, ge, Xe);
        }
        (A = Fe.get(N)),
          A.init(),
          x.push(A),
          N.traverseVisible(function (ne) {
            ne.isLight &&
              ne.layers.test(se.layers) &&
              (A.pushLight(ne), ne.castShadow && A.pushShadow(ne));
          }),
          A.setupLights(_.useLegacyLights),
          N.traverse(function (ne) {
            const ge = ne.material;
            if (ge)
              if (Array.isArray(ge))
                for (let Xe = 0; Xe < ge.length; Xe++) {
                  const $e = ge[Xe];
                  pe($e, N, ne);
                }
              else pe(ge, N, ne);
          }),
          x.pop(),
          (A = null);
      });
    let An = null;
    function Di(N) {
      An && An(N);
    }
    function Xt() {
      jn.stop();
    }
    function Fi() {
      jn.start();
    }
    const jn = new fB();
    jn.setAnimationLoop(Di),
      typeof self < "u" && jn.setContext(self),
      (this.setAnimationLoop = function (N) {
        (An = N), Q.setAnimationLoop(N), N === null ? jn.stop() : jn.start();
      }),
      Q.addEventListener("sessionstart", Xt),
      Q.addEventListener("sessionend", Fi),
      (this.render = function (N, se) {
        if (se !== void 0 && se.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (E === !0) return;
        N.matrixWorldAutoUpdate === !0 && N.updateMatrixWorld(),
          se.parent === null &&
            se.matrixWorldAutoUpdate === !0 &&
            se.updateMatrixWorld(),
          Q.enabled === !0 &&
            Q.isPresenting === !0 &&
            (Q.cameraAutoUpdate === !0 && Q.updateCamera(se),
            (se = Q.getCamera())),
          N.isScene === !0 && N.onBeforeRender(_, N, se, P),
          (A = Fe.get(N, x.length)),
          A.init(),
          x.push(A),
          Le.multiplyMatrices(se.projectionMatrix, se.matrixWorldInverse),
          he.setFromProjectionMatrix(Le),
          (xe = this.localClippingEnabled),
          (ae = Ke.init(this.clippingPlanes, xe)),
          (M = Se.get(N, g.length)),
          M.init(),
          g.push(M),
          Wh(N, se, 0, _.sortObjects),
          M.finish(),
          _.sortObjects === !0 && M.sort(I, G),
          this.info.render.frame++,
          ae === !0 && Ke.beginShadows();
        const pe = A.state.shadowsArray;
        if (
          (Ie.render(pe, N, se),
          ae === !0 && Ke.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          de.render(M, N),
          A.setupLights(_.useLegacyLights),
          se.isArrayCamera)
        ) {
          const ne = se.cameras;
          for (let ge = 0, Xe = ne.length; ge < Xe; ge++) {
            const $e = ne[ge];
            jh(M, N, $e, $e.viewport);
          }
        } else jh(M, N, se);
        P !== null &&
          (Ge.updateMultisampleRenderTarget(P), Ge.updateRenderTargetMipmap(P)),
          N.isScene === !0 && N.onAfterRender(_, N, se),
          De.resetDefaultState(),
          (B = -1),
          (b = null),
          x.pop(),
          x.length > 0 ? (A = x[x.length - 1]) : (A = null),
          g.pop(),
          g.length > 0 ? (M = g[g.length - 1]) : (M = null);
      });
    function Wh(N, se, pe, ne) {
      if (N.visible === !1) return;
      if (N.layers.test(se.layers)) {
        if (N.isGroup) pe = N.renderOrder;
        else if (N.isLOD) N.autoUpdate === !0 && N.update(se);
        else if (N.isLight) A.pushLight(N), N.castShadow && A.pushShadow(N);
        else if (N.isSprite) {
          if (!N.frustumCulled || he.intersectsSprite(N)) {
            ne && ct.setFromMatrixPosition(N.matrixWorld).applyMatrix4(Le);
            const $e = D.update(N),
              st = N.material;
            st.visible && M.push(N, $e, st, pe, ct.z, null);
          }
        } else if (
          (N.isMesh || N.isLine || N.isPoints) &&
          (!N.frustumCulled || he.intersectsObject(N))
        ) {
          const $e = D.update(N),
            st = N.material;
          if (
            (ne &&
              (N.boundingSphere !== void 0
                ? (N.boundingSphere === null && N.computeBoundingSphere(),
                  ct.copy(N.boundingSphere.center))
                : ($e.boundingSphere === null && $e.computeBoundingSphere(),
                  ct.copy($e.boundingSphere.center)),
              ct.applyMatrix4(N.matrixWorld).applyMatrix4(Le)),
            Array.isArray(st))
          ) {
            const ot = $e.groups;
            for (let St = 0, at = ot.length; St < at; St++) {
              const lt = ot[St],
                Wt = st[lt.materialIndex];
              Wt && Wt.visible && M.push(N, $e, Wt, pe, ct.z, lt);
            }
          } else st.visible && M.push(N, $e, st, pe, ct.z, null);
        }
      }
      const Xe = N.children;
      for (let $e = 0, st = Xe.length; $e < st; $e++) Wh(Xe[$e], se, pe, ne);
    }
    function jh(N, se, pe, ne) {
      const ge = N.opaque,
        Xe = N.transmissive,
        $e = N.transparent;
      A.setupLightsView(pe),
        ae === !0 && Ke.setGlobalState(_.clippingPlanes, pe),
        Xe.length > 0 && Xh(ge, Xe, se, pe),
        ne && _e.viewport(L.copy(ne)),
        ge.length > 0 && no(ge, se, pe),
        Xe.length > 0 && no(Xe, se, pe),
        $e.length > 0 && no($e, se, pe),
        _e.buffers.depth.setTest(!0),
        _e.buffers.depth.setMask(!0),
        _e.buffers.color.setMask(!0),
        _e.setPolygonOffset(!1);
    }
    function Xh(N, se, pe, ne) {
      const ge = Ee.isWebGL2;
      Ae === null &&
        (Ae = new Jr(1, 1, {
          generateMipmaps: !0,
          type: me.has("EXT_color_buffer_half_float") ? Xc : ms,
          minFilter: _s,
          samples: ge ? 4 : 0,
        })),
        _.getDrawingBufferSize(Ve),
        ge ? Ae.setSize(Ve.x, Ve.y) : Ae.setSize(Zm(Ve.x), Zm(Ve.y));
      const Xe = _.getRenderTarget();
      _.setRenderTarget(Ae),
        _.getClearColor(X),
        (Y = _.getClearAlpha()),
        Y < 1 && _.setClearColor(16777215, 0.5),
        _.clear();
      const $e = _.toneMapping;
      (_.toneMapping = Vr),
        no(N, pe, ne),
        Ge.updateMultisampleRenderTarget(Ae),
        Ge.updateRenderTargetMipmap(Ae);
      let st = !1;
      for (let ot = 0, St = se.length; ot < St; ot++) {
        const at = se[ot],
          lt = at.object,
          Wt = at.geometry,
          Jt = at.material,
          Ni = at.group;
        if (Jt.side === Ar && lt.layers.test(ne.layers)) {
          const Ui = Jt.side;
          (Jt.side = xi),
            (Jt.needsUpdate = !0),
            Jh(lt, pe, ne, Wt, Jt, Ni),
            (Jt.side = Ui),
            (Jt.needsUpdate = !0),
            (st = !0);
        }
      }
      st === !0 &&
        (Ge.updateMultisampleRenderTarget(Ae), Ge.updateRenderTargetMipmap(Ae)),
        _.setRenderTarget(Xe),
        _.setClearColor(X, Y),
        (_.toneMapping = $e);
    }
    function no(N, se, pe) {
      const ne = se.isScene === !0 ? se.overrideMaterial : null;
      for (let ge = 0, Xe = N.length; ge < Xe; ge++) {
        const $e = N[ge],
          st = $e.object,
          ot = $e.geometry,
          St = ne === null ? $e.material : ne,
          at = $e.group;
        st.layers.test(pe.layers) && Jh(st, se, pe, ot, St, at);
      }
    }
    function Jh(N, se, pe, ne, ge, Xe) {
      N.onBeforeRender(_, se, pe, ne, ge, Xe),
        N.modelViewMatrix.multiplyMatrices(
          pe.matrixWorldInverse,
          N.matrixWorld
        ),
        N.normalMatrix.getNormalMatrix(N.modelViewMatrix),
        ge.onBeforeRender(_, se, pe, ne, N, Xe),
        ge.transparent === !0 && ge.side === Ar && ge.forceSinglePass === !1
          ? ((ge.side = xi),
            (ge.needsUpdate = !0),
            _.renderBufferDirect(pe, se, ne, ge, N, Xe),
            (ge.side = xs),
            (ge.needsUpdate = !0),
            _.renderBufferDirect(pe, se, ne, ge, N, Xe),
            (ge.side = Ar))
          : _.renderBufferDirect(pe, se, ne, ge, N, Xe),
        N.onAfterRender(_, se, pe, ne, ge, Xe);
    }
    function $r(N, se, pe) {
      se.isScene !== !0 && (se = tt);
      const ne = Oe.get(N),
        ge = A.state.lights,
        Xe = A.state.shadowsArray,
        $e = ge.state.version,
        st = ce.getParameters(N, ge.state, Xe, se, pe),
        ot = ce.getProgramCacheKey(st);
      let St = ne.programs;
      (ne.environment = N.isMeshStandardMaterial ? se.environment : null),
        (ne.fog = se.fog),
        (ne.envMap = (N.isMeshStandardMaterial ? vt : Ze).get(
          N.envMap || ne.environment
        )),
        St === void 0 &&
          (N.addEventListener("dispose", He),
          (St = new Map()),
          (ne.programs = St));
      let at = St.get(ot);
      if (at !== void 0) {
        if (ne.currentProgram === at && ne.lightsStateVersion === $e)
          return Kh(N, st), at;
      } else
        (st.uniforms = ce.getUniforms(N)),
          N.onBuild(pe, st, _),
          N.onBeforeCompile(st, _),
          (at = ce.acquireProgram(st, ot)),
          St.set(ot, at),
          (ne.uniforms = st.uniforms);
      const lt = ne.uniforms;
      ((!N.isShaderMaterial && !N.isRawShaderMaterial) || N.clipping === !0) &&
        (lt.clippingPlanes = Ke.uniform),
        Kh(N, st),
        (ne.needsLights = _0(N)),
        (ne.lightsStateVersion = $e),
        ne.needsLights &&
          ((lt.ambientLightColor.value = ge.state.ambient),
          (lt.lightProbe.value = ge.state.probe),
          (lt.directionalLights.value = ge.state.directional),
          (lt.directionalLightShadows.value = ge.state.directionalShadow),
          (lt.spotLights.value = ge.state.spot),
          (lt.spotLightShadows.value = ge.state.spotShadow),
          (lt.rectAreaLights.value = ge.state.rectArea),
          (lt.ltc_1.value = ge.state.rectAreaLTC1),
          (lt.ltc_2.value = ge.state.rectAreaLTC2),
          (lt.pointLights.value = ge.state.point),
          (lt.pointLightShadows.value = ge.state.pointShadow),
          (lt.hemisphereLights.value = ge.state.hemi),
          (lt.directionalShadowMap.value = ge.state.directionalShadowMap),
          (lt.directionalShadowMatrix.value = ge.state.directionalShadowMatrix),
          (lt.spotShadowMap.value = ge.state.spotShadowMap),
          (lt.spotLightMatrix.value = ge.state.spotLightMatrix),
          (lt.spotLightMap.value = ge.state.spotLightMap),
          (lt.pointShadowMap.value = ge.state.pointShadowMap),
          (lt.pointShadowMatrix.value = ge.state.pointShadowMatrix));
      const Wt = at.getUniforms(),
        Jt = xm.seqWithValue(Wt.seq, lt);
      return (ne.currentProgram = at), (ne.uniformsList = Jt), at;
    }
    function Kh(N, se) {
      const pe = Oe.get(N);
      (pe.outputColorSpace = se.outputColorSpace),
        (pe.instancing = se.instancing),
        (pe.skinning = se.skinning),
        (pe.morphTargets = se.morphTargets),
        (pe.morphNormals = se.morphNormals),
        (pe.morphColors = se.morphColors),
        (pe.morphTargetsCount = se.morphTargetsCount),
        (pe.numClippingPlanes = se.numClippingPlanes),
        (pe.numIntersection = se.numClipIntersection),
        (pe.vertexAlphas = se.vertexAlphas),
        (pe.vertexTangents = se.vertexTangents),
        (pe.toneMapping = se.toneMapping);
    }
    function y0(N, se, pe, ne, ge) {
      se.isScene !== !0 && (se = tt), Ge.resetTextureUnits();
      const Xe = se.fog,
        $e = ne.isMeshStandardMaterial ? se.environment : null,
        st =
          P === null
            ? _.outputColorSpace
            : P.isXRRenderTarget === !0
            ? P.texture.colorSpace
            : Xr,
        ot = (ne.isMeshStandardMaterial ? vt : Ze).get(ne.envMap || $e),
        St =
          ne.vertexColors === !0 &&
          !!pe.attributes.color &&
          pe.attributes.color.itemSize === 4,
        at = !!pe.attributes.tangent && (!!ne.normalMap || ne.anisotropy > 0),
        lt = !!pe.morphAttributes.position,
        Wt = !!pe.morphAttributes.normal,
        Jt = !!pe.morphAttributes.color,
        Ni = ne.toneMapped ? _.toneMapping : Vr,
        Ui =
          pe.morphAttributes.position ||
          pe.morphAttributes.normal ||
          pe.morphAttributes.color,
        zt = Ui !== void 0 ? Ui.length : 0,
        ft = Oe.get(ne),
        Nt = A.state.lights;
      if (ae === !0 && (xe === !0 || N !== b)) {
        const Zn = N === b && ne.id === B;
        Ke.setState(ne, N, Zn);
      }
      let ut = !1;
      ne.version === ft.__version
        ? ((ft.needsLights && ft.lightsStateVersion !== Nt.state.version) ||
            ft.outputColorSpace !== st ||
            (ge.isInstancedMesh && ft.instancing === !1) ||
            (!ge.isInstancedMesh && ft.instancing === !0) ||
            (ge.isSkinnedMesh && ft.skinning === !1) ||
            (!ge.isSkinnedMesh && ft.skinning === !0) ||
            ft.envMap !== ot ||
            (ne.fog === !0 && ft.fog !== Xe) ||
            (ft.numClippingPlanes !== void 0 &&
              (ft.numClippingPlanes !== Ke.numPlanes ||
                ft.numIntersection !== Ke.numIntersection)) ||
            ft.vertexAlphas !== St ||
            ft.vertexTangents !== at ||
            ft.morphTargets !== lt ||
            ft.morphNormals !== Wt ||
            ft.morphColors !== Jt ||
            ft.toneMapping !== Ni ||
            (Ee.isWebGL2 === !0 && ft.morphTargetsCount !== zt)) &&
          (ut = !0)
        : ((ut = !0), (ft.__version = ne.version));
      let qn = ft.currentProgram;
      ut === !0 && (qn = $r(ne, se, ge));
      let Rn = !1,
        Sn = !1,
        Cr = !1;
      const fn = qn.getUniforms(),
        hn = ft.uniforms;
      if (
        (_e.useProgram(qn.program) && ((Rn = !0), (Sn = !0), (Cr = !0)),
        ne.id !== B && ((B = ne.id), (Sn = !0)),
        Rn || b !== N)
      ) {
        if (
          (fn.setValue(V, "projectionMatrix", N.projectionMatrix),
          Ee.logarithmicDepthBuffer &&
            fn.setValue(
              V,
              "logDepthBufFC",
              2 / (Math.log(N.far + 1) / Math.LN2)
            ),
          b !== N && ((b = N), (Sn = !0), (Cr = !0)),
          ne.isShaderMaterial ||
            ne.isMeshPhongMaterial ||
            ne.isMeshToonMaterial ||
            ne.isMeshStandardMaterial ||
            ne.envMap)
        ) {
          const Zn = fn.map.cameraPosition;
          Zn !== void 0 &&
            Zn.setValue(V, ct.setFromMatrixPosition(N.matrixWorld));
        }
        (ne.isMeshPhongMaterial ||
          ne.isMeshToonMaterial ||
          ne.isMeshLambertMaterial ||
          ne.isMeshBasicMaterial ||
          ne.isMeshStandardMaterial ||
          ne.isShaderMaterial) &&
          fn.setValue(V, "isOrthographic", N.isOrthographicCamera === !0),
          (ne.isMeshPhongMaterial ||
            ne.isMeshToonMaterial ||
            ne.isMeshLambertMaterial ||
            ne.isMeshBasicMaterial ||
            ne.isMeshStandardMaterial ||
            ne.isShaderMaterial ||
            ne.isShadowMaterial ||
            ge.isSkinnedMesh) &&
            fn.setValue(V, "viewMatrix", N.matrixWorldInverse);
      }
      if (ge.isSkinnedMesh) {
        fn.setOptional(V, ge, "bindMatrix"),
          fn.setOptional(V, ge, "bindMatrixInverse");
        const Zn = ge.skeleton;
        Zn &&
          (Ee.floatVertexTextures
            ? (Zn.boneTexture === null && Zn.computeBoneTexture(),
              fn.setValue(V, "boneTexture", Zn.boneTexture, Ge),
              fn.setValue(V, "boneTextureSize", Zn.boneTextureSize))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      const io = pe.morphAttributes;
      if (
        ((io.position !== void 0 ||
          io.normal !== void 0 ||
          (io.color !== void 0 && Ee.isWebGL2 === !0)) &&
          J.update(ge, pe, qn),
        (Sn || ft.receiveShadow !== ge.receiveShadow) &&
          ((ft.receiveShadow = ge.receiveShadow),
          fn.setValue(V, "receiveShadow", ge.receiveShadow)),
        ne.isMeshGouraudMaterial &&
          ne.envMap !== null &&
          ((hn.envMap.value = ot),
          (hn.flipEnvMap.value =
            ot.isCubeTexture && ot.isRenderTargetTexture === !1 ? -1 : 1)),
        Sn &&
          (fn.setValue(V, "toneMappingExposure", _.toneMappingExposure),
          ft.needsLights && x0(hn, Cr),
          Xe && ne.fog === !0 && we.refreshFogUniforms(hn, Xe),
          we.refreshMaterialUniforms(hn, ne, ee, ie, Ae),
          xm.upload(V, ft.uniformsList, hn, Ge)),
        ne.isShaderMaterial &&
          ne.uniformsNeedUpdate === !0 &&
          (xm.upload(V, ft.uniformsList, hn, Ge), (ne.uniformsNeedUpdate = !1)),
        ne.isSpriteMaterial && fn.setValue(V, "center", ge.center),
        fn.setValue(V, "modelViewMatrix", ge.modelViewMatrix),
        fn.setValue(V, "normalMatrix", ge.normalMatrix),
        fn.setValue(V, "modelMatrix", ge.matrixWorld),
        ne.isShaderMaterial || ne.isRawShaderMaterial)
      ) {
        const Zn = ne.uniformsGroups;
        for (let yl = 0, xl = Zn.length; yl < xl; yl++)
          if (Ee.isWebGL2) {
            const hu = Zn[yl];
            nt.update(hu, qn), nt.bind(hu, qn);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return qn;
    }
    function x0(N, se) {
      (N.ambientLightColor.needsUpdate = se),
        (N.lightProbe.needsUpdate = se),
        (N.directionalLights.needsUpdate = se),
        (N.directionalLightShadows.needsUpdate = se),
        (N.pointLights.needsUpdate = se),
        (N.pointLightShadows.needsUpdate = se),
        (N.spotLights.needsUpdate = se),
        (N.spotLightShadows.needsUpdate = se),
        (N.rectAreaLights.needsUpdate = se),
        (N.hemisphereLights.needsUpdate = se);
    }
    function _0(N) {
      return (
        N.isMeshLambertMaterial ||
        N.isMeshToonMaterial ||
        N.isMeshPhongMaterial ||
        N.isMeshStandardMaterial ||
        N.isShadowMaterial ||
        (N.isShaderMaterial && N.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return T;
    }),
      (this.getActiveMipmapLevel = function () {
        return R;
      }),
      (this.getRenderTarget = function () {
        return P;
      }),
      (this.setRenderTargetTextures = function (N, se, pe) {
        (Oe.get(N.texture).__webglTexture = se),
          (Oe.get(N.depthTexture).__webglTexture = pe);
        const ne = Oe.get(N);
        (ne.__hasExternalTextures = !0),
          ne.__hasExternalTextures &&
            ((ne.__autoAllocateDepthBuffer = pe === void 0),
            ne.__autoAllocateDepthBuffer ||
              (me.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (ne.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (N, se) {
        const pe = Oe.get(N);
        (pe.__webglFramebuffer = se),
          (pe.__useDefaultFramebuffer = se === void 0);
      }),
      (this.setRenderTarget = function (N, se = 0, pe = 0) {
        (P = N), (T = se), (R = pe);
        let ne = !0,
          ge = null,
          Xe = !1,
          $e = !1;
        if (N) {
          const ot = Oe.get(N);
          ot.__useDefaultFramebuffer !== void 0
            ? (_e.bindFramebuffer(V.FRAMEBUFFER, null), (ne = !1))
            : ot.__webglFramebuffer === void 0
            ? Ge.setupRenderTarget(N)
            : ot.__hasExternalTextures &&
              Ge.rebindTextures(
                N,
                Oe.get(N.texture).__webglTexture,
                Oe.get(N.depthTexture).__webglTexture
              );
          const St = N.texture;
          (St.isData3DTexture ||
            St.isDataArrayTexture ||
            St.isCompressedArrayTexture) &&
            ($e = !0);
          const at = Oe.get(N).__webglFramebuffer;
          N.isWebGLCubeRenderTarget
            ? ((ge = at[se]), (Xe = !0))
            : Ee.isWebGL2 && N.samples > 0 && Ge.useMultisampledRTT(N) === !1
            ? (ge = Oe.get(N).__webglMultisampledFramebuffer)
            : (ge = at),
            L.copy(N.viewport),
            z.copy(N.scissor),
            ($ = N.scissorTest);
        } else
          L.copy(k).multiplyScalar(ee).floor(),
            z.copy(U).multiplyScalar(ee).floor(),
            ($ = j);
        if (
          (_e.bindFramebuffer(V.FRAMEBUFFER, ge) &&
            Ee.drawBuffers &&
            ne &&
            _e.drawBuffers(N, ge),
          _e.viewport(L),
          _e.scissor(z),
          _e.setScissorTest($),
          Xe)
        ) {
          const ot = Oe.get(N.texture);
          V.framebufferTexture2D(
            V.FRAMEBUFFER,
            V.COLOR_ATTACHMENT0,
            V.TEXTURE_CUBE_MAP_POSITIVE_X + se,
            ot.__webglTexture,
            pe
          );
        } else if ($e) {
          const ot = Oe.get(N.texture),
            St = se || 0;
          V.framebufferTextureLayer(
            V.FRAMEBUFFER,
            V.COLOR_ATTACHMENT0,
            ot.__webglTexture,
            pe || 0,
            St
          );
        }
        B = -1;
      }),
      (this.readRenderTargetPixels = function (N, se, pe, ne, ge, Xe, $e) {
        if (!(N && N.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let st = Oe.get(N).__webglFramebuffer;
        if ((N.isWebGLCubeRenderTarget && $e !== void 0 && (st = st[$e]), st)) {
          _e.bindFramebuffer(V.FRAMEBUFFER, st);
          try {
            const ot = N.texture,
              St = ot.format,
              at = ot.type;
            if (
              St !== bi &&
              be.convert(St) !==
                V.getParameter(V.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const lt =
              at === Xc &&
              (me.has("EXT_color_buffer_half_float") ||
                (Ee.isWebGL2 && me.has("EXT_color_buffer_float")));
            if (
              at !== ms &&
              be.convert(at) !==
                V.getParameter(V.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                at === fs &&
                (Ee.isWebGL2 ||
                  me.has("OES_texture_float") ||
                  me.has("WEBGL_color_buffer_float"))
              ) &&
              !lt
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            se >= 0 &&
              se <= N.width - ne &&
              pe >= 0 &&
              pe <= N.height - ge &&
              V.readPixels(se, pe, ne, ge, be.convert(St), be.convert(at), Xe);
          } finally {
            const ot = P !== null ? Oe.get(P).__webglFramebuffer : null;
            _e.bindFramebuffer(V.FRAMEBUFFER, ot);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (N, se, pe = 0) {
        const ne = Math.pow(2, -pe),
          ge = Math.floor(se.image.width * ne),
          Xe = Math.floor(se.image.height * ne);
        Ge.setTexture2D(se, 0),
          V.copyTexSubImage2D(V.TEXTURE_2D, pe, 0, 0, N.x, N.y, ge, Xe),
          _e.unbindTexture();
      }),
      (this.copyTextureToTexture = function (N, se, pe, ne = 0) {
        const ge = se.image.width,
          Xe = se.image.height,
          $e = be.convert(pe.format),
          st = be.convert(pe.type);
        Ge.setTexture2D(pe, 0),
          V.pixelStorei(V.UNPACK_FLIP_Y_WEBGL, pe.flipY),
          V.pixelStorei(V.UNPACK_PREMULTIPLY_ALPHA_WEBGL, pe.premultiplyAlpha),
          V.pixelStorei(V.UNPACK_ALIGNMENT, pe.unpackAlignment),
          se.isDataTexture
            ? V.texSubImage2D(
                V.TEXTURE_2D,
                ne,
                N.x,
                N.y,
                ge,
                Xe,
                $e,
                st,
                se.image.data
              )
            : se.isCompressedTexture
            ? V.compressedTexSubImage2D(
                V.TEXTURE_2D,
                ne,
                N.x,
                N.y,
                se.mipmaps[0].width,
                se.mipmaps[0].height,
                $e,
                se.mipmaps[0].data
              )
            : V.texSubImage2D(V.TEXTURE_2D, ne, N.x, N.y, $e, st, se.image),
          ne === 0 && pe.generateMipmaps && V.generateMipmap(V.TEXTURE_2D),
          _e.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (N, se, pe, ne, ge = 0) {
        if (_.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const Xe = N.max.x - N.min.x + 1,
          $e = N.max.y - N.min.y + 1,
          st = N.max.z - N.min.z + 1,
          ot = be.convert(ne.format),
          St = be.convert(ne.type);
        let at;
        if (ne.isData3DTexture) Ge.setTexture3D(ne, 0), (at = V.TEXTURE_3D);
        else if (ne.isDataArrayTexture)
          Ge.setTexture2DArray(ne, 0), (at = V.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        V.pixelStorei(V.UNPACK_FLIP_Y_WEBGL, ne.flipY),
          V.pixelStorei(V.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ne.premultiplyAlpha),
          V.pixelStorei(V.UNPACK_ALIGNMENT, ne.unpackAlignment);
        const lt = V.getParameter(V.UNPACK_ROW_LENGTH),
          Wt = V.getParameter(V.UNPACK_IMAGE_HEIGHT),
          Jt = V.getParameter(V.UNPACK_SKIP_PIXELS),
          Ni = V.getParameter(V.UNPACK_SKIP_ROWS),
          Ui = V.getParameter(V.UNPACK_SKIP_IMAGES),
          zt = pe.isCompressedTexture ? pe.mipmaps[0] : pe.image;
        V.pixelStorei(V.UNPACK_ROW_LENGTH, zt.width),
          V.pixelStorei(V.UNPACK_IMAGE_HEIGHT, zt.height),
          V.pixelStorei(V.UNPACK_SKIP_PIXELS, N.min.x),
          V.pixelStorei(V.UNPACK_SKIP_ROWS, N.min.y),
          V.pixelStorei(V.UNPACK_SKIP_IMAGES, N.min.z),
          pe.isDataTexture || pe.isData3DTexture
            ? V.texSubImage3D(
                at,
                ge,
                se.x,
                se.y,
                se.z,
                Xe,
                $e,
                st,
                ot,
                St,
                zt.data
              )
            : pe.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              V.compressedTexSubImage3D(
                at,
                ge,
                se.x,
                se.y,
                se.z,
                Xe,
                $e,
                st,
                ot,
                zt.data
              ))
            : V.texSubImage3D(at, ge, se.x, se.y, se.z, Xe, $e, st, ot, St, zt),
          V.pixelStorei(V.UNPACK_ROW_LENGTH, lt),
          V.pixelStorei(V.UNPACK_IMAGE_HEIGHT, Wt),
          V.pixelStorei(V.UNPACK_SKIP_PIXELS, Jt),
          V.pixelStorei(V.UNPACK_SKIP_ROWS, Ni),
          V.pixelStorei(V.UNPACK_SKIP_IMAGES, Ui),
          ge === 0 && ne.generateMipmaps && V.generateMipmap(at),
          _e.unbindTexture();
      }),
      (this.initTexture = function (N) {
        N.isCubeTexture
          ? Ge.setTextureCube(N, 0)
          : N.isData3DTexture
          ? Ge.setTexture3D(N, 0)
          : N.isDataArrayTexture || N.isCompressedArrayTexture
          ? Ge.setTexture2DArray(N, 0)
          : Ge.setTexture2D(N, 0),
          _e.unbindTexture();
      }),
      (this.resetState = function () {
        (T = 0), (R = 0), (P = null), _e.reset(), De.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return hs;
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(e) {
    console.warn(
      "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !e);
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
      this.outputColorSpace === mt ? zo : x1
    );
  }
  set outputEncoding(e) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
    ),
      (this.outputColorSpace = e === zo ? mt : Xr);
  }
}
class xB extends B1 {}
xB.prototype.isWebGL1Renderer = !0;
class Hg {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new Ue(e)),
      (this.density = t);
  }
  clone() {
    return new Hg(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class zg {
  constructor(e, t = 1, i = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new Ue(e)),
      (this.near = t),
      (this.far = i);
  }
  clone() {
    return new zg(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class $m extends Rt {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
}
class bh {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = th),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = qi());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.stride), (i *= t.stride);
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = qi()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = qi()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const di = new F();
class Qo {
  constructor(e, t, i, r = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = r);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      di.fromBufferAttribute(this, t),
        di.applyMatrix4(e),
        this.setXYZ(t, di.x, di.y, di.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      di.fromBufferAttribute(this, t),
        di.applyNormalMatrix(e),
        this.setXYZ(t, di.x, di.y, di.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      di.fromBufferAttribute(this, t),
        di.transformDirection(e),
        this.setXYZ(t, di.x, di.y, di.z);
    return this;
  }
  setX(e, t) {
    return (
      this.normalized && (t = At(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = At(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = At(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = At(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Xi(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Xi(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Xi(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Xi(t, this.array)), t;
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = At(t, this.array)), (i = At(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = At(t, this.array)),
        (i = At(i, this.array)),
        (r = At(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = At(t, this.array)),
        (i = At(i, this.array)),
        (r = At(r, this.array)),
        (s = At(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return new Ft(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Qo(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class L1 extends bn {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new Ue(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let Yl;
const Wu = new F(),
  Ql = new F(),
  ql = new F(),
  Zl = new ve(),
  ju = new ve(),
  _B = new rt(),
  Ep = new F(),
  Xu = new F(),
  wp = new F(),
  aT = new ve(),
  xy = new ve(),
  lT = new ve();
class AB extends Rt {
  constructor(e) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), Yl === void 0)
    ) {
      Yl = new gt();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        i = new bh(t, 5);
      Yl.setIndex([0, 1, 2, 0, 2, 3]),
        Yl.setAttribute("position", new Qo(i, 3, 0, !1)),
        Yl.setAttribute("uv", new Qo(i, 2, 3, !1));
    }
    (this.geometry = Yl),
      (this.material = e !== void 0 ? e : new L1()),
      (this.center = new ve(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      Ql.setFromMatrixScale(this.matrixWorld),
      _B.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      ql.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Ql.multiplyScalar(-ql.z);
    const i = this.material.rotation;
    let r, s;
    i !== 0 && ((s = Math.cos(i)), (r = Math.sin(i)));
    const o = this.center;
    Tp(Ep.set(-0.5, -0.5, 0), ql, o, Ql, r, s),
      Tp(Xu.set(0.5, -0.5, 0), ql, o, Ql, r, s),
      Tp(wp.set(0.5, 0.5, 0), ql, o, Ql, r, s),
      aT.set(0, 0),
      xy.set(1, 0),
      lT.set(1, 1);
    let a = e.ray.intersectTriangle(Ep, Xu, wp, !1, Wu);
    if (
      a === null &&
      (Tp(Xu.set(-0.5, 0.5, 0), ql, o, Ql, r, s),
      xy.set(0, 1),
      (a = e.ray.intersectTriangle(Ep, wp, Xu, !1, Wu)),
      a === null)
    )
      return;
    const l = e.ray.origin.distanceTo(Wu);
    l < e.near ||
      l > e.far ||
      t.push({
        distance: l,
        point: Wu.clone(),
        uv: Ci.getInterpolation(Wu, Ep, Xu, wp, aT, xy, lT, new ve()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function Tp(n, e, t, i, r, s) {
  Zl.subVectors(n, t).addScalar(0.5).multiply(i),
    r !== void 0
      ? ((ju.x = s * Zl.x - r * Zl.y), (ju.y = r * Zl.x + s * Zl.y))
      : ju.copy(Zl),
    n.copy(e),
    (n.x += ju.x),
    (n.y += ju.y),
    n.applyMatrix4(_B);
}
const Cp = new F(),
  cT = new F();
class SB extends Rt {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(t < r[s].distance); s++);
    return (
      r.splice(s, 0, { distance: t, hysteresis: i, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let s = t[i].distance;
        if ((t[i].object.visible && (s -= s * t[i].hysteresis), e < s)) break;
      }
      return t[i - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Cp.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(Cp);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Cp.setFromMatrixPosition(e.matrixWorld),
        cT.setFromMatrixPosition(this.matrixWorld);
      const i = Cp.distanceTo(cT) / e.zoom;
      t[0].object.visible = !0;
      let r, s;
      for (r = 1, s = t.length; r < s; r++) {
        let o = t[r].distance;
        if ((t[r].object.visible && (o -= o * t[r].hysteresis), i >= o))
          (t[r - 1].object.visible = !1), (t[r].object.visible = !0);
        else break;
      }
      for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const i = this.levels;
    for (let r = 0, s = i.length; r < s; r++) {
      const o = i[r];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis,
      });
    }
    return t;
  }
}
const uT = new F(),
  fT = new Ut(),
  hT = new Ut(),
  s4 = new F(),
  dT = new rt(),
  $l = new F(),
  _y = new Tr(),
  pT = new rt(),
  Ay = new au();
class I1 extends Gn {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new rt()),
      (this.bindMatrixInverse = new rt()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Yr()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      $l.fromBufferAttribute(t, i),
        this.applyBoneTransform(i, $l),
        this.boundingBox.expandByPoint($l);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Tr()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      $l.fromBufferAttribute(t, i),
        this.applyBoneTransform(i, $l),
        this.boundingSphere.expandByPoint($l);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const i = this.material,
      r = this.matrixWorld;
    i !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      _y.copy(this.boundingSphere),
      _y.applyMatrix4(r),
      e.ray.intersectsSphere(_y) !== !1 &&
        (pT.copy(r).invert(),
        Ay.copy(e.ray).applyMatrix4(pT),
        !(
          this.boundingBox !== null && Ay.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, Ay)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Ut(),
      t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === "detached"
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton,
      r = this.geometry;
    fT.fromBufferAttribute(r.attributes.skinIndex, e),
      hT.fromBufferAttribute(r.attributes.skinWeight, e),
      uT.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = hT.getComponent(s);
      if (o !== 0) {
        const a = fT.getComponent(s);
        dT.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
          t.addScaledVector(s4.copy(uT).applyMatrix4(dT), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return (
      console.warn(
        "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
      ),
      this.applyBoneTransform(e, t)
    );
  }
}
class Gg extends Rt {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Dc extends en {
  constructor(e = null, t = 1, i = 1, r, s, o, a, l, u = gn, h = gn, d, p) {
    super(null, o, a, l, u, h, r, s, d, p),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const mT = new rt(),
  o4 = new rt();
class Rh {
  constructor(e = [], t = []) {
    (this.uuid = qi()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new rt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new rt();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : o4;
      mT.multiplyMatrices(a, t[s]), mT.toArray(i, s * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new Rh(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = sB(e)), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Dc(t, e, e, bi, fs);
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i];
      let o = t[s];
      o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (o = new Gg())),
        this.bones.push(o),
        this.boneInverses.push(new rt().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      i = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      e.bones.push(o.uuid);
      const a = i[r];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class Qc extends Ft {
  constructor(e, t, i, r = 1) {
    super(e, t, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const ec = new rt(),
  gT = new rt(),
  bp = [],
  vT = new Yr(),
  a4 = new rt(),
  Ju = new Gn(),
  Ku = new Tr();
class D1 extends Gn {
  constructor(e, t, i) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Qc(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.count = i),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let r = 0; r < i; r++) this.setMatrixAt(r, a4);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new Yr()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, ec),
        vT.copy(e.boundingBox).applyMatrix4(ec),
        this.boundingBox.union(vT);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Tr()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, ec),
        Ku.copy(e.boundingSphere).applyMatrix4(ec),
        this.boundingSphere.union(Ku);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      r = this.count;
    if (
      ((Ju.geometry = this.geometry),
      (Ju.material = this.material),
      Ju.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Ku.copy(this.boundingSphere),
        Ku.applyMatrix4(i),
        e.ray.intersectsSphere(Ku) !== !1))
    )
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, ec),
          gT.multiplyMatrices(i, ec),
          (Ju.matrixWorld = gT),
          Ju.raycast(e, bp);
        for (let o = 0, a = bp.length; o < a; o++) {
          const l = bp[o];
          (l.instanceId = s), (l.object = this), t.push(l);
        }
        bp.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new Qc(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ci extends bn {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Ue(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const yT = new F(),
  xT = new F(),
  _T = new rt(),
  Sy = new au(),
  Rp = new Tr();
class $s extends Rt {
  constructor(e = new gt(), t = new ci()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [0];
      for (let r = 1, s = t.count; r < s; r++)
        yT.fromBufferAttribute(t, r - 1),
          xT.fromBufferAttribute(t, r),
          (i[r] = i[r - 1]),
          (i[r] += yT.distanceTo(xT));
      e.setAttribute("lineDistance", new Ye(i, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Rp.copy(i.boundingSphere),
      Rp.applyMatrix4(r),
      (Rp.radius += s),
      e.ray.intersectsSphere(Rp) === !1)
    )
      return;
    _T.copy(r).invert(), Sy.copy(e.ray).applyMatrix4(_T);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      u = new F(),
      h = new F(),
      d = new F(),
      p = new F(),
      m = this.isLineSegments ? 2 : 1,
      y = i.index,
      A = i.attributes.position;
    if (y !== null) {
      const g = Math.max(0, o.start),
        x = Math.min(y.count, o.start + o.count);
      for (let _ = g, E = x - 1; _ < E; _ += m) {
        const T = y.getX(_),
          R = y.getX(_ + 1);
        if (
          (u.fromBufferAttribute(A, T),
          h.fromBufferAttribute(A, R),
          Sy.distanceSqToSegment(u, h, p, d) > l)
        )
          continue;
        p.applyMatrix4(this.matrixWorld);
        const B = e.ray.origin.distanceTo(p);
        B < e.near ||
          B > e.far ||
          t.push({
            distance: B,
            point: d.clone().applyMatrix4(this.matrixWorld),
            index: _,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const g = Math.max(0, o.start),
        x = Math.min(A.count, o.start + o.count);
      for (let _ = g, E = x - 1; _ < E; _ += m) {
        if (
          (u.fromBufferAttribute(A, _),
          h.fromBufferAttribute(A, _ + 1),
          Sy.distanceSqToSegment(u, h, p, d) > l)
        )
          continue;
        p.applyMatrix4(this.matrixWorld);
        const R = e.ray.origin.distanceTo(p);
        R < e.near ||
          R > e.far ||
          t.push({
            distance: R,
            point: d.clone().applyMatrix4(this.matrixWorld),
            index: _,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
const AT = new F(),
  ST = new F();
class Qr extends $s {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        AT.fromBufferAttribute(t, r),
          ST.fromBufferAttribute(t, r + 1),
          (i[r] = r === 0 ? 0 : i[r - 1]),
          (i[r + 1] = i[r] + AT.distanceTo(ST));
      e.setAttribute("lineDistance", new Ye(i, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class F1 extends $s {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class Ph extends bn {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Ue(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const MT = new rt(),
  N_ = new au(),
  Pp = new Tr(),
  Bp = new F();
let N1 = class extends Rt {
  constructor(e = new gt(), t = new Ph()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Pp.copy(i.boundingSphere),
      Pp.applyMatrix4(r),
      (Pp.radius += s),
      e.ray.intersectsSphere(Pp) === !1)
    )
      return;
    MT.copy(r).invert(), N_.copy(e.ray).applyMatrix4(MT);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      u = i.index,
      d = i.attributes.position;
    if (u !== null) {
      const p = Math.max(0, o.start),
        m = Math.min(u.count, o.start + o.count);
      for (let y = p, M = m; y < M; y++) {
        const A = u.getX(y);
        Bp.fromBufferAttribute(d, A), ET(Bp, A, l, r, e, t, this);
      }
    } else {
      const p = Math.max(0, o.start),
        m = Math.min(d.count, o.start + o.count);
      for (let y = p, M = m; y < M; y++)
        Bp.fromBufferAttribute(d, y), ET(Bp, y, l, r, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
};
function ET(n, e, t, i, r, s, o) {
  const a = N_.distanceSqToPoint(n);
  if (a < t) {
    const l = new F();
    N_.closestPointToPoint(n, l), l.applyMatrix4(i);
    const u = r.ray.origin.distanceTo(l);
    if (u < r.near || u > r.far) return;
    s.push({
      distance: u,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      object: o,
    });
  }
}
class l4 extends en {
  constructor(e, t, i, r, s, o, a, l, u) {
    super(e, t, i, r, s, o, a, l, u),
      (this.isVideoTexture = !0),
      (this.minFilter = o !== void 0 ? o : sn),
      (this.magFilter = s !== void 0 ? s : sn),
      (this.generateMipmaps = !1);
    const h = this;
    function d() {
      (h.needsUpdate = !0), e.requestVideoFrameCallback(d);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class c4 extends en {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = gn),
      (this.minFilter = gn),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class U1 extends en {
  constructor(e, t, i, r, s, o, a, l, u, h, d, p) {
    super(null, o, a, l, u, h, r, s, d, p),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: i }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class u4 extends U1 {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, s, o),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = r),
      (this.wrapR = Kn);
  }
}
class f4 extends en {
  constructor(e, t, i, r, s, o, a, l, u) {
    super(e, t, i, r, s, o, a, l, u),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class qr {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i,
      r = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      (i = this.getPoint(o / e)), (s += i.distanceTo(r)), t.push(s), (r = i);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let r = 0;
    const s = i.length;
    let o;
    t ? (o = t) : (o = e * i[s - 1]);
    let a = 0,
      l = s - 1,
      u;
    for (; a <= l; )
      if (((r = Math.floor(a + (l - a) / 2)), (u = i[r] - o), u < 0)) a = r + 1;
      else if (u > 0) l = r - 1;
      else {
        l = r;
        break;
      }
    if (((r = l), i[r] === o)) return r / (s - 1);
    const h = i[r],
      p = i[r + 1] - h,
      m = (o - h) / p;
    return (r + m) / (s - 1);
  }
  getTangent(e, t) {
    let r = e - 1e-4,
      s = e + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const o = this.getPoint(r),
      a = this.getPoint(s),
      l = t || (o.isVector2 ? new ve() : new F());
    return l.copy(a).sub(o).normalize(), l;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new F(),
      r = [],
      s = [],
      o = [],
      a = new F(),
      l = new rt();
    for (let m = 0; m <= e; m++) {
      const y = m / e;
      r[m] = this.getTangentAt(y, new F());
    }
    (s[0] = new F()), (o[0] = new F());
    let u = Number.MAX_VALUE;
    const h = Math.abs(r[0].x),
      d = Math.abs(r[0].y),
      p = Math.abs(r[0].z);
    h <= u && ((u = h), i.set(1, 0, 0)),
      d <= u && ((u = d), i.set(0, 1, 0)),
      p <= u && i.set(0, 0, 1),
      a.crossVectors(r[0], i).normalize(),
      s[0].crossVectors(r[0], a),
      o[0].crossVectors(r[0], s[0]);
    for (let m = 1; m <= e; m++) {
      if (
        ((s[m] = s[m - 1].clone()),
        (o[m] = o[m - 1].clone()),
        a.crossVectors(r[m - 1], r[m]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const y = Math.acos(vn(r[m - 1].dot(r[m]), -1, 1));
        s[m].applyMatrix4(l.makeRotationAxis(a, y));
      }
      o[m].crossVectors(r[m], s[m]);
    }
    if (t === !0) {
      let m = Math.acos(vn(s[0].dot(s[e]), -1, 1));
      (m /= e), r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
      for (let y = 1; y <= e; y++)
        s[y].applyMatrix4(l.makeRotationAxis(r[y], m * y)),
          o[y].crossVectors(r[y], s[y]);
    }
    return { tangents: r, normals: s, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class Vg extends qr {
  constructor(
    e = 0,
    t = 0,
    i = 1,
    r = 1,
    s = 0,
    o = Math.PI * 2,
    a = !1,
    l = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = i),
      (this.yRadius = r),
      (this.aStartAngle = s),
      (this.aEndAngle = o),
      (this.aClockwise = a),
      (this.aRotation = l);
  }
  getPoint(e, t) {
    const i = t || new ve(),
      r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += r;
    for (; s > r; ) s -= r;
    s < Number.EPSILON && (o ? (s = 0) : (s = r)),
      this.aClockwise === !0 && !o && (s === r ? (s = -r) : (s = s - r));
    const a = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(a),
      u = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation),
        d = Math.sin(this.aRotation),
        p = l - this.aX,
        m = u - this.aY;
      (l = p * h - m * d + this.aX), (u = p * d + m * h + this.aY);
    }
    return i.set(l, u);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class MB extends Vg {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, i, r, s, o),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function O1() {
  let n = 0,
    e = 0,
    t = 0,
    i = 0;
  function r(s, o, a, l) {
    (n = s),
      (e = a),
      (t = -3 * s + 3 * o - 2 * a - l),
      (i = 2 * s - 2 * o + a + l);
  }
  return {
    initCatmullRom: function (s, o, a, l, u) {
      r(o, a, u * (a - s), u * (l - o));
    },
    initNonuniformCatmullRom: function (s, o, a, l, u, h, d) {
      let p = (o - s) / u - (a - s) / (u + h) + (a - o) / h,
        m = (a - o) / h - (l - o) / (h + d) + (l - a) / d;
      (p *= h), (m *= h), r(o, a, p, m);
    },
    calc: function (s) {
      const o = s * s,
        a = o * s;
      return n + e * s + t * o + i * a;
    },
  };
}
const Lp = new F(),
  My = new O1(),
  Ey = new O1(),
  wy = new O1();
class EB extends qr {
  constructor(e = [], t = !1, i = "centripetal", r = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = i),
      (this.tension = r);
  }
  getPoint(e, t = new F()) {
    const i = t,
      r = this.points,
      s = r.length,
      o = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o),
      l = o - a;
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
      : l === 0 && a === s - 1 && ((a = s - 2), (l = 1));
    let u, h;
    this.closed || a > 0
      ? (u = r[(a - 1) % s])
      : (Lp.subVectors(r[0], r[1]).add(r[0]), (u = Lp));
    const d = r[a % s],
      p = r[(a + 1) % s];
    if (
      (this.closed || a + 2 < s
        ? (h = r[(a + 2) % s])
        : (Lp.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (h = Lp)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const m = this.curveType === "chordal" ? 0.5 : 0.25;
      let y = Math.pow(u.distanceToSquared(d), m),
        M = Math.pow(d.distanceToSquared(p), m),
        A = Math.pow(p.distanceToSquared(h), m);
      M < 1e-4 && (M = 1),
        y < 1e-4 && (y = M),
        A < 1e-4 && (A = M),
        My.initNonuniformCatmullRom(u.x, d.x, p.x, h.x, y, M, A),
        Ey.initNonuniformCatmullRom(u.y, d.y, p.y, h.y, y, M, A),
        wy.initNonuniformCatmullRom(u.z, d.z, p.z, h.z, y, M, A);
    } else
      this.curveType === "catmullrom" &&
        (My.initCatmullRom(u.x, d.x, p.x, h.x, this.tension),
        Ey.initCatmullRom(u.y, d.y, p.y, h.y, this.tension),
        wy.initCatmullRom(u.z, d.z, p.z, h.z, this.tension));
    return i.set(My.calc(l), Ey.calc(l), wy.calc(l)), i;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new F().fromArray(r));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function wT(n, e, t, i, r) {
  const s = (i - e) * 0.5,
    o = (r - t) * 0.5,
    a = n * n,
    l = n * a;
  return (
    (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
  );
}
function h4(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function d4(n, e) {
  return 2 * (1 - n) * n * e;
}
function p4(n, e) {
  return n * n * e;
}
function Tf(n, e, t, i) {
  return h4(n, e) + d4(n, t) + p4(n, i);
}
function m4(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function g4(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function v4(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function y4(n, e) {
  return n * n * n * e;
}
function Cf(n, e, t, i, r) {
  return m4(n, e) + g4(n, t) + v4(n, i) + y4(n, r);
}
class k1 extends qr {
  constructor(e = new ve(), t = new ve(), i = new ve(), r = new ve()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r);
  }
  getPoint(e, t = new ve()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return i.set(Cf(e, r.x, s.x, o.x, a.x), Cf(e, r.y, s.y, o.y, a.y)), i;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class wB extends qr {
  constructor(e = new F(), t = new F(), i = new F(), r = new F()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r);
  }
  getPoint(e, t = new F()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return (
      i.set(
        Cf(e, r.x, s.x, o.x, a.x),
        Cf(e, r.y, s.y, o.y, a.y),
        Cf(e, r.z, s.z, o.z, a.z)
      ),
      i
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class Wg extends qr {
  constructor(e = new ve(), t = new ve()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new ve()) {
    const i = t;
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new ve()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class TB extends qr {
  constructor(e = new F(), t = new F()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new F()) {
    const i = t;
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new F()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class H1 extends qr {
  constructor(e = new ve(), t = new ve(), i = new ve()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i);
  }
  getPoint(e, t = new ve()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2;
    return i.set(Tf(e, r.x, s.x, o.x), Tf(e, r.y, s.y, o.y)), i;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class z1 extends qr {
  constructor(e = new F(), t = new F(), i = new F()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i);
  }
  getPoint(e, t = new F()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2;
    return (
      i.set(Tf(e, r.x, s.x, o.x), Tf(e, r.y, s.y, o.y), Tf(e, r.z, s.z, o.z)), i
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class G1 extends qr {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new ve()) {
    const i = t,
      r = this.points,
      s = (r.length - 1) * e,
      o = Math.floor(s),
      a = s - o,
      l = r[o === 0 ? o : o - 1],
      u = r[o],
      h = r[o > r.length - 2 ? r.length - 1 : o + 1],
      d = r[o > r.length - 3 ? r.length - 1 : o + 2];
    return i.set(wT(a, l.x, u.x, h.x, d.x), wT(a, l.y, u.y, h.y, d.y)), i;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new ve().fromArray(r));
    }
    return this;
  }
}
var V1 = Object.freeze({
  __proto__: null,
  ArcCurve: MB,
  CatmullRomCurve3: EB,
  CubicBezierCurve: k1,
  CubicBezierCurve3: wB,
  EllipseCurve: Vg,
  LineCurve: Wg,
  LineCurve3: TB,
  QuadraticBezierCurve: H1,
  QuadraticBezierCurve3: z1,
  SplineCurve: G1,
});
class CB extends qr {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new Wg(t, e));
  }
  getPoint(e, t) {
    const i = e * this.getLength(),
      r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const o = r[s] - i,
          a = this.curves[s],
          l = a.getLength(),
          u = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(u, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, r = this.curves.length; i < r; i++)
      (t += this.curves[i].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r],
        a = o.isEllipseCurve
          ? e * 2
          : o.isLineCurve || o.isLineCurve3
          ? 1
          : o.isSplineCurve
          ? e * o.points.length
          : e,
        l = o.getPoints(a);
      for (let u = 0; u < l.length; u++) {
        const h = l[u];
        (i && i.equals(h)) || (t.push(h), (i = h));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(new V1[r.type]().fromJSON(r));
    }
    return this;
  }
}
class rh extends CB {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new ve()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const i = new Wg(this.currentPoint.clone(), new ve(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    const s = new H1(this.currentPoint.clone(), new ve(e, t), new ve(i, r));
    return this.curves.push(s), this.currentPoint.set(i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    const a = new k1(
      this.currentPoint.clone(),
      new ve(e, t),
      new ve(i, r),
      new ve(s, o)
    );
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      i = new G1(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, r, s, o) {
    const a = this.currentPoint.x,
      l = this.currentPoint.y;
    return this.absarc(e + a, t + l, i, r, s, o), this;
  }
  absarc(e, t, i, r, s, o) {
    return this.absellipse(e, t, i, i, r, s, o), this;
  }
  ellipse(e, t, i, r, s, o, a, l) {
    const u = this.currentPoint.x,
      h = this.currentPoint.y;
    return this.absellipse(e + u, t + h, i, r, s, o, a, l), this;
  }
  absellipse(e, t, i, r, s, o, a, l) {
    const u = new Vg(e, t, i, r, s, o, a, l);
    if (this.curves.length > 0) {
      const d = u.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(u);
    const h = u.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Bh extends gt {
  constructor(
    e = [new ve(0, -0.5), new ve(0.5, 0), new ve(0, 0.5)],
    t = 12,
    i = 0,
    r = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }),
      (t = Math.floor(t)),
      (r = vn(r, 0, Math.PI * 2));
    const s = [],
      o = [],
      a = [],
      l = [],
      u = [],
      h = 1 / t,
      d = new F(),
      p = new ve(),
      m = new F(),
      y = new F(),
      M = new F();
    let A = 0,
      g = 0;
    for (let x = 0; x <= e.length - 1; x++)
      switch (x) {
        case 0:
          (A = e[x + 1].x - e[x].x),
            (g = e[x + 1].y - e[x].y),
            (m.x = g * 1),
            (m.y = -A),
            (m.z = g * 0),
            M.copy(m),
            m.normalize(),
            l.push(m.x, m.y, m.z);
          break;
        case e.length - 1:
          l.push(M.x, M.y, M.z);
          break;
        default:
          (A = e[x + 1].x - e[x].x),
            (g = e[x + 1].y - e[x].y),
            (m.x = g * 1),
            (m.y = -A),
            (m.z = g * 0),
            y.copy(m),
            (m.x += M.x),
            (m.y += M.y),
            (m.z += M.z),
            m.normalize(),
            l.push(m.x, m.y, m.z),
            M.copy(y);
      }
    for (let x = 0; x <= t; x++) {
      const _ = i + x * h * r,
        E = Math.sin(_),
        T = Math.cos(_);
      for (let R = 0; R <= e.length - 1; R++) {
        (d.x = e[R].x * E),
          (d.y = e[R].y),
          (d.z = e[R].x * T),
          o.push(d.x, d.y, d.z),
          (p.x = x / t),
          (p.y = R / (e.length - 1)),
          a.push(p.x, p.y);
        const P = l[3 * R + 0] * E,
          B = l[3 * R + 1],
          b = l[3 * R + 0] * T;
        u.push(P, B, b);
      }
    }
    for (let x = 0; x < t; x++)
      for (let _ = 0; _ < e.length - 1; _++) {
        const E = _ + x * e.length,
          T = E,
          R = E + e.length,
          P = E + e.length + 1,
          B = E + 1;
        s.push(T, R, B), s.push(P, B, R);
      }
    this.setIndex(s),
      this.setAttribute("position", new Ye(o, 3)),
      this.setAttribute("uv", new Ye(a, 2)),
      this.setAttribute("normal", new Ye(u, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Bh(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class jg extends Bh {
  constructor(e = 1, t = 1, i = 4, r = 8) {
    const s = new rh();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      s.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(s.getPoints(i), r),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        capSegments: i,
        radialSegments: r,
      });
  }
  static fromJSON(e) {
    return new jg(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Xg extends gt {
  constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: i,
        thetaLength: r,
      }),
      (t = Math.max(3, t));
    const s = [],
      o = [],
      a = [],
      l = [],
      u = new F(),
      h = new ve();
    o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= t; d++, p += 3) {
      const m = i + (d / t) * r;
      (u.x = e * Math.cos(m)),
        (u.y = e * Math.sin(m)),
        o.push(u.x, u.y, u.z),
        a.push(0, 0, 1),
        (h.x = (o[p] / e + 1) / 2),
        (h.y = (o[p + 1] / e + 1) / 2),
        l.push(h.x, h.y);
    }
    for (let d = 1; d <= t; d++) s.push(d, d + 1, 0);
    this.setIndex(s),
      this.setAttribute("position", new Ye(o, 3)),
      this.setAttribute("normal", new Ye(a, 3)),
      this.setAttribute("uv", new Ye(l, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Xg(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class cu extends gt {
  constructor(
    e = 1,
    t = 1,
    i = 1,
    r = 32,
    s = 1,
    o = !1,
    a = 0,
    l = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: i,
        radialSegments: r,
        heightSegments: s,
        openEnded: o,
        thetaStart: a,
        thetaLength: l,
      });
    const u = this;
    (r = Math.floor(r)), (s = Math.floor(s));
    const h = [],
      d = [],
      p = [],
      m = [];
    let y = 0;
    const M = [],
      A = i / 2;
    let g = 0;
    x(),
      o === !1 && (e > 0 && _(!0), t > 0 && _(!1)),
      this.setIndex(h),
      this.setAttribute("position", new Ye(d, 3)),
      this.setAttribute("normal", new Ye(p, 3)),
      this.setAttribute("uv", new Ye(m, 2));
    function x() {
      const E = new F(),
        T = new F();
      let R = 0;
      const P = (t - e) / i;
      for (let B = 0; B <= s; B++) {
        const b = [],
          L = B / s,
          z = L * (t - e) + e;
        for (let $ = 0; $ <= r; $++) {
          const X = $ / r,
            Y = X * l + a,
            K = Math.sin(Y),
            ie = Math.cos(Y);
          (T.x = z * K),
            (T.y = -L * i + A),
            (T.z = z * ie),
            d.push(T.x, T.y, T.z),
            E.set(K, P, ie).normalize(),
            p.push(E.x, E.y, E.z),
            m.push(X, 1 - L),
            b.push(y++);
        }
        M.push(b);
      }
      for (let B = 0; B < r; B++)
        for (let b = 0; b < s; b++) {
          const L = M[b][B],
            z = M[b + 1][B],
            $ = M[b + 1][B + 1],
            X = M[b][B + 1];
          h.push(L, z, X), h.push(z, $, X), (R += 6);
        }
      u.addGroup(g, R, 0), (g += R);
    }
    function _(E) {
      const T = y,
        R = new ve(),
        P = new F();
      let B = 0;
      const b = E === !0 ? e : t,
        L = E === !0 ? 1 : -1;
      for (let $ = 1; $ <= r; $++)
        d.push(0, A * L, 0), p.push(0, L, 0), m.push(0.5, 0.5), y++;
      const z = y;
      for (let $ = 0; $ <= r; $++) {
        const Y = ($ / r) * l + a,
          K = Math.cos(Y),
          ie = Math.sin(Y);
        (P.x = b * ie),
          (P.y = A * L),
          (P.z = b * K),
          d.push(P.x, P.y, P.z),
          p.push(0, L, 0),
          (R.x = K * 0.5 + 0.5),
          (R.y = ie * 0.5 * L + 0.5),
          m.push(R.x, R.y),
          y++;
      }
      for (let $ = 0; $ < r; $++) {
        const X = T + $,
          Y = z + $;
        E === !0 ? h.push(Y, Y + 1, X) : h.push(Y + 1, Y, X), (B += 3);
      }
      u.addGroup(g, B, E === !0 ? 1 : 2), (g += B);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new cu(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Jg extends cu {
  constructor(e = 1, t = 1, i = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, i, r, s, o, a),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: i,
        heightSegments: r,
        openEnded: s,
        thetaStart: o,
        thetaLength: a,
      });
  }
  static fromJSON(e) {
    return new Jg(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class ra extends gt {
  constructor(e = [], t = [], i = 1, r = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: i, detail: r });
    const s = [],
      o = [];
    a(r),
      u(i),
      h(),
      this.setAttribute("position", new Ye(s, 3)),
      this.setAttribute("normal", new Ye(s.slice(), 3)),
      this.setAttribute("uv", new Ye(o, 2)),
      r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(x) {
      const _ = new F(),
        E = new F(),
        T = new F();
      for (let R = 0; R < t.length; R += 3)
        m(t[R + 0], _), m(t[R + 1], E), m(t[R + 2], T), l(_, E, T, x);
    }
    function l(x, _, E, T) {
      const R = T + 1,
        P = [];
      for (let B = 0; B <= R; B++) {
        P[B] = [];
        const b = x.clone().lerp(E, B / R),
          L = _.clone().lerp(E, B / R),
          z = R - B;
        for (let $ = 0; $ <= z; $++)
          $ === 0 && B === R
            ? (P[B][$] = b)
            : (P[B][$] = b.clone().lerp(L, $ / z));
      }
      for (let B = 0; B < R; B++)
        for (let b = 0; b < 2 * (R - B) - 1; b++) {
          const L = Math.floor(b / 2);
          b % 2 === 0
            ? (p(P[B][L + 1]), p(P[B + 1][L]), p(P[B][L]))
            : (p(P[B][L + 1]), p(P[B + 1][L + 1]), p(P[B + 1][L]));
        }
    }
    function u(x) {
      const _ = new F();
      for (let E = 0; E < s.length; E += 3)
        (_.x = s[E + 0]),
          (_.y = s[E + 1]),
          (_.z = s[E + 2]),
          _.normalize().multiplyScalar(x),
          (s[E + 0] = _.x),
          (s[E + 1] = _.y),
          (s[E + 2] = _.z);
    }
    function h() {
      const x = new F();
      for (let _ = 0; _ < s.length; _ += 3) {
        (x.x = s[_ + 0]), (x.y = s[_ + 1]), (x.z = s[_ + 2]);
        const E = A(x) / 2 / Math.PI + 0.5,
          T = g(x) / Math.PI + 0.5;
        o.push(E, 1 - T);
      }
      y(), d();
    }
    function d() {
      for (let x = 0; x < o.length; x += 6) {
        const _ = o[x + 0],
          E = o[x + 2],
          T = o[x + 4],
          R = Math.max(_, E, T),
          P = Math.min(_, E, T);
        R > 0.9 &&
          P < 0.1 &&
          (_ < 0.2 && (o[x + 0] += 1),
          E < 0.2 && (o[x + 2] += 1),
          T < 0.2 && (o[x + 4] += 1));
      }
    }
    function p(x) {
      s.push(x.x, x.y, x.z);
    }
    function m(x, _) {
      const E = x * 3;
      (_.x = e[E + 0]), (_.y = e[E + 1]), (_.z = e[E + 2]);
    }
    function y() {
      const x = new F(),
        _ = new F(),
        E = new F(),
        T = new F(),
        R = new ve(),
        P = new ve(),
        B = new ve();
      for (let b = 0, L = 0; b < s.length; b += 9, L += 6) {
        x.set(s[b + 0], s[b + 1], s[b + 2]),
          _.set(s[b + 3], s[b + 4], s[b + 5]),
          E.set(s[b + 6], s[b + 7], s[b + 8]),
          R.set(o[L + 0], o[L + 1]),
          P.set(o[L + 2], o[L + 3]),
          B.set(o[L + 4], o[L + 5]),
          T.copy(x).add(_).add(E).divideScalar(3);
        const z = A(T);
        M(R, L + 0, x, z), M(P, L + 2, _, z), M(B, L + 4, E, z);
      }
    }
    function M(x, _, E, T) {
      T < 0 && x.x === 1 && (o[_] = x.x - 1),
        E.x === 0 && E.z === 0 && (o[_] = T / 2 / Math.PI + 0.5);
    }
    function A(x) {
      return Math.atan2(x.z, -x.x);
    }
    function g(x) {
      return Math.atan2(-x.y, Math.sqrt(x.x * x.x + x.z * x.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ra(e.vertices, e.indices, e.radius, e.details);
  }
}
class Kg extends ra {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = 1 / i,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        0,
        -i,
        0,
        -r,
        i,
        0,
        -r,
        -i,
        0,
        r,
        i,
        0,
        r,
      ],
      o = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(s, o, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Kg(e.radius, e.detail);
  }
}
const Ip = new F(),
  Dp = new F(),
  Ty = new F(),
  Fp = new Ci();
class bB extends gt {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const r = Math.pow(10, 4),
        s = Math.cos(qa * t),
        o = e.getIndex(),
        a = e.getAttribute("position"),
        l = o ? o.count : a.count,
        u = [0, 0, 0],
        h = ["a", "b", "c"],
        d = new Array(3),
        p = {},
        m = [];
      for (let y = 0; y < l; y += 3) {
        o
          ? ((u[0] = o.getX(y)), (u[1] = o.getX(y + 1)), (u[2] = o.getX(y + 2)))
          : ((u[0] = y), (u[1] = y + 1), (u[2] = y + 2));
        const { a: M, b: A, c: g } = Fp;
        if (
          (M.fromBufferAttribute(a, u[0]),
          A.fromBufferAttribute(a, u[1]),
          g.fromBufferAttribute(a, u[2]),
          Fp.getNormal(Ty),
          (d[0] = `${Math.round(M.x * r)},${Math.round(M.y * r)},${Math.round(
            M.z * r
          )}`),
          (d[1] = `${Math.round(A.x * r)},${Math.round(A.y * r)},${Math.round(
            A.z * r
          )}`),
          (d[2] = `${Math.round(g.x * r)},${Math.round(g.y * r)},${Math.round(
            g.z * r
          )}`),
          !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0]))
        )
          for (let x = 0; x < 3; x++) {
            const _ = (x + 1) % 3,
              E = d[x],
              T = d[_],
              R = Fp[h[x]],
              P = Fp[h[_]],
              B = `${E}_${T}`,
              b = `${T}_${E}`;
            b in p && p[b]
              ? (Ty.dot(p[b].normal) <= s &&
                  (m.push(R.x, R.y, R.z), m.push(P.x, P.y, P.z)),
                (p[b] = null))
              : B in p ||
                (p[B] = { index0: u[x], index1: u[_], normal: Ty.clone() });
          }
      }
      for (const y in p)
        if (p[y]) {
          const { index0: M, index1: A } = p[y];
          Ip.fromBufferAttribute(a, M),
            Dp.fromBufferAttribute(a, A),
            m.push(Ip.x, Ip.y, Ip.z),
            m.push(Dp.x, Dp.y, Dp.z);
        }
      this.setAttribute("position", new Ye(m, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class $a extends rh {
  constructor(e) {
    super(e), (this.uuid = qi()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, r = this.holes.length; i < r; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(new rh().fromJSON(r));
    }
    return this;
  }
}
const x4 = {
  triangulate: function (n, e, t = 2) {
    const i = e && e.length,
      r = i ? e[0] * t : n.length;
    let s = RB(n, 0, r, t, !0);
    const o = [];
    if (!s || s.next === s.prev) return o;
    let a, l, u, h, d, p, m;
    if ((i && (s = E4(n, e, s, t)), n.length > 80 * t)) {
      (a = u = n[0]), (l = h = n[1]);
      for (let y = t; y < r; y += t)
        (d = n[y]),
          (p = n[y + 1]),
          d < a && (a = d),
          p < l && (l = p),
          d > u && (u = d),
          p > h && (h = p);
      (m = Math.max(u - a, h - l)), (m = m !== 0 ? 32767 / m : 0);
    }
    return sh(s, o, t, a, l, m, 0), o;
  },
};
function RB(n, e, t, i, r) {
  let s, o;
  if (r === F4(n, e, t, i) > 0)
    for (s = e; s < t; s += i) o = TT(s, n[s], n[s + 1], o);
  else for (s = t - i; s >= e; s -= i) o = TT(s, n[s], n[s + 1], o);
  return o && Yg(o, o.next) && (ah(o), (o = o.next)), o;
}
function ll(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    i;
  do
    if (
      ((i = !1), !t.steiner && (Yg(t, t.next) || on(t.prev, t, t.next) === 0))
    ) {
      if ((ah(t), (t = e = t.prev), t === t.next)) break;
      i = !0;
    } else t = t.next;
  while (i || t !== e);
  return e;
}
function sh(n, e, t, i, r, s, o) {
  if (!n) return;
  !o && s && R4(n, i, r, s);
  let a = n,
    l,
    u;
  for (; n.prev !== n.next; ) {
    if (((l = n.prev), (u = n.next), s ? A4(n, i, r, s) : _4(n))) {
      e.push((l.i / t) | 0),
        e.push((n.i / t) | 0),
        e.push((u.i / t) | 0),
        ah(n),
        (n = u.next),
        (a = u.next);
      continue;
    }
    if (((n = u), n === a)) {
      o
        ? o === 1
          ? ((n = S4(ll(n), e, t)), sh(n, e, t, i, r, s, 2))
          : o === 2 && M4(n, e, t, i, r, s)
        : sh(ll(n), e, t, i, r, s, 1);
      break;
    }
  }
}
function _4(n) {
  const e = n.prev,
    t = n,
    i = n.next;
  if (on(e, t, i) >= 0) return !1;
  const r = e.x,
    s = t.x,
    o = i.x,
    a = e.y,
    l = t.y,
    u = i.y,
    h = r < s ? (r < o ? r : o) : s < o ? s : o,
    d = a < l ? (a < u ? a : u) : l < u ? l : u,
    p = r > s ? (r > o ? r : o) : s > o ? s : o,
    m = a > l ? (a > u ? a : u) : l > u ? l : u;
  let y = i.next;
  for (; y !== e; ) {
    if (
      y.x >= h &&
      y.x <= p &&
      y.y >= d &&
      y.y <= m &&
      xc(r, a, s, l, o, u, y.x, y.y) &&
      on(y.prev, y, y.next) >= 0
    )
      return !1;
    y = y.next;
  }
  return !0;
}
function A4(n, e, t, i) {
  const r = n.prev,
    s = n,
    o = n.next;
  if (on(r, s, o) >= 0) return !1;
  const a = r.x,
    l = s.x,
    u = o.x,
    h = r.y,
    d = s.y,
    p = o.y,
    m = a < l ? (a < u ? a : u) : l < u ? l : u,
    y = h < d ? (h < p ? h : p) : d < p ? d : p,
    M = a > l ? (a > u ? a : u) : l > u ? l : u,
    A = h > d ? (h > p ? h : p) : d > p ? d : p,
    g = U_(m, y, e, t, i),
    x = U_(M, A, e, t, i);
  let _ = n.prevZ,
    E = n.nextZ;
  for (; _ && _.z >= g && E && E.z <= x; ) {
    if (
      (_.x >= m &&
        _.x <= M &&
        _.y >= y &&
        _.y <= A &&
        _ !== r &&
        _ !== o &&
        xc(a, h, l, d, u, p, _.x, _.y) &&
        on(_.prev, _, _.next) >= 0) ||
      ((_ = _.prevZ),
      E.x >= m &&
        E.x <= M &&
        E.y >= y &&
        E.y <= A &&
        E !== r &&
        E !== o &&
        xc(a, h, l, d, u, p, E.x, E.y) &&
        on(E.prev, E, E.next) >= 0)
    )
      return !1;
    E = E.nextZ;
  }
  for (; _ && _.z >= g; ) {
    if (
      _.x >= m &&
      _.x <= M &&
      _.y >= y &&
      _.y <= A &&
      _ !== r &&
      _ !== o &&
      xc(a, h, l, d, u, p, _.x, _.y) &&
      on(_.prev, _, _.next) >= 0
    )
      return !1;
    _ = _.prevZ;
  }
  for (; E && E.z <= x; ) {
    if (
      E.x >= m &&
      E.x <= M &&
      E.y >= y &&
      E.y <= A &&
      E !== r &&
      E !== o &&
      xc(a, h, l, d, u, p, E.x, E.y) &&
      on(E.prev, E, E.next) >= 0
    )
      return !1;
    E = E.nextZ;
  }
  return !0;
}
function S4(n, e, t) {
  let i = n;
  do {
    const r = i.prev,
      s = i.next.next;
    !Yg(r, s) &&
      PB(r, i, i.next, s) &&
      oh(r, s) &&
      oh(s, r) &&
      (e.push((r.i / t) | 0),
      e.push((i.i / t) | 0),
      e.push((s.i / t) | 0),
      ah(i),
      ah(i.next),
      (i = n = s)),
      (i = i.next);
  } while (i !== n);
  return ll(i);
}
function M4(n, e, t, i, r, s) {
  let o = n;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && L4(o, a)) {
        let l = BB(o, a);
        (o = ll(o, o.next)),
          (l = ll(l, l.next)),
          sh(o, e, t, i, r, s, 0),
          sh(l, e, t, i, r, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n);
}
function E4(n, e, t, i) {
  const r = [];
  let s, o, a, l, u;
  for (s = 0, o = e.length; s < o; s++)
    (a = e[s] * i),
      (l = s < o - 1 ? e[s + 1] * i : n.length),
      (u = RB(n, a, l, i, !1)),
      u === u.next && (u.steiner = !0),
      r.push(B4(u));
  for (r.sort(w4), s = 0; s < r.length; s++) t = T4(r[s], t);
  return t;
}
function w4(n, e) {
  return n.x - e.x;
}
function T4(n, e) {
  const t = C4(n, e);
  if (!t) return e;
  const i = BB(t, n);
  return ll(i, i.next), ll(t, t.next);
}
function C4(n, e) {
  let t = e,
    i = -1 / 0,
    r;
  const s = n.x,
    o = n.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const p = t.x + ((o - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        p <= s &&
        p > i &&
        ((i = p), (r = t.x < t.next.x ? t : t.next), p === s)
      )
        return r;
    }
    t = t.next;
  } while (t !== e);
  if (!r) return null;
  const a = r,
    l = r.x,
    u = r.y;
  let h = 1 / 0,
    d;
  t = r;
  do
    s >= t.x &&
      t.x >= l &&
      s !== t.x &&
      xc(o < u ? s : i, o, l, u, o < u ? i : s, o, t.x, t.y) &&
      ((d = Math.abs(o - t.y) / (s - t.x)),
      oh(t, n) &&
        (d < h || (d === h && (t.x > r.x || (t.x === r.x && b4(r, t))))) &&
        ((r = t), (h = d))),
      (t = t.next);
  while (t !== a);
  return r;
}
function b4(n, e) {
  return on(n.prev, n, e.prev) < 0 && on(e.next, n, n.next) < 0;
}
function R4(n, e, t, i) {
  let r = n;
  do
    r.z === 0 && (r.z = U_(r.x, r.y, e, t, i)),
      (r.prevZ = r.prev),
      (r.nextZ = r.next),
      (r = r.next);
  while (r !== n);
  (r.prevZ.nextZ = null), (r.prevZ = null), P4(r);
}
function P4(n) {
  let e,
    t,
    i,
    r,
    s,
    o,
    a,
    l,
    u = 1;
  do {
    for (t = n, n = null, s = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < u && (a++, (i = i.nextZ), !!i); e++);
      for (l = u; a > 0 || (l > 0 && i); )
        a !== 0 && (l === 0 || !i || t.z <= i.z)
          ? ((r = t), (t = t.nextZ), a--)
          : ((r = i), (i = i.nextZ), l--),
          s ? (s.nextZ = r) : (n = r),
          (r.prevZ = s),
          (s = r);
      t = i;
    }
    (s.nextZ = null), (u *= 2);
  } while (o > 1);
  return n;
}
function U_(n, e, t, i, r) {
  return (
    (n = ((n - t) * r) | 0),
    (e = ((e - i) * r) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function B4(n) {
  let e = n,
    t = n;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== n);
  return t;
}
function xc(n, e, t, i, r, s, o, a) {
  return (
    (r - o) * (e - a) >= (n - o) * (s - a) &&
    (n - o) * (i - a) >= (t - o) * (e - a) &&
    (t - o) * (s - a) >= (r - o) * (i - a)
  );
}
function L4(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !I4(n, e) &&
    ((oh(n, e) &&
      oh(e, n) &&
      D4(n, e) &&
      (on(n.prev, n, e.prev) || on(n, e.prev, e))) ||
      (Yg(n, e) && on(n.prev, n, n.next) > 0 && on(e.prev, e, e.next) > 0))
  );
}
function on(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function Yg(n, e) {
  return n.x === e.x && n.y === e.y;
}
function PB(n, e, t, i) {
  const r = Up(on(n, e, t)),
    s = Up(on(n, e, i)),
    o = Up(on(t, i, n)),
    a = Up(on(t, i, e));
  return !!(
    (r !== s && o !== a) ||
    (r === 0 && Np(n, t, e)) ||
    (s === 0 && Np(n, i, e)) ||
    (o === 0 && Np(t, n, i)) ||
    (a === 0 && Np(t, e, i))
  );
}
function Np(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function Up(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function I4(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      PB(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function oh(n, e) {
  return on(n.prev, n, n.next) < 0
    ? on(n, e, n.next) >= 0 && on(n, n.prev, e) >= 0
    : on(n, e, n.prev) < 0 || on(n, n.next, e) < 0;
}
function D4(n, e) {
  let t = n,
    i = !1;
  const r = (n.x + e.x) / 2,
    s = (n.y + e.y) / 2;
  do
    t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (i = !i),
      (t = t.next);
  while (t !== n);
  return i;
}
function BB(n, e) {
  const t = new O_(n.i, n.x, n.y),
    i = new O_(e.i, e.x, e.y),
    r = n.next,
    s = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = r),
    (r.prev = t),
    (i.next = t),
    (t.prev = i),
    (s.next = i),
    (i.prev = s),
    i
  );
}
function TT(n, e, t, i) {
  const r = new O_(n, e, t);
  return (
    i
      ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function ah(n) {
  (n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function O_(n, e, t) {
  (this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function F4(n, e, t, i) {
  let r = 0;
  for (let s = e, o = t - i; s < t; s += i)
    (r += (n[o] - n[s]) * (n[s + 1] + n[o + 1])), (o = s);
  return r;
}
class gs {
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      i += e[r].x * e[s].y - e[s].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return gs.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [],
      r = [],
      s = [];
    CT(e), bT(i, e);
    let o = e.length;
    t.forEach(CT);
    for (let l = 0; l < t.length; l++)
      r.push(o), (o += t[l].length), bT(i, t[l]);
    const a = x4.triangulate(i, r);
    for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
    return s;
  }
}
function CT(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function bT(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
class Qg extends gt {
  constructor(
    e = new $a([
      new ve(0.5, 0.5),
      new ve(-0.5, 0.5),
      new ve(-0.5, -0.5),
      new ve(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const i = this,
      r = [],
      s = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a];
      o(u);
    }
    this.setAttribute("position", new Ye(r, 3)),
      this.setAttribute("uv", new Ye(s, 2)),
      this.computeVertexNormals();
    function o(a) {
      const l = [],
        u = t.curveSegments !== void 0 ? t.curveSegments : 12,
        h = t.steps !== void 0 ? t.steps : 1,
        d = t.depth !== void 0 ? t.depth : 1;
      let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        m = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        y = t.bevelSize !== void 0 ? t.bevelSize : m - 0.1,
        M = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        A = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const g = t.extrudePath,
        x = t.UVGenerator !== void 0 ? t.UVGenerator : N4;
      let _,
        E = !1,
        T,
        R,
        P,
        B;
      g &&
        ((_ = g.getSpacedPoints(h)),
        (E = !0),
        (p = !1),
        (T = g.computeFrenetFrames(h, !1)),
        (R = new F()),
        (P = new F()),
        (B = new F())),
        p || ((A = 0), (m = 0), (y = 0), (M = 0));
      const b = a.extractPoints(u);
      let L = b.shape;
      const z = b.holes;
      if (!gs.isClockWise(L)) {
        L = L.reverse();
        for (let V = 0, ye = z.length; V < ye; V++) {
          const me = z[V];
          gs.isClockWise(me) && (z[V] = me.reverse());
        }
      }
      const X = gs.triangulateShape(L, z),
        Y = L;
      for (let V = 0, ye = z.length; V < ye; V++) {
        const me = z[V];
        L = L.concat(me);
      }
      function K(V, ye, me) {
        return (
          ye || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          V.clone().addScaledVector(ye, me)
        );
      }
      const ie = L.length,
        ee = X.length;
      function I(V, ye, me) {
        let Ee, _e, We;
        const Oe = V.x - ye.x,
          Ge = V.y - ye.y,
          Ze = me.x - V.x,
          vt = me.y - V.y,
          kt = Oe * Oe + Ge * Ge,
          H = Oe * vt - Ge * Ze;
        if (Math.abs(H) > Number.EPSILON) {
          const D = Math.sqrt(kt),
            ce = Math.sqrt(Ze * Ze + vt * vt),
            we = ye.x - Ge / D,
            Se = ye.y + Oe / D,
            Fe = me.x - vt / ce,
            Ke = me.y + Ze / ce,
            Ie = ((Fe - we) * vt - (Ke - Se) * Ze) / (Oe * vt - Ge * Ze);
          (Ee = we + Oe * Ie - V.x), (_e = Se + Ge * Ie - V.y);
          const de = Ee * Ee + _e * _e;
          if (de <= 2) return new ve(Ee, _e);
          We = Math.sqrt(de / 2);
        } else {
          let D = !1;
          Oe > Number.EPSILON
            ? Ze > Number.EPSILON && (D = !0)
            : Oe < -Number.EPSILON
            ? Ze < -Number.EPSILON && (D = !0)
            : Math.sign(Ge) === Math.sign(vt) && (D = !0),
            D
              ? ((Ee = -Ge), (_e = Oe), (We = Math.sqrt(kt)))
              : ((Ee = Oe), (_e = Ge), (We = Math.sqrt(kt / 2)));
        }
        return new ve(Ee / We, _e / We);
      }
      const G = [];
      for (
        let V = 0, ye = Y.length, me = ye - 1, Ee = V + 1;
        V < ye;
        V++, me++, Ee++
      )
        me === ye && (me = 0),
          Ee === ye && (Ee = 0),
          (G[V] = I(Y[V], Y[me], Y[Ee]));
      const k = [];
      let U,
        j = G.concat();
      for (let V = 0, ye = z.length; V < ye; V++) {
        const me = z[V];
        U = [];
        for (
          let Ee = 0, _e = me.length, We = _e - 1, Oe = Ee + 1;
          Ee < _e;
          Ee++, We++, Oe++
        )
          We === _e && (We = 0),
            Oe === _e && (Oe = 0),
            (U[Ee] = I(me[Ee], me[We], me[Oe]));
        k.push(U), (j = j.concat(U));
      }
      for (let V = 0; V < A; V++) {
        const ye = V / A,
          me = m * Math.cos((ye * Math.PI) / 2),
          Ee = y * Math.sin((ye * Math.PI) / 2) + M;
        for (let _e = 0, We = Y.length; _e < We; _e++) {
          const Oe = K(Y[_e], G[_e], Ee);
          Le(Oe.x, Oe.y, -me);
        }
        for (let _e = 0, We = z.length; _e < We; _e++) {
          const Oe = z[_e];
          U = k[_e];
          for (let Ge = 0, Ze = Oe.length; Ge < Ze; Ge++) {
            const vt = K(Oe[Ge], U[Ge], Ee);
            Le(vt.x, vt.y, -me);
          }
        }
      }
      const he = y + M;
      for (let V = 0; V < ie; V++) {
        const ye = p ? K(L[V], j[V], he) : L[V];
        E
          ? (P.copy(T.normals[0]).multiplyScalar(ye.x),
            R.copy(T.binormals[0]).multiplyScalar(ye.y),
            B.copy(_[0]).add(P).add(R),
            Le(B.x, B.y, B.z))
          : Le(ye.x, ye.y, 0);
      }
      for (let V = 1; V <= h; V++)
        for (let ye = 0; ye < ie; ye++) {
          const me = p ? K(L[ye], j[ye], he) : L[ye];
          E
            ? (P.copy(T.normals[V]).multiplyScalar(me.x),
              R.copy(T.binormals[V]).multiplyScalar(me.y),
              B.copy(_[V]).add(P).add(R),
              Le(B.x, B.y, B.z))
            : Le(me.x, me.y, (d / h) * V);
        }
      for (let V = A - 1; V >= 0; V--) {
        const ye = V / A,
          me = m * Math.cos((ye * Math.PI) / 2),
          Ee = y * Math.sin((ye * Math.PI) / 2) + M;
        for (let _e = 0, We = Y.length; _e < We; _e++) {
          const Oe = K(Y[_e], G[_e], Ee);
          Le(Oe.x, Oe.y, d + me);
        }
        for (let _e = 0, We = z.length; _e < We; _e++) {
          const Oe = z[_e];
          U = k[_e];
          for (let Ge = 0, Ze = Oe.length; Ge < Ze; Ge++) {
            const vt = K(Oe[Ge], U[Ge], Ee);
            E
              ? Le(vt.x, vt.y + _[h - 1].y, _[h - 1].x + me)
              : Le(vt.x, vt.y, d + me);
          }
        }
      }
      ae(), xe();
      function ae() {
        const V = r.length / 3;
        if (p) {
          let ye = 0,
            me = ie * ye;
          for (let Ee = 0; Ee < ee; Ee++) {
            const _e = X[Ee];
            Ve(_e[2] + me, _e[1] + me, _e[0] + me);
          }
          (ye = h + A * 2), (me = ie * ye);
          for (let Ee = 0; Ee < ee; Ee++) {
            const _e = X[Ee];
            Ve(_e[0] + me, _e[1] + me, _e[2] + me);
          }
        } else {
          for (let ye = 0; ye < ee; ye++) {
            const me = X[ye];
            Ve(me[2], me[1], me[0]);
          }
          for (let ye = 0; ye < ee; ye++) {
            const me = X[ye];
            Ve(me[0] + ie * h, me[1] + ie * h, me[2] + ie * h);
          }
        }
        i.addGroup(V, r.length / 3 - V, 0);
      }
      function xe() {
        const V = r.length / 3;
        let ye = 0;
        Ae(Y, ye), (ye += Y.length);
        for (let me = 0, Ee = z.length; me < Ee; me++) {
          const _e = z[me];
          Ae(_e, ye), (ye += _e.length);
        }
        i.addGroup(V, r.length / 3 - V, 1);
      }
      function Ae(V, ye) {
        let me = V.length;
        for (; --me >= 0; ) {
          const Ee = me;
          let _e = me - 1;
          _e < 0 && (_e = V.length - 1);
          for (let We = 0, Oe = h + A * 2; We < Oe; We++) {
            const Ge = ie * We,
              Ze = ie * (We + 1),
              vt = ye + Ee + Ge,
              kt = ye + _e + Ge,
              H = ye + _e + Ze,
              D = ye + Ee + Ze;
            ct(vt, kt, H, D);
          }
        }
      }
      function Le(V, ye, me) {
        l.push(V), l.push(ye), l.push(me);
      }
      function Ve(V, ye, me) {
        tt(V), tt(ye), tt(me);
        const Ee = r.length / 3,
          _e = x.generateTopUV(i, r, Ee - 3, Ee - 2, Ee - 1);
        Me(_e[0]), Me(_e[1]), Me(_e[2]);
      }
      function ct(V, ye, me, Ee) {
        tt(V), tt(ye), tt(Ee), tt(ye), tt(me), tt(Ee);
        const _e = r.length / 3,
          We = x.generateSideWallUV(i, r, _e - 6, _e - 3, _e - 2, _e - 1);
        Me(We[0]), Me(We[1]), Me(We[3]), Me(We[1]), Me(We[2]), Me(We[3]);
      }
      function tt(V) {
        r.push(l[V * 3 + 0]), r.push(l[V * 3 + 1]), r.push(l[V * 3 + 2]);
      }
      function Me(V) {
        s.push(V.x), s.push(V.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      i = this.parameters.options;
    return U4(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]];
      i.push(a);
    }
    const r = e.options.extrudePath;
    return (
      r !== void 0 && (e.options.extrudePath = new V1[r.type]().fromJSON(r)),
      new Qg(i, e.options)
    );
  }
}
const N4 = {
  generateTopUV: function (n, e, t, i, r) {
    const s = e[t * 3],
      o = e[t * 3 + 1],
      a = e[i * 3],
      l = e[i * 3 + 1],
      u = e[r * 3],
      h = e[r * 3 + 1];
    return [new ve(s, o), new ve(a, l), new ve(u, h)];
  },
  generateSideWallUV: function (n, e, t, i, r, s) {
    const o = e[t * 3],
      a = e[t * 3 + 1],
      l = e[t * 3 + 2],
      u = e[i * 3],
      h = e[i * 3 + 1],
      d = e[i * 3 + 2],
      p = e[r * 3],
      m = e[r * 3 + 1],
      y = e[r * 3 + 2],
      M = e[s * 3],
      A = e[s * 3 + 1],
      g = e[s * 3 + 2];
    return Math.abs(a - h) < Math.abs(o - u)
      ? [new ve(o, 1 - l), new ve(u, 1 - d), new ve(p, 1 - y), new ve(M, 1 - g)]
      : [
          new ve(a, 1 - l),
          new ve(h, 1 - d),
          new ve(m, 1 - y),
          new ve(A, 1 - g),
        ];
  },
};
function U4(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i];
      t.shapes.push(s.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class qg extends ra {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(r, s, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new qg(e.radius, e.detail);
  }
}
class Lh extends ra {
  constructor(e = 1, t = 0) {
    const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      r = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(i, r, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Lh(e.radius, e.detail);
  }
}
class Zg extends gt {
  constructor(e = 0.5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: i,
        phiSegments: r,
        thetaStart: s,
        thetaLength: o,
      }),
      (i = Math.max(3, i)),
      (r = Math.max(1, r));
    const a = [],
      l = [],
      u = [],
      h = [];
    let d = e;
    const p = (t - e) / r,
      m = new F(),
      y = new ve();
    for (let M = 0; M <= r; M++) {
      for (let A = 0; A <= i; A++) {
        const g = s + (A / i) * o;
        (m.x = d * Math.cos(g)),
          (m.y = d * Math.sin(g)),
          l.push(m.x, m.y, m.z),
          u.push(0, 0, 1),
          (y.x = (m.x / t + 1) / 2),
          (y.y = (m.y / t + 1) / 2),
          h.push(y.x, y.y);
      }
      d += p;
    }
    for (let M = 0; M < r; M++) {
      const A = M * (i + 1);
      for (let g = 0; g < i; g++) {
        const x = g + A,
          _ = x,
          E = x + i + 1,
          T = x + i + 2,
          R = x + 1;
        a.push(_, E, R), a.push(E, T, R);
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new Ye(l, 3)),
      this.setAttribute("normal", new Ye(u, 3)),
      this.setAttribute("uv", new Ye(h, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Zg(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class $g extends gt {
  constructor(
    e = new $a([new ve(0, 0.5), new ve(-0.5, -0.5), new ve(0.5, -0.5)]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const i = [],
      r = [],
      s = [],
      o = [];
    let a = 0,
      l = 0;
    if (Array.isArray(e) === !1) u(e);
    else
      for (let h = 0; h < e.length; h++)
        u(e[h]), this.addGroup(a, l, h), (a += l), (l = 0);
    this.setIndex(i),
      this.setAttribute("position", new Ye(r, 3)),
      this.setAttribute("normal", new Ye(s, 3)),
      this.setAttribute("uv", new Ye(o, 2));
    function u(h) {
      const d = r.length / 3,
        p = h.extractPoints(t);
      let m = p.shape;
      const y = p.holes;
      gs.isClockWise(m) === !1 && (m = m.reverse());
      for (let A = 0, g = y.length; A < g; A++) {
        const x = y[A];
        gs.isClockWise(x) === !0 && (y[A] = x.reverse());
      }
      const M = gs.triangulateShape(m, y);
      for (let A = 0, g = y.length; A < g; A++) {
        const x = y[A];
        m = m.concat(x);
      }
      for (let A = 0, g = m.length; A < g; A++) {
        const x = m[A];
        r.push(x.x, x.y, 0), s.push(0, 0, 1), o.push(x.x, x.y);
      }
      for (let A = 0, g = M.length; A < g; A++) {
        const x = M[A],
          _ = x[0] + d,
          E = x[1] + d,
          T = x[2] + d;
        i.push(_, E, T), (l += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return O4(t, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const o = t[e.shapes[r]];
      i.push(o);
    }
    return new $g(i, e.curveSegments);
  }
}
function O4(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, i = n.length; t < i; t++) {
      const r = n[t];
      e.shapes.push(r.uuid);
    }
  else e.shapes.push(n.uuid);
  return e;
}
class Ih extends gt {
  constructor(
    e = 1,
    t = 32,
    i = 16,
    r = 0,
    s = Math.PI * 2,
    o = 0,
    a = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: i,
        phiStart: r,
        phiLength: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (i = Math.max(2, Math.floor(i)));
    const l = Math.min(o + a, Math.PI);
    let u = 0;
    const h = [],
      d = new F(),
      p = new F(),
      m = [],
      y = [],
      M = [],
      A = [];
    for (let g = 0; g <= i; g++) {
      const x = [],
        _ = g / i;
      let E = 0;
      g === 0 && o === 0
        ? (E = 0.5 / t)
        : g === i && l === Math.PI && (E = -0.5 / t);
      for (let T = 0; T <= t; T++) {
        const R = T / t;
        (d.x = -e * Math.cos(r + R * s) * Math.sin(o + _ * a)),
          (d.y = e * Math.cos(o + _ * a)),
          (d.z = e * Math.sin(r + R * s) * Math.sin(o + _ * a)),
          y.push(d.x, d.y, d.z),
          p.copy(d).normalize(),
          M.push(p.x, p.y, p.z),
          A.push(R + E, 1 - _),
          x.push(u++);
      }
      h.push(x);
    }
    for (let g = 0; g < i; g++)
      for (let x = 0; x < t; x++) {
        const _ = h[g][x + 1],
          E = h[g][x],
          T = h[g + 1][x],
          R = h[g + 1][x + 1];
        (g !== 0 || o > 0) && m.push(_, E, R),
          (g !== i - 1 || l < Math.PI) && m.push(E, T, R);
      }
    this.setIndex(m),
      this.setAttribute("position", new Ye(y, 3)),
      this.setAttribute("normal", new Ye(M, 3)),
      this.setAttribute("uv", new Ye(A, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ih(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class e0 extends ra {
  constructor(e = 1, t = 0) {
    const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(i, r, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new e0(e.radius, e.detail);
  }
}
class t0 extends gt {
  constructor(e = 1, t = 0.4, i = 12, r = 48, s = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: i,
        tubularSegments: r,
        arc: s,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r));
    const o = [],
      a = [],
      l = [],
      u = [],
      h = new F(),
      d = new F(),
      p = new F();
    for (let m = 0; m <= i; m++)
      for (let y = 0; y <= r; y++) {
        const M = (y / r) * s,
          A = (m / i) * Math.PI * 2;
        (d.x = (e + t * Math.cos(A)) * Math.cos(M)),
          (d.y = (e + t * Math.cos(A)) * Math.sin(M)),
          (d.z = t * Math.sin(A)),
          a.push(d.x, d.y, d.z),
          (h.x = e * Math.cos(M)),
          (h.y = e * Math.sin(M)),
          p.subVectors(d, h).normalize(),
          l.push(p.x, p.y, p.z),
          u.push(y / r),
          u.push(m / i);
      }
    for (let m = 1; m <= i; m++)
      for (let y = 1; y <= r; y++) {
        const M = (r + 1) * m + y - 1,
          A = (r + 1) * (m - 1) + y - 1,
          g = (r + 1) * (m - 1) + y,
          x = (r + 1) * m + y;
        o.push(M, A, x), o.push(A, g, x);
      }
    this.setIndex(o),
      this.setAttribute("position", new Ye(a, 3)),
      this.setAttribute("normal", new Ye(l, 3)),
      this.setAttribute("uv", new Ye(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new t0(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class n0 extends gt {
  constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, o = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: i,
        radialSegments: r,
        p: s,
        q: o,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r));
    const a = [],
      l = [],
      u = [],
      h = [],
      d = new F(),
      p = new F(),
      m = new F(),
      y = new F(),
      M = new F(),
      A = new F(),
      g = new F();
    for (let _ = 0; _ <= i; ++_) {
      const E = (_ / i) * s * Math.PI * 2;
      x(E, s, o, e, m),
        x(E + 0.01, s, o, e, y),
        A.subVectors(y, m),
        g.addVectors(y, m),
        M.crossVectors(A, g),
        g.crossVectors(M, A),
        M.normalize(),
        g.normalize();
      for (let T = 0; T <= r; ++T) {
        const R = (T / r) * Math.PI * 2,
          P = -t * Math.cos(R),
          B = t * Math.sin(R);
        (d.x = m.x + (P * g.x + B * M.x)),
          (d.y = m.y + (P * g.y + B * M.y)),
          (d.z = m.z + (P * g.z + B * M.z)),
          l.push(d.x, d.y, d.z),
          p.subVectors(d, m).normalize(),
          u.push(p.x, p.y, p.z),
          h.push(_ / i),
          h.push(T / r);
      }
    }
    for (let _ = 1; _ <= i; _++)
      for (let E = 1; E <= r; E++) {
        const T = (r + 1) * (_ - 1) + (E - 1),
          R = (r + 1) * _ + (E - 1),
          P = (r + 1) * _ + E,
          B = (r + 1) * (_ - 1) + E;
        a.push(T, R, B), a.push(R, P, B);
      }
    this.setIndex(a),
      this.setAttribute("position", new Ye(l, 3)),
      this.setAttribute("normal", new Ye(u, 3)),
      this.setAttribute("uv", new Ye(h, 2));
    function x(_, E, T, R, P) {
      const B = Math.cos(_),
        b = Math.sin(_),
        L = (T / E) * _,
        z = Math.cos(L);
      (P.x = R * (2 + z) * 0.5 * B),
        (P.y = R * (2 + z) * b * 0.5),
        (P.z = R * Math.sin(L) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new n0(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class i0 extends gt {
  constructor(
    e = new z1(new F(-1, -1, 0), new F(-1, 1, 0), new F(1, 1, 0)),
    t = 64,
    i = 1,
    r = 8,
    s = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: i,
        radialSegments: r,
        closed: s,
      });
    const o = e.computeFrenetFrames(t, s);
    (this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals);
    const a = new F(),
      l = new F(),
      u = new ve();
    let h = new F();
    const d = [],
      p = [],
      m = [],
      y = [];
    M(),
      this.setIndex(y),
      this.setAttribute("position", new Ye(d, 3)),
      this.setAttribute("normal", new Ye(p, 3)),
      this.setAttribute("uv", new Ye(m, 2));
    function M() {
      for (let _ = 0; _ < t; _++) A(_);
      A(s === !1 ? t : 0), x(), g();
    }
    function A(_) {
      h = e.getPointAt(_ / t, h);
      const E = o.normals[_],
        T = o.binormals[_];
      for (let R = 0; R <= r; R++) {
        const P = (R / r) * Math.PI * 2,
          B = Math.sin(P),
          b = -Math.cos(P);
        (l.x = b * E.x + B * T.x),
          (l.y = b * E.y + B * T.y),
          (l.z = b * E.z + B * T.z),
          l.normalize(),
          p.push(l.x, l.y, l.z),
          (a.x = h.x + i * l.x),
          (a.y = h.y + i * l.y),
          (a.z = h.z + i * l.z),
          d.push(a.x, a.y, a.z);
      }
    }
    function g() {
      for (let _ = 1; _ <= t; _++)
        for (let E = 1; E <= r; E++) {
          const T = (r + 1) * (_ - 1) + (E - 1),
            R = (r + 1) * _ + (E - 1),
            P = (r + 1) * _ + E,
            B = (r + 1) * (_ - 1) + E;
          y.push(T, R, B), y.push(R, P, B);
        }
    }
    function x() {
      for (let _ = 0; _ <= t; _++)
        for (let E = 0; E <= r; E++)
          (u.x = _ / t), (u.y = E / r), m.push(u.x, u.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new i0(
      new V1[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class LB extends gt {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        i = new Set(),
        r = new F(),
        s = new F();
      if (e.index !== null) {
        const o = e.attributes.position,
          a = e.index;
        let l = e.groups;
        l.length === 0 &&
          (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let u = 0, h = l.length; u < h; ++u) {
          const d = l[u],
            p = d.start,
            m = d.count;
          for (let y = p, M = p + m; y < M; y += 3)
            for (let A = 0; A < 3; A++) {
              const g = a.getX(y + A),
                x = a.getX(y + ((A + 1) % 3));
              r.fromBufferAttribute(o, g),
                s.fromBufferAttribute(o, x),
                RT(r, s, i) === !0 &&
                  (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, l = o.count / 3; a < l; a++)
          for (let u = 0; u < 3; u++) {
            const h = 3 * a + u,
              d = 3 * a + ((u + 1) % 3);
            r.fromBufferAttribute(o, h),
              s.fromBufferAttribute(o, d),
              RT(r, s, i) === !0 &&
                (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new Ye(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function RT(n, e, t) {
  const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0);
}
var PT = Object.freeze({
  __proto__: null,
  BoxGeometry: hl,
  CapsuleGeometry: jg,
  CircleGeometry: Xg,
  ConeGeometry: Jg,
  CylinderGeometry: cu,
  DodecahedronGeometry: Kg,
  EdgesGeometry: bB,
  ExtrudeGeometry: Qg,
  IcosahedronGeometry: qg,
  LatheGeometry: Bh,
  OctahedronGeometry: Lh,
  PlaneGeometry: Ch,
  PolyhedronGeometry: ra,
  RingGeometry: Zg,
  ShapeGeometry: $g,
  SphereGeometry: Ih,
  TetrahedronGeometry: e0,
  TorusGeometry: t0,
  TorusKnotGeometry: n0,
  TubeGeometry: i0,
  WireframeGeometry: LB,
});
class IB extends bn {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new Ue(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class DB extends As {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class Dh extends bn {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Ue(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ue(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ia),
      (this.normalScale = new ve(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Ms extends Dh {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new ve(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return vn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Ue(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Ue(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Ue(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class FB extends bn {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Ue(16777215)),
      (this.specular = new Ue(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ue(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ia),
      (this.normalScale = new ve(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Mh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class NB extends bn {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Ue(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ue(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ia),
      (this.normalScale = new ve(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class UB extends bn {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ia),
      (this.normalScale = new ve(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class OB extends bn {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Ue(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ue(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ia),
      (this.normalScale = new ve(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Mh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class kB extends bn {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Ue(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ia),
      (this.normalScale = new ve(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class HB extends ci {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function vr(n, e, t) {
  return W1(n)
    ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length))
    : n.slice(e, t);
}
function Wa(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(n)
    : Array.prototype.slice.call(n);
}
function W1(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function zB(n) {
  function e(r, s) {
    return n[r] - n[s];
  }
  const t = n.length,
    i = new Array(t);
  for (let r = 0; r !== t; ++r) i[r] = r;
  return i.sort(e), i;
}
function k_(n, e, t) {
  const i = n.length,
    r = new n.constructor(i);
  for (let s = 0, o = 0; o !== i; ++s) {
    const a = t[s] * e;
    for (let l = 0; l !== e; ++l) r[o++] = n[a + l];
  }
  return r;
}
function j1(n, e, t, i) {
  let r = 1,
    s = n[0];
  for (; s !== void 0 && s[i] === void 0; ) s = n[r++];
  if (s === void 0) return;
  let o = s[i];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), t.push.apply(t, o)),
          (s = n[r++]);
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
          (s = n[r++]);
      while (s !== void 0);
    else
      do (o = s[i]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[r++]);
      while (s !== void 0);
}
function k4(n, e, t, i, r = 30) {
  const s = n.clone();
  s.name = e;
  const o = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const u = s.tracks[l],
      h = u.getValueSize(),
      d = [],
      p = [];
    for (let m = 0; m < u.times.length; ++m) {
      const y = u.times[m] * r;
      if (!(y < t || y >= i)) {
        d.push(u.times[m]);
        for (let M = 0; M < h; ++M) p.push(u.values[m * h + M]);
      }
    }
    d.length !== 0 &&
      ((u.times = Wa(d, u.times.constructor)),
      (u.values = Wa(p, u.values.constructor)),
      o.push(u));
  }
  s.tracks = o;
  let a = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l)
    a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
  return s.resetDuration(), s;
}
function H4(n, e = 0, t = n, i = 30) {
  i <= 0 && (i = 30);
  const r = t.tracks.length,
    s = e / i;
  for (let o = 0; o < r; ++o) {
    const a = t.tracks[o],
      l = a.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const u = n.tracks.find(function (g) {
      return g.name === a.name && g.ValueTypeName === l;
    });
    if (u === void 0) continue;
    let h = 0;
    const d = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (h = d / 3);
    let p = 0;
    const m = u.getValueSize();
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (p = m / 3);
    const y = a.times.length - 1;
    let M;
    if (s <= a.times[0]) {
      const g = h,
        x = d - h;
      M = vr(a.values, g, x);
    } else if (s >= a.times[y]) {
      const g = y * d + h,
        x = g + d - h;
      M = vr(a.values, g, x);
    } else {
      const g = a.createInterpolant(),
        x = h,
        _ = d - h;
      g.evaluate(s), (M = vr(g.resultBuffer, x, _));
    }
    l === "quaternion" &&
      new Wn().fromArray(M).normalize().conjugate().toArray(M);
    const A = u.times.length;
    for (let g = 0; g < A; ++g) {
      const x = g * m + p;
      if (l === "quaternion")
        Wn.multiplyQuaternionsFlat(u.values, x, M, 0, u.values, x);
      else {
        const _ = m - p * 2;
        for (let E = 0; E < _; ++E) u.values[x + E] -= M[E];
      }
    }
  }
  return (n.blendMode = v1), n;
}
const z4 = {
  arraySlice: vr,
  convertArray: Wa,
  isTypedArray: W1,
  getKeyframeOrder: zB,
  sortedArray: k_,
  flattenJSON: j1,
  subclip: k4,
  makeClipAdditive: H4,
};
class uu {
  constructor(e, t, i, r) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex,
      r = t[i],
      s = t[i - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i;
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
              }
              if (i === a) break;
              if (((s = r), (r = t[++i]), e < r)) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && ((i = 2), (s = a));
            for (let l = i - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (i === l) break;
              if (((r = s), (s = t[--i - 1]), e >= s)) break t;
            }
            (o = i), (i = 0);
            break n;
          }
          break e;
        }
        for (; i < o; ) {
          const a = (i + o) >>> 1;
          e < t[a] ? (o = a) : (i = a + 1);
        }
        if (((r = t[i]), (s = t[i - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (r === void 0)
          return (
            (i = t.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          );
      }
      (this._cachedIndex = i), this.intervalChanged_(i, s, r);
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r;
    for (let o = 0; o !== r; ++o) t[o] = i[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class GB extends uu {
  constructor(e, t, i, r) {
    super(e, t, i, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: za, endingEnd: za });
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      a = r[s],
      l = r[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case Ga:
          (s = e), (a = 2 * t - i);
          break;
        case eh:
          (s = r.length - 2), (a = t + r[s] - r[s + 1]);
          break;
        default:
          (s = e), (a = i);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case Ga:
          (o = e), (l = 2 * i - t);
          break;
        case eh:
          (o = 1), (l = i + r[1] - r[0]);
          break;
        default:
          (o = e - 1), (l = t);
      }
    const u = (i - t) * 0.5,
      h = this.valueSize;
    (this._weightPrev = u / (t - a)),
      (this._weightNext = u / (l - i)),
      (this._offsetPrev = s * h),
      (this._offsetNext = o * h);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      u = l - a,
      h = this._offsetPrev,
      d = this._offsetNext,
      p = this._weightPrev,
      m = this._weightNext,
      y = (i - t) / (r - t),
      M = y * y,
      A = M * y,
      g = -p * A + 2 * p * M - p * y,
      x = (1 + p) * A + (-1.5 - 2 * p) * M + (-0.5 + p) * y + 1,
      _ = (-1 - m) * A + (1.5 + m) * M + 0.5 * y,
      E = m * A - m * M;
    for (let T = 0; T !== a; ++T)
      s[T] = g * o[h + T] + x * o[u + T] + _ * o[l + T] + E * o[d + T];
    return s;
  }
}
class X1 extends uu {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      u = l - a,
      h = (i - t) / (r - t),
      d = 1 - h;
    for (let p = 0; p !== a; ++p) s[p] = o[u + p] * d + o[l + p] * h;
    return s;
  }
}
class VB extends uu {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Zr {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = Wa(t, this.TimeBufferType)),
      (this.values = Wa(i, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: Wa(e.times, Array),
        values: Wa(e.values, Array),
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return (i.type = e.ValueTypeName), i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new VB(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new X1(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new GB(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Jc:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case al:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case vm:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Jc;
      case this.InterpolantFactoryMethodLinear:
        return al;
      case this.InterpolantFactoryMethodSmooth:
        return vm;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times,
      r = i.length;
    let s = 0,
      o = r - 1;
    for (; s !== r && i[s] < e; ) ++s;
    for (; o !== -1 && i[o] > t; ) --o;
    if ((++o, s !== 0 || o !== r)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const a = this.getValueSize();
      (this.times = vr(i, s, o)), (this.values = vr(this.values, s * a, o * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const i = this.times,
      r = this.values,
      s = i.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = i[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          l
        ),
          (e = !1);
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
          (e = !1);
        break;
      }
      o = l;
    }
    if (r !== void 0 && W1(r))
      for (let a = 0, l = r.length; a !== l; ++a) {
        const u = r[a];
        if (isNaN(u)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            u
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = vr(this.times),
      t = vr(this.values),
      i = this.getValueSize(),
      r = this.getInterpolation() === vm,
      s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const u = e[a],
        h = e[a + 1];
      if (u !== h && (a !== 1 || u !== e[0]))
        if (r) l = !0;
        else {
          const d = a * i,
            p = d - i,
            m = d + i;
          for (let y = 0; y !== i; ++y) {
            const M = t[d + y];
            if (M !== t[p + y] || M !== t[m + y]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const d = a * i,
            p = o * i;
          for (let m = 0; m !== i; ++m) t[p + m] = t[d + m];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * i, l = o * i, u = 0; u !== i; ++u) t[l + u] = t[a + u];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = vr(e, 0, o)), (this.values = vr(t, 0, o * i)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = vr(this.times, 0),
      t = vr(this.values, 0),
      i = this.constructor,
      r = new i(this.name, e, t);
    return (r.createInterpolant = this.createInterpolant), r;
  }
}
Zr.prototype.TimeBufferType = Float32Array;
Zr.prototype.ValueBufferType = Float32Array;
Zr.prototype.DefaultInterpolation = al;
class dl extends Zr {}
dl.prototype.ValueTypeName = "bool";
dl.prototype.ValueBufferType = Array;
dl.prototype.DefaultInterpolation = Jc;
dl.prototype.InterpolantFactoryMethodLinear = void 0;
dl.prototype.InterpolantFactoryMethodSmooth = void 0;
class J1 extends Zr {}
J1.prototype.ValueTypeName = "color";
class qc extends Zr {}
qc.prototype.ValueTypeName = "number";
class WB extends uu {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = (i - t) / (r - t);
    let u = e * a;
    for (let h = u + a; u !== h; u += 4) Wn.slerpFlat(s, 0, o, u - a, o, u, l);
    return s;
  }
}
class qo extends Zr {
  InterpolantFactoryMethodLinear(e) {
    return new WB(this.times, this.values, this.getValueSize(), e);
  }
}
qo.prototype.ValueTypeName = "quaternion";
qo.prototype.DefaultInterpolation = al;
qo.prototype.InterpolantFactoryMethodSmooth = void 0;
class pl extends Zr {}
pl.prototype.ValueTypeName = "string";
pl.prototype.ValueBufferType = Array;
pl.prototype.DefaultInterpolation = Jc;
pl.prototype.InterpolantFactoryMethodLinear = void 0;
pl.prototype.InterpolantFactoryMethodSmooth = void 0;
class Zc extends Zr {}
Zc.prototype.ValueTypeName = "vector";
class $c {
  constructor(e, t = -1, i, r = Ng) {
    (this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = qi()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      r = 1 / (e.fps || 1);
    for (let o = 0, a = i.length; o !== a; ++o) t.push(V4(i[o]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, o = i.length; s !== o; ++s) t.push(Zr.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length,
      o = [];
    for (let a = 0; a < s; a++) {
      let l = [],
        u = [];
      l.push((a + s - 1) % s, a, (a + 1) % s), u.push(0, 1, 0);
      const h = zB(l);
      (l = k_(l, 1, h)),
        (u = k_(u, 1, h)),
        !r && l[0] === 0 && (l.push(s), u.push(u[0])),
        o.push(
          new qc(".morphTargetInfluences[" + t[a].name + "]", l, u).scale(1 / i)
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = (r.geometry && r.geometry.animations) || r.animations;
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a],
        h = u.name.match(s);
      if (h && h.length > 1) {
        const d = h[1];
        let p = r[d];
        p || (r[d] = p = []), p.push(u);
      }
    }
    const o = [];
    for (const a in r)
      o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const i = function (d, p, m, y, M) {
        if (m.length !== 0) {
          const A = [],
            g = [];
          j1(m, A, g, y), A.length !== 0 && M.push(new d(p, A, g));
        }
      },
      r = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let l = e.length || -1;
    const u = e.hierarchy || [];
    for (let d = 0; d < u.length; d++) {
      const p = u[d].keys;
      if (!(!p || p.length === 0))
        if (p[0].morphTargets) {
          const m = {};
          let y;
          for (y = 0; y < p.length; y++)
            if (p[y].morphTargets)
              for (let M = 0; M < p[y].morphTargets.length; M++)
                m[p[y].morphTargets[M]] = -1;
          for (const M in m) {
            const A = [],
              g = [];
            for (let x = 0; x !== p[y].morphTargets.length; ++x) {
              const _ = p[y];
              A.push(_.time), g.push(_.morphTarget === M ? 1 : 0);
            }
            r.push(new qc(".morphTargetInfluence[" + M + "]", A, g));
          }
          l = m.length * o;
        } else {
          const m = ".bones[" + t[d].name + "]";
          i(Zc, m + ".position", p, "pos", r),
            i(qo, m + ".quaternion", p, "rot", r),
            i(Zc, m + ".scale", p, "scl", r);
        }
    }
    return r.length === 0 ? null : new this(s, l, r, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function G4(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return qc;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Zc;
    case "color":
      return J1;
    case "quaternion":
      return qo;
    case "bool":
    case "boolean":
      return dl;
    case "string":
      return pl;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function V4(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = G4(n.type);
  if (n.times === void 0) {
    const t = [],
      i = [];
    j1(n.keys, t, i, "value"), (n.times = t), (n.values = i);
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const cl = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class K1 {
  constructor(e, t, i) {
    const r = this;
    let s = !1,
      o = 0,
      a = 0,
      l;
    const u = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (h) {
        a++, s === !1 && r.onStart !== void 0 && r.onStart(h, o, a), (s = !0);
      }),
      (this.itemEnd = function (h) {
        o++,
          r.onProgress !== void 0 && r.onProgress(h, o, a),
          o === a && ((s = !1), r.onLoad !== void 0 && r.onLoad());
      }),
      (this.itemError = function (h) {
        r.onError !== void 0 && r.onError(h);
      }),
      (this.resolveURL = function (h) {
        return l ? l(h) : h;
      }),
      (this.setURLModifier = function (h) {
        return (l = h), this;
      }),
      (this.addHandler = function (h, d) {
        return u.push(h, d), this;
      }),
      (this.removeHandler = function (h) {
        const d = u.indexOf(h);
        return d !== -1 && u.splice(d, 2), this;
      }),
      (this.getHandler = function (h) {
        for (let d = 0, p = u.length; d < p; d += 2) {
          const m = u[d],
            y = u[d + 1];
          if ((m.global && (m.lastIndex = 0), m.test(h))) return y;
        }
        return null;
      });
  }
}
const _c = new K1();
class ui {
  constructor(e) {
    (this.manager = e !== void 0 ? e : _c),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.load(e, r, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
ui.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Ns = {};
class W4 extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class $i extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = cl.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (Ns[e] !== void 0) {
      Ns[e].push({ onLoad: t, onProgress: i, onError: r });
      return;
    }
    (Ns[e] = []), Ns[e].push({ onLoad: t, onProgress: i, onError: r });
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      l = this.responseType;
    fetch(o)
      .then((u) => {
        if (u.status === 200 || u.status === 0) {
          if (
            (u.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              u.body === void 0 ||
              u.body.getReader === void 0)
          )
            return u;
          const h = Ns[e],
            d = u.body.getReader(),
            p = u.headers.get("Content-Length") || u.headers.get("X-File-Size"),
            m = p ? parseInt(p) : 0,
            y = m !== 0;
          let M = 0;
          const A = new ReadableStream({
            start(g) {
              x();
              function x() {
                d.read().then(({ done: _, value: E }) => {
                  if (_) g.close();
                  else {
                    M += E.byteLength;
                    const T = new ProgressEvent("progress", {
                      lengthComputable: y,
                      loaded: M,
                      total: m,
                    });
                    for (let R = 0, P = h.length; R < P; R++) {
                      const B = h[R];
                      B.onProgress && B.onProgress(T);
                    }
                    g.enqueue(E), x();
                  }
                });
              }
            },
          });
          return new Response(A);
        } else
          throw new W4(
            `fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,
            u
          );
      })
      .then((u) => {
        switch (l) {
          case "arraybuffer":
            return u.arrayBuffer();
          case "blob":
            return u.blob();
          case "document":
            return u.text().then((h) => new DOMParser().parseFromString(h, a));
          case "json":
            return u.json();
          default:
            if (a === void 0) return u.text();
            {
              const d = /charset="?([^;"\s]*)"?/i.exec(a),
                p = d && d[1] ? d[1].toLowerCase() : void 0,
                m = new TextDecoder(p);
              return u.arrayBuffer().then((y) => m.decode(y));
            }
        }
      })
      .then((u) => {
        cl.add(e, u);
        const h = Ns[e];
        delete Ns[e];
        for (let d = 0, p = h.length; d < p; d++) {
          const m = h[d];
          m.onLoad && m.onLoad(u);
        }
      })
      .catch((u) => {
        const h = Ns[e];
        if (h === void 0) throw (this.manager.itemError(e), u);
        delete Ns[e];
        for (let d = 0, p = h.length; d < p; d++) {
          const m = h[d];
          m.onError && m.onError(u);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class j4 extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new $i(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            r ? r(l) : console.error(l), s.manager.itemError(e);
          }
        },
        i,
        r
      );
  }
  parse(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const r = $c.parse(e[i]);
      t.push(r);
    }
    return t;
  }
}
class X4 extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = [],
      a = new U1(),
      l = new $i(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(s.withCredentials);
    let u = 0;
    function h(d) {
      l.load(
        e[d],
        function (p) {
          const m = s.parse(p, !0);
          (o[d] = {
            width: m.width,
            height: m.height,
            format: m.format,
            mipmaps: m.mipmaps,
          }),
            (u += 1),
            u === 6 &&
              (m.mipmapCount === 1 && (a.minFilter = sn),
              (a.image = o),
              (a.format = m.format),
              (a.needsUpdate = !0),
              t && t(a));
        },
        i,
        r
      );
    }
    if (Array.isArray(e)) for (let d = 0, p = e.length; d < p; ++d) h(d);
    else
      l.load(
        e,
        function (d) {
          const p = s.parse(d, !0);
          if (p.isCubemap) {
            const m = p.mipmaps.length / p.mipmapCount;
            for (let y = 0; y < m; y++) {
              o[y] = { mipmaps: [] };
              for (let M = 0; M < p.mipmapCount; M++)
                o[y].mipmaps.push(p.mipmaps[y * p.mipmapCount + M]),
                  (o[y].format = p.format),
                  (o[y].width = p.width),
                  (o[y].height = p.height);
            }
            a.image = o;
          } else
            (a.image.width = p.width),
              (a.image.height = p.height),
              (a.mipmaps = p.mipmaps);
          p.mipmapCount === 1 && (a.minFilter = sn),
            (a.format = p.format),
            (a.needsUpdate = !0),
            t && t(a);
        },
        i,
        r
      );
    return a;
  }
}
class lh extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = cl.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = ih("img");
    function l() {
      h(), cl.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function u(d) {
      h(), r && r(d), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function h() {
      a.removeEventListener("load", l, !1),
        a.removeEventListener("error", u, !1);
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", u, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class J4 extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new Th();
    s.colorSpace = mt;
    const o = new lh(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(u) {
      o.load(
        e[u],
        function (h) {
          (s.images[u] = h), a++, a === 6 && ((s.needsUpdate = !0), t && t(s));
        },
        void 0,
        r
      );
    }
    for (let u = 0; u < e.length; ++u) l(u);
    return s;
  }
}
class K4 extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Dc(),
      a = new $i(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (l) {
          const u = s.parse(l);
          u &&
            (u.image !== void 0
              ? (o.image = u.image)
              : u.data !== void 0 &&
                ((o.image.width = u.width),
                (o.image.height = u.height),
                (o.image.data = u.data)),
            (o.wrapS = u.wrapS !== void 0 ? u.wrapS : Kn),
            (o.wrapT = u.wrapT !== void 0 ? u.wrapT : Kn),
            (o.magFilter = u.magFilter !== void 0 ? u.magFilter : sn),
            (o.minFilter = u.minFilter !== void 0 ? u.minFilter : sn),
            (o.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1),
            u.colorSpace !== void 0
              ? (o.colorSpace = u.colorSpace)
              : u.encoding !== void 0 && (o.encoding = u.encoding),
            u.flipY !== void 0 && (o.flipY = u.flipY),
            u.format !== void 0 && (o.format = u.format),
            u.type !== void 0 && (o.type = u.type),
            u.mipmaps !== void 0 &&
              ((o.mipmaps = u.mipmaps), (o.minFilter = _s)),
            u.mipmapCount === 1 && (o.minFilter = sn),
            u.generateMipmaps !== void 0 &&
              (o.generateMipmaps = u.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, u));
        },
        i,
        r
      ),
      o
    );
  }
}
class jB extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new en(),
      o = new lh(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        i,
        r
      ),
      s
    );
  }
}
class sa extends Rt {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Ue(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
class XB extends sa {
  constructor(e, t, i) {
    super(e, i),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Rt.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Ue(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const Cy = new rt(),
  BT = new F(),
  LT = new F();
class Y1 {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new ve(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new rt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Og()),
      (this._frameExtents = new ve(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Ut(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix;
    BT.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(BT),
      LT.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(LT),
      t.updateMatrixWorld(),
      Cy.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Cy),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(Cy);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class Y4 extends Y1 {
  constructor() {
    super(new $t(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      i = Kc * 2 * e.angle * this.focus,
      r = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    (i !== t.fov || r !== t.aspect || s !== t.far) &&
      ((t.fov = i), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class Q1 extends sa {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Rt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Rt()),
      (this.distance = i),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new Y4());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const IT = new rt(),
  Yu = new F(),
  by = new F();
class Q4 extends Y1 {
  constructor() {
    super(new $t(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new ve(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Ut(2, 1, 1, 1),
        new Ut(0, 1, 1, 1),
        new Ut(3, 1, 1, 1),
        new Ut(1, 1, 1, 1),
        new Ut(3, 0, 1, 1),
        new Ut(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new F(1, 0, 0),
        new F(-1, 0, 0),
        new F(0, 0, 1),
        new F(0, 0, -1),
        new F(0, 1, 0),
        new F(0, -1, 0),
      ]),
      (this._cubeUps = [
        new F(0, 1, 0),
        new F(0, 1, 0),
        new F(0, 1, 0),
        new F(0, 1, 0),
        new F(0, 0, 1),
        new F(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      r = this.matrix,
      s = e.distance || i.far;
    s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      Yu.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(Yu),
      by.copy(i.position),
      by.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(by),
      i.updateMatrixWorld(),
      r.makeTranslation(-Yu.x, -Yu.y, -Yu.z),
      IT.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(IT);
  }
}
class q1 extends sa {
  constructor(e, t, i = 0, r = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = i),
      (this.decay = r),
      (this.shadow = new Q4());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class q4 extends Y1 {
  constructor() {
    super(new Wr(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class Z1 extends sa {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Rt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Rt()),
      (this.shadow = new q4());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class JB extends sa {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class KB extends sa {
  constructor(e, t, i = 10, r = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = i),
      (this.height = r);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class YB {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new F());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.282095),
      t.addScaledVector(o[1], 0.488603 * r),
      t.addScaledVector(o[2], 0.488603 * s),
      t.addScaledVector(o[3], 0.488603 * i),
      t.addScaledVector(o[4], 1.092548 * (i * r)),
      t.addScaledVector(o[5], 1.092548 * (r * s)),
      t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(o[7], 1.092548 * (i * s)),
      t.addScaledVector(o[8], 0.546274 * (i * i - r * r)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.886227),
      t.addScaledVector(o[1], 2 * 0.511664 * r),
      t.addScaledVector(o[2], 2 * 0.511664 * s),
      t.addScaledVector(o[3], 2 * 0.511664 * i),
      t.addScaledVector(o[4], 2 * 0.429043 * i * r),
      t.addScaledVector(o[5], 2 * 0.429043 * r * s),
      t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(o[7], 2 * 0.429043 * i * s),
      t.addScaledVector(o[8], 0.429043 * (i * i - r * r)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].fromArray(e, t + r * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].toArray(e, t + r * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * r),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * i),
      (t[4] = 1.092548 * i * r),
      (t[5] = 1.092548 * r * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * i * s),
      (t[8] = 0.546274 * (i * i - r * r));
  }
}
class r0 extends sa {
  constructor(e = new YB(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class s0 extends ui {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, i, r) {
    const s = this,
      o = new $i(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            r ? r(l) : console.error(l), s.manager.itemError(e);
          }
        },
        i,
        r
      );
  }
  parse(e) {
    const t = this.textures;
    function i(s) {
      return (
        t[s] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", s),
        t[s]
      );
    }
    const r = s0.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (r.uuid = e.uuid),
      e.name !== void 0 && (r.name = e.name),
      e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
      e.roughness !== void 0 && (r.roughness = e.roughness),
      e.metalness !== void 0 && (r.metalness = e.metalness),
      e.sheen !== void 0 && (r.sheen = e.sheen),
      e.sheenColor !== void 0 && (r.sheenColor = new Ue().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        r.emissive !== void 0 &&
        r.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        r.specular !== void 0 &&
        r.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (r.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        r.specularColor !== void 0 &&
        r.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (r.shininess = e.shininess),
      e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = e.clearcoatRoughness),
      e.iridescence !== void 0 && (r.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (r.transmission = e.transmission),
      e.thickness !== void 0 && (r.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (r.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        r.attenuationColor !== void 0 &&
        r.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (r.fog = e.fog),
      e.flatShading !== void 0 && (r.flatShading = e.flatShading),
      e.blending !== void 0 && (r.blending = e.blending),
      e.combine !== void 0 && (r.combine = e.combine),
      e.side !== void 0 && (r.side = e.side),
      e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (r.opacity = e.opacity),
      e.transparent !== void 0 && (r.transparent = e.transparent),
      e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash),
      e.depthTest !== void 0 && (r.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
      e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
      e.stencilWriteMask !== void 0 &&
        (r.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
      e.wireframe !== void 0 && (r.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (r.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (r.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (r.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (r.rotation = e.rotation),
      e.linewidth !== 1 && (r.linewidth = e.linewidth),
      e.dashSize !== void 0 && (r.dashSize = e.dashSize),
      e.gapSize !== void 0 && (r.gapSize = e.gapSize),
      e.scale !== void 0 && (r.scale = e.scale),
      e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (r.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (r.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (r.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (r.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (r.visible = e.visible),
      e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
      e.userData !== void 0 && (r.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (r.vertexColors = e.vertexColors > 0)
          : (r.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const o = e.uniforms[s];
        switch (((r.uniforms[s] = {}), o.type)) {
          case "t":
            r.uniforms[s].value = i(o.value);
            break;
          case "c":
            r.uniforms[s].value = new Ue().setHex(o.value);
            break;
          case "v2":
            r.uniforms[s].value = new ve().fromArray(o.value);
            break;
          case "v3":
            r.uniforms[s].value = new F().fromArray(o.value);
            break;
          case "v4":
            r.uniforms[s].value = new Ut().fromArray(o.value);
            break;
          case "m3":
            r.uniforms[s].value = new _t().fromArray(o.value);
            break;
          case "m4":
            r.uniforms[s].value = new rt().fromArray(o.value);
            break;
          default:
            r.uniforms[s].value = o.value;
        }
      }
    if (
      (e.defines !== void 0 && (r.defines = e.defines),
      e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) r.extensions[s] = e.extensions[s];
    if (
      (e.lights !== void 0 && (r.lights = e.lights),
      e.clipping !== void 0 && (r.clipping = e.clipping),
      e.size !== void 0 && (r.size = e.size),
      e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (r.map = i(e.map)),
      e.matcap !== void 0 && (r.matcap = i(e.matcap)),
      e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
      e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
      e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
      e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]),
        (r.normalScale = new ve().fromArray(s));
    }
    return (
      e.displacementMap !== void 0 &&
        (r.displacementMap = i(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (r.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (r.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
      e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
      e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (r.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (r.specularIntensityMap = i(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (r.specularColorMap = i(e.specularColorMap)),
      e.envMap !== void 0 && (r.envMap = i(e.envMap)),
      e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (r.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
      e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
      e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (r.clearcoatNormalScale = new ve().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (r.transmissionMap = i(e.transmissionMap)),
      e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
      r
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: IB,
      SpriteMaterial: L1,
      RawShaderMaterial: DB,
      ShaderMaterial: As,
      PointsMaterial: Ph,
      MeshPhysicalMaterial: Ms,
      MeshStandardMaterial: Dh,
      MeshPhongMaterial: FB,
      MeshToonMaterial: NB,
      MeshNormalMaterial: UB,
      MeshLambertMaterial: OB,
      MeshDepthMaterial: R1,
      MeshDistanceMaterial: P1,
      MeshBasicMaterial: Ji,
      MeshMatcapMaterial: kB,
      LineDashedMaterial: HB,
      LineBasicMaterial: ci,
      Material: bn,
    };
    return new t[e]();
  }
}
class vs {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class QB extends gt {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class qB extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new $i(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            r ? r(l) : console.error(l), s.manager.itemError(e);
          }
        },
        i,
        r
      );
  }
  parse(e) {
    const t = {},
      i = {};
    function r(m, y) {
      if (t[y] !== void 0) return t[y];
      const A = m.interleavedBuffers[y],
        g = s(m, A.buffer),
        x = vc(A.type, g),
        _ = new bh(x, A.stride);
      return (_.uuid = A.uuid), (t[y] = _), _;
    }
    function s(m, y) {
      if (i[y] !== void 0) return i[y];
      const A = m.arrayBuffers[y],
        g = new Uint32Array(A).buffer;
      return (i[y] = g), g;
    }
    const o = e.isInstancedBufferGeometry ? new QB() : new gt(),
      a = e.data.index;
    if (a !== void 0) {
      const m = vc(a.type, a.array);
      o.setIndex(new Ft(m, 1));
    }
    const l = e.data.attributes;
    for (const m in l) {
      const y = l[m];
      let M;
      if (y.isInterleavedBufferAttribute) {
        const A = r(e.data, y.data);
        M = new Qo(A, y.itemSize, y.offset, y.normalized);
      } else {
        const A = vc(y.type, y.array),
          g = y.isInstancedBufferAttribute ? Qc : Ft;
        M = new g(A, y.itemSize, y.normalized);
      }
      y.name !== void 0 && (M.name = y.name),
        y.usage !== void 0 && M.setUsage(y.usage),
        y.updateRange !== void 0 &&
          ((M.updateRange.offset = y.updateRange.offset),
          (M.updateRange.count = y.updateRange.count)),
        o.setAttribute(m, M);
    }
    const u = e.data.morphAttributes;
    if (u)
      for (const m in u) {
        const y = u[m],
          M = [];
        for (let A = 0, g = y.length; A < g; A++) {
          const x = y[A];
          let _;
          if (x.isInterleavedBufferAttribute) {
            const E = r(e.data, x.data);
            _ = new Qo(E, x.itemSize, x.offset, x.normalized);
          } else {
            const E = vc(x.type, x.array);
            _ = new Ft(E, x.itemSize, x.normalized);
          }
          x.name !== void 0 && (_.name = x.name), M.push(_);
        }
        o.morphAttributes[m] = M;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const d = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (d !== void 0)
      for (let m = 0, y = d.length; m !== y; ++m) {
        const M = d[m];
        o.addGroup(M.start, M.count, M.materialIndex);
      }
    const p = e.data.boundingSphere;
    if (p !== void 0) {
      const m = new F();
      p.center !== void 0 && m.fromArray(p.center),
        (o.boundingSphere = new Tr(m, p.radius));
    }
    return (
      e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
    );
  }
}
class Z4 extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = this.path === "" ? vs.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new $i(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (l) {
          let u = null;
          try {
            u = JSON.parse(l);
          } catch (d) {
            r !== void 0 && r(d),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                d.message
              );
            return;
          }
          const h = u.metadata;
          if (
            h === void 0 ||
            h.type === void 0 ||
            h.type.toLowerCase() === "geometry"
          ) {
            r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          s.parse(u, t);
        },
        i,
        r
      );
  }
  async loadAsync(e, t) {
    const i = this,
      r = this.path === "" ? vs.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const s = new $i(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials);
    const o = await s.loadAsync(e, t),
      a = JSON.parse(o),
      l = a.metadata;
    if (
      l === void 0 ||
      l.type === void 0 ||
      l.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i.parseAsync(a);
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, r),
      o = this.parseImages(e.images, function () {
        t !== void 0 && t(u);
      }),
      a = this.parseTextures(e.textures, o),
      l = this.parseMaterials(e.materials, a),
      u = this.parseObject(e.object, s, l, a, i),
      h = this.parseSkeletons(e.skeletons, u);
    if ((this.bindSkeletons(u, h), t !== void 0)) {
      let d = !1;
      for (const p in o)
        if (o[p].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && t(u);
    }
    return u;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      r = this.parseGeometries(e.geometries, i),
      s = await this.parseImagesAsync(e.images),
      o = this.parseTextures(e.textures, s),
      a = this.parseMaterials(e.materials, o),
      l = this.parseObject(e.object, r, a, o, t),
      u = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, u), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0, r = e.length; i < r; i++) {
        const s = new $a().fromJSON(e[i]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const i = {},
      r = {};
    if (
      (t.traverse(function (s) {
        s.isBone && (r[s.uuid] = s);
      }),
      e !== void 0)
    )
      for (let s = 0, o = e.length; s < o; s++) {
        const a = new Rh().fromJSON(e[s], r);
        i[a.uuid] = a;
      }
    return i;
  }
  parseGeometries(e, t) {
    const i = {};
    if (e !== void 0) {
      const r = new qB();
      for (let s = 0, o = e.length; s < o; s++) {
        let a;
        const l = e[s];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = r.parse(l);
            break;
          default:
            l.type in PT
              ? (a = PT[l.type].fromJSON(l, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${l.type}"`
                );
        }
        (a.uuid = l.uuid),
          l.name !== void 0 && (a.name = l.name),
          l.userData !== void 0 && (a.userData = l.userData),
          (i[l.uuid] = a);
      }
    }
    return i;
  }
  parseMaterials(e, t) {
    const i = {},
      r = {};
    if (e !== void 0) {
      const s = new s0();
      s.setTextures(t);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)),
          (r[l.uuid] = i[l.uuid]);
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const r = e[i],
          s = $c.parse(r);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const i = this,
      r = {};
    let s;
    function o(l) {
      return (
        i.manager.itemStart(l),
        s.load(
          l,
          function () {
            i.manager.itemEnd(l);
          },
          void 0,
          function () {
            i.manager.itemError(l), i.manager.itemEnd(l);
          }
        )
      );
    }
    function a(l) {
      if (typeof l == "string") {
        const u = l,
          h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : i.resourcePath + u;
        return o(h);
      } else
        return l.data
          ? { data: vc(l.type, l.data), width: l.width, height: l.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new K1(t);
      (s = new lh(l)), s.setCrossOrigin(this.crossOrigin);
      for (let u = 0, h = e.length; u < h; u++) {
        const d = e[u],
          p = d.url;
        if (Array.isArray(p)) {
          const m = [];
          for (let y = 0, M = p.length; y < M; y++) {
            const A = p[y],
              g = a(A);
            g !== null &&
              (g instanceof HTMLImageElement
                ? m.push(g)
                : m.push(new Dc(g.data, g.width, g.height)));
          }
          r[d.uuid] = new Va(m);
        } else {
          const m = a(d.url);
          r[d.uuid] = new Va(m);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this,
      i = {};
    let r;
    async function s(o) {
      if (typeof o == "string") {
        const a = o,
          l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await r.loadAsync(l);
      } else
        return o.data
          ? { data: vc(o.type, o.data), width: o.width, height: o.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (r = new lh(this.manager)), r.setCrossOrigin(this.crossOrigin);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o],
          u = l.url;
        if (Array.isArray(u)) {
          const h = [];
          for (let d = 0, p = u.length; d < p; d++) {
            const m = u[d],
              y = await s(m);
            y !== null &&
              (y instanceof HTMLImageElement
                ? h.push(y)
                : h.push(new Dc(y.data, y.width, y.height)));
          }
          i[l.uuid] = new Va(h);
        } else {
          const h = await s(l.url);
          i[l.uuid] = new Va(h);
        }
      }
    }
    return i;
  }
  parseTextures(e, t) {
    function i(s, o) {
      return typeof s == "number"
        ? s
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            s
          ),
          o[s]);
    }
    const r = {};
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s];
        a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
          t[a.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = t[a.image],
          u = l.data;
        let h;
        Array.isArray(u)
          ? ((h = new Th()), u.length === 6 && (h.needsUpdate = !0))
          : (u && u.data ? (h = new Dc()) : (h = new en()),
            u && (h.needsUpdate = !0)),
          (h.source = l),
          (h.uuid = a.uuid),
          a.name !== void 0 && (h.name = a.name),
          a.mapping !== void 0 && (h.mapping = i(a.mapping, $4)),
          a.channel !== void 0 && (h.channel = a.channel),
          a.offset !== void 0 && h.offset.fromArray(a.offset),
          a.repeat !== void 0 && h.repeat.fromArray(a.repeat),
          a.center !== void 0 && h.center.fromArray(a.center),
          a.rotation !== void 0 && (h.rotation = a.rotation),
          a.wrap !== void 0 &&
            ((h.wrapS = i(a.wrap[0], DT)), (h.wrapT = i(a.wrap[1], DT))),
          a.format !== void 0 && (h.format = a.format),
          a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat),
          a.type !== void 0 && (h.type = a.type),
          a.colorSpace !== void 0 && (h.colorSpace = a.colorSpace),
          a.encoding !== void 0 && (h.encoding = a.encoding),
          a.minFilter !== void 0 && (h.minFilter = i(a.minFilter, FT)),
          a.magFilter !== void 0 && (h.magFilter = i(a.magFilter, FT)),
          a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy),
          a.flipY !== void 0 && (h.flipY = a.flipY),
          a.generateMipmaps !== void 0 &&
            (h.generateMipmaps = a.generateMipmaps),
          a.premultiplyAlpha !== void 0 &&
            (h.premultiplyAlpha = a.premultiplyAlpha),
          a.unpackAlignment !== void 0 &&
            (h.unpackAlignment = a.unpackAlignment),
          a.compareFunction !== void 0 &&
            (h.compareFunction = a.compareFunction),
          a.userData !== void 0 && (h.userData = a.userData),
          (r[a.uuid] = h);
      }
    return r;
  }
  parseObject(e, t, i, r, s) {
    let o;
    function a(p) {
      return (
        t[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", p),
        t[p]
      );
    }
    function l(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          const m = [];
          for (let y = 0, M = p.length; y < M; y++) {
            const A = p[y];
            i[A] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", A),
              m.push(i[A]);
          }
          return m;
        }
        return (
          i[p] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", p),
          i[p]
        );
      }
    }
    function u(p) {
      return (
        r[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", p),
        r[p]
      );
    }
    let h, d;
    switch (e.type) {
      case "Scene":
        (o = new $m()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (o.background = new Ue(e.background))
              : (o.background = u(e.background))),
          e.environment !== void 0 && (o.environment = u(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (o.fog = new zg(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (o.fog = new Hg(e.fog.color, e.fog.density))),
          e.backgroundBlurriness !== void 0 &&
            (o.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (o.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        (o = new $t(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (o.focus = e.focus),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (o = new Wr(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new JB(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new Z1(e.color, e.intensity);
        break;
      case "PointLight":
        o = new q1(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new KB(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new Q1(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        );
        break;
      case "HemisphereLight":
        o = new XB(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new r0().fromJSON(e);
        break;
      case "SkinnedMesh":
        (h = a(e.geometry)),
          (d = l(e.material)),
          (o = new I1(h, d)),
          e.bindMode !== void 0 && (o.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        (h = a(e.geometry)), (d = l(e.material)), (o = new Gn(h, d));
        break;
      case "InstancedMesh":
        (h = a(e.geometry)), (d = l(e.material));
        const p = e.count,
          m = e.instanceMatrix,
          y = e.instanceColor;
        (o = new D1(h, d, p)),
          (o.instanceMatrix = new Qc(new Float32Array(m.array), 16)),
          y !== void 0 &&
            (o.instanceColor = new Qc(new Float32Array(y.array), y.itemSize));
        break;
      case "LOD":
        o = new SB();
        break;
      case "Line":
        o = new $s(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        o = new F1(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        o = new Qr(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new N1(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        o = new AB(l(e.material));
        break;
      case "Group":
        o = new Vs();
        break;
      case "Bone":
        o = new Gg();
        break;
      default:
        o = new Rt();
    }
    if (
      ((o.uuid = e.uuid),
      e.name !== void 0 && (o.name = e.name),
      e.matrix !== void 0
        ? (o.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (o.matrixAutoUpdate = e.matrixAutoUpdate),
          o.matrixAutoUpdate &&
            o.matrix.decompose(o.position, o.quaternion, o.scale))
        : (e.position !== void 0 && o.position.fromArray(e.position),
          e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && o.scale.fromArray(e.scale)),
      e.up !== void 0 && o.up.fromArray(e.up),
      e.castShadow !== void 0 && (o.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (o.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (o.visible = e.visible),
      e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
      e.userData !== void 0 && (o.userData = e.userData),
      e.layers !== void 0 && (o.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const p = e.children;
      for (let m = 0; m < p.length; m++)
        o.add(this.parseObject(p[m], t, i, r, s));
    }
    if (e.animations !== void 0) {
      const p = e.animations;
      for (let m = 0; m < p.length; m++) {
        const y = p[m];
        o.animations.push(s[y]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const p = e.levels;
      for (let m = 0; m < p.length; m++) {
        const y = p[m],
          M = o.getObjectByProperty("uuid", y.object);
        M !== void 0 && o.addLevel(M, y.distance, y.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (i) {
        if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
          const r = t[i.skeleton];
          r === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                i.skeleton
              )
            : i.bind(r, i.bindMatrix);
        }
      });
  }
}
const $4 = {
    UVMapping: Ig,
    CubeReflectionMapping: Jo,
    CubeRefractionMapping: Ko,
    EquirectangularReflectionMapping: qf,
    EquirectangularRefractionMapping: Zf,
    CubeUVReflectionMapping: ou,
  },
  DT = {
    RepeatWrapping: Yo,
    ClampToEdgeWrapping: Kn,
    MirroredRepeatWrapping: jc,
  },
  FT = {
    NearestFilter: gn,
    NearestMipmapNearestFilter: $f,
    NearestMipmapLinearFilter: Lc,
    LinearFilter: sn,
    LinearMipmapNearestFilter: Dg,
    LinearMipmapLinearFilter: _s,
  };
class ZB extends ui {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = cl.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader),
      fetch(e, a)
        .then(function (l) {
          return l.blob();
        })
        .then(function (l) {
          return createImageBitmap(
            l,
            Object.assign(s.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (l) {
          cl.add(e, l), t && t(l), s.manager.itemEnd(e);
        })
        .catch(function (l) {
          r && r(l), s.manager.itemError(e), s.manager.itemEnd(e);
        }),
      s.manager.itemStart(e);
  }
}
let Op;
class $1 {
  static getContext() {
    return (
      Op === void 0 &&
        (Op = new (window.AudioContext || window.webkitAudioContext)()),
      Op
    );
  }
  static setContext(e) {
    Op = e;
  }
}
class eV extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new $i(this.manager);
    o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (l) {
          try {
            const u = l.slice(0);
            $1.getContext().decodeAudioData(
              u,
              function (d) {
                t(d);
              },
              a
            );
          } catch (u) {
            a(u);
          }
        },
        i,
        r
      );
    function a(l) {
      r ? r(l) : console.error(l), s.manager.itemError(e);
    }
  }
}
class tV extends r0 {
  constructor(e, t, i = 1) {
    super(void 0, i), (this.isHemisphereLightProbe = !0);
    const r = new Ue().set(e),
      s = new Ue().set(t),
      o = new F(r.r, r.g, r.b),
      a = new F(s.r, s.g, s.b),
      l = Math.sqrt(Math.PI),
      u = l * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),
      this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(u);
  }
}
class nV extends r0 {
  constructor(e, t = 1) {
    super(void 0, t), (this.isAmbientLightProbe = !0);
    const i = new Ue().set(e);
    this.sh.coefficients[0]
      .set(i.r, i.g, i.b)
      .multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
const NT = new rt(),
  UT = new rt(),
  _a = new rt();
class iV {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new $t()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new $t()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        _a.copy(e.projectionMatrix);
      const r = t.eyeSep / 2,
        s = (r * t.near) / t.focus,
        o = (t.near * Math.tan(qa * t.fov * 0.5)) / t.zoom;
      let a, l;
      (UT.elements[12] = -r),
        (NT.elements[12] = r),
        (a = -o * t.aspect + s),
        (l = o * t.aspect + s),
        (_a.elements[0] = (2 * t.near) / (l - a)),
        (_a.elements[8] = (l + a) / (l - a)),
        this.cameraL.projectionMatrix.copy(_a),
        (a = -o * t.aspect - s),
        (l = o * t.aspect - s),
        (_a.elements[0] = (2 * t.near) / (l - a)),
        (_a.elements[8] = (l + a) / (l - a)),
        this.cameraR.projectionMatrix.copy(_a);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(UT),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(NT);
  }
}
class eS {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = OT()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = OT();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function OT() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Aa = new F(),
  kT = new Wn(),
  rV = new F(),
  Sa = new F();
class sV extends Rt {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = $1.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new eS());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      i = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(Aa, kT, rV),
      Sa.set(0, 0, -1).applyQuaternion(kT),
      t.positionX)
    ) {
      const r = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Aa.x, r),
        t.positionY.linearRampToValueAtTime(Aa.y, r),
        t.positionZ.linearRampToValueAtTime(Aa.z, r),
        t.forwardX.linearRampToValueAtTime(Sa.x, r),
        t.forwardY.linearRampToValueAtTime(Sa.y, r),
        t.forwardZ.linearRampToValueAtTime(Sa.z, r),
        t.upX.linearRampToValueAtTime(i.x, r),
        t.upY.linearRampToValueAtTime(i.y, r),
        t.upZ.linearRampToValueAtTime(i.z, r);
    } else
      t.setPosition(Aa.x, Aa.y, Aa.z),
        t.setOrientation(Sa.x, Sa.y, Sa.z, i.x, i.y, i.z);
  }
}
class $B extends Rt {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else this.source.disconnect(this.getOutput());
    return (this._connected = !1), this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    if (((this.detune = e), this.source.detune !== void 0))
      return (
        this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
}
const Ma = new F(),
  HT = new Wn(),
  oV = new F(),
  Ea = new F();
class aV extends $B {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, i) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = i),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(Ma, HT, oV), Ea.set(0, 0, 1).applyQuaternion(HT);
    const t = this.panner;
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Ma.x, i),
        t.positionY.linearRampToValueAtTime(Ma.y, i),
        t.positionZ.linearRampToValueAtTime(Ma.z, i),
        t.orientationX.linearRampToValueAtTime(Ea.x, i),
        t.orientationY.linearRampToValueAtTime(Ea.y, i),
        t.orientationZ.linearRampToValueAtTime(Ea.z, i);
    } else t.setPosition(Ma.x, Ma.y, Ma.z), t.setOrientation(Ea.x, Ea.y, Ea.z);
  }
}
class lV {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let i = 0; i < t.length; i++) e += t[i];
    return e / t.length;
  }
}
class eL {
  constructor(e, t, i) {
    (this.binding = e), (this.valueSize = i);
    let r, s, o;
    switch (t) {
      case "quaternion":
        (r = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(i * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (r = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(i * 5));
        break;
      default:
        (r = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(i * 5));
    }
    (this._mixBufferRegion = r),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const i = this.buffer,
      r = this.valueSize,
      s = e * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== r; ++a) i[s + a] = i[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(i, s, 0, a, r);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      i = this.valueSize,
      r = i * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, r, 0, e, i),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      i = this.buffer,
      r = e * t + t,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const l = t * this._origIndex;
      this._mixBufferRegion(i, r, l, 1 - s, t);
    }
    o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
    for (let l = t, u = t + t; l !== u; ++l)
      if (i[l] !== i[l + t]) {
        a.setValue(i, r);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      i = this.valueSize,
      r = i * this._origIndex;
    e.getValue(t, r);
    for (let s = i, o = r; s !== o; ++s) t[s] = t[r + (s % i)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let i = e; i < t; i++) this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  _select(e, t, i, r, s) {
    if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[i + o];
  }
  _slerp(e, t, i, r) {
    Wn.slerpFlat(e, t, e, t, e, i, r);
  }
  _slerpAdditive(e, t, i, r, s) {
    const o = this._workIndex * s;
    Wn.multiplyQuaternionsFlat(e, o, e, t, e, i),
      Wn.slerpFlat(e, t, e, t, e, o, r);
  }
  _lerp(e, t, i, r, s) {
    const o = 1 - r;
    for (let a = 0; a !== s; ++a) {
      const l = t + a;
      e[l] = e[l] * o + e[i + a] * r;
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o;
      e[a] = e[a] + e[i + o] * r;
    }
  }
}
const tS = "\\[\\]\\.:\\/",
  cV = new RegExp("[" + tS + "]", "g"),
  nS = "[^" + tS + "]",
  uV = "[^" + tS.replace("\\.", "") + "]",
  fV = /((?:WC+[\/:])*)/.source.replace("WC", nS),
  hV = /(WCOD+)?/.source.replace("WCOD", uV),
  dV = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", nS),
  pV = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", nS),
  mV = new RegExp("^" + fV + hV + dV + pV + "$"),
  gV = ["material", "materials", "bones", "map"];
class vV {
  constructor(e, t, i) {
    const r = i || bt.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_,
      r = this._bindings[i];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class bt {
  constructor(e, t, i) {
    (this.path = t),
      (this.parsedPath = i || bt.parseTrackName(t)),
      (this.node = bt.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new bt.Composite(e, t, i)
      : new bt(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(cV, "");
  }
  static parseTrackName(e) {
    const t = mV.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      gV.indexOf(s) !== -1 &&
        ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s));
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return i;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0) return i;
    }
    if (e.children) {
      const i = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.name === t || a.uuid === t) return a;
            const l = i(a.children);
            if (l) return l;
          }
          return null;
        },
        r = i(e.children);
      if (r) return r;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      i = t.objectName,
      r = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = bt.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.error(
        "THREE.PropertyBinding: Trying to update node for track: " +
          this.path +
          " but it wasn't found."
      );
      return;
    }
    if (i) {
      let u = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === u) {
              u = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[i];
      }
      if (u !== void 0) {
        if (e[u] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[u];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const u = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          u +
          "." +
          r +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = r);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
bt.Composite = vV;
bt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
bt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
bt.prototype.GetterByBindingType = [
  bt.prototype._getValue_direct,
  bt.prototype._getValue_array,
  bt.prototype._getValue_arrayElement,
  bt.prototype._getValue_toArray,
];
bt.prototype.SetterByBindingTypeAndVersioning = [
  [
    bt.prototype._setValue_direct,
    bt.prototype._setValue_direct_setNeedsUpdate,
    bt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    bt.prototype._setValue_array,
    bt.prototype._setValue_array_setNeedsUpdate,
    bt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    bt.prototype._setValue_arrayElement,
    bt.prototype._setValue_arrayElement_setNeedsUpdate,
    bt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    bt.prototype._setValue_fromArray,
    bt.prototype._setValue_fromArray_setNeedsUpdate,
    bt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class yV {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = qi()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let i = 0, r = arguments.length; i !== r; ++i)
      e[arguments[i].uuid] = i;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._paths,
      r = this._parsedPaths,
      s = this._bindings,
      o = s.length;
    let a,
      l = e.length,
      u = this.nCachedObjects_;
    for (let h = 0, d = arguments.length; h !== d; ++h) {
      const p = arguments[h],
        m = p.uuid;
      let y = t[m];
      if (y === void 0) {
        (y = l++), (t[m] = y), e.push(p);
        for (let M = 0, A = o; M !== A; ++M) s[M].push(new bt(p, i[M], r[M]));
      } else if (y < u) {
        a = e[y];
        const M = --u,
          A = e[M];
        (t[A.uuid] = y), (e[y] = A), (t[m] = M), (e[M] = p);
        for (let g = 0, x = o; g !== x; ++g) {
          const _ = s[g],
            E = _[M];
          let T = _[y];
          (_[y] = E), T === void 0 && (T = new bt(p, i[g], r[g])), (_[M] = T);
        }
      } else
        e[y] !== a &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = u;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const l = arguments[o],
        u = l.uuid,
        h = t[u];
      if (h !== void 0 && h >= s) {
        const d = s++,
          p = e[d];
        (t[p.uuid] = h), (e[h] = p), (t[u] = d), (e[d] = l);
        for (let m = 0, y = r; m !== y; ++m) {
          const M = i[m],
            A = M[d],
            g = M[h];
          (M[h] = A), (M[d] = g);
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length;
    let s = this.nCachedObjects_,
      o = e.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const u = arguments[a],
        h = u.uuid,
        d = t[h];
      if (d !== void 0)
        if ((delete t[h], d < s)) {
          const p = --s,
            m = e[p],
            y = --o,
            M = e[y];
          (t[m.uuid] = d), (e[d] = m), (t[M.uuid] = p), (e[p] = M), e.pop();
          for (let A = 0, g = r; A !== g; ++A) {
            const x = i[A],
              _ = x[p],
              E = x[y];
            (x[d] = _), (x[p] = E), x.pop();
          }
        } else {
          const p = --o,
            m = e[p];
          p > 0 && (t[m.uuid] = d), (e[d] = m), e.pop();
          for (let y = 0, M = r; y !== M; ++y) {
            const A = i[y];
            (A[d] = A[p]), A.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath;
    let r = i[e];
    const s = this._bindings;
    if (r !== void 0) return s[r];
    const o = this._paths,
      a = this._parsedPaths,
      l = this._objects,
      u = l.length,
      h = this.nCachedObjects_,
      d = new Array(u);
    (r = s.length), (i[e] = r), o.push(e), a.push(t), s.push(d);
    for (let p = h, m = l.length; p !== m; ++p) {
      const y = l[p];
      d[p] = new bt(y, e, t);
    }
    return d;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      i = t[e];
    if (i !== void 0) {
      const r = this._paths,
        s = this._parsedPaths,
        o = this._bindings,
        a = o.length - 1,
        l = o[a],
        u = e[a];
      (t[u] = i),
        (o[i] = l),
        o.pop(),
        (s[i] = s[a]),
        s.pop(),
        (r[i] = r[a]),
        r.pop();
    }
  }
}
class tL {
  constructor(e, t, i = null, r = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = i),
      (this.blendMode = r);
    const s = t.tracks,
      o = s.length,
      a = new Array(o),
      l = { endingStart: za, endingEnd: za };
    for (let u = 0; u !== o; ++u) {
      const h = s[u].createInterpolant(null);
      (a[u] = h), (h.settings = l);
    }
    (this._interpolantSettings = l),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = W2),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if ((e.fadeOut(t), this.fadeIn(t), i)) {
      const r = this._clip.duration,
        s = e._clip.duration,
        o = s / r,
        a = r / s;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const r = this._mixer,
      s = r.time,
      o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null &&
      ((a = r._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const l = a.parameterPositions,
      u = a.sampleValues;
    return (l[0] = s), (l[1] = s + i), (u[0] = e / o), (u[1] = t / o), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * i;
      l < 0 || i === 0 ? (t = 0) : ((this._startTime = null), (t = i * l));
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t),
      a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants,
        u = this._propertyBindings;
      switch (this.blendMode) {
        case v1:
          for (let h = 0, d = l.length; h !== d; ++h)
            l[h].evaluate(o), u[h].accumulateAdditive(a);
          break;
        case Ng:
        default:
          for (let h = 0, d = l.length; h !== d; ++h)
            l[h].evaluate(o), u[h].accumulate(r, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        (t *= r),
          e > i.parameterPositions[1] &&
            (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        (t *= r),
          e > i.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      i = this.loop;
    let r = this.time + e,
      s = this._loopCount;
    const o = i === j2;
    if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
    if (i === V2) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (r >= t) r = t;
        else if (r < 0) r = 0;
        else {
          this.time = r;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = r),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        r >= t || r < 0)
      ) {
        const a = Math.floor(r / t);
        (r -= t * a), (s += Math.abs(a));
        const l = this.repetitions - s;
        if (l <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (r = e > 0 ? t : 0),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (l === 1) {
            const u = e < 0;
            this._setEndings(u, !u, o);
          } else this._setEndings(!1, !1, o);
          (this._loopCount = s),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            });
        }
      } else this.time = r;
      if (o && (s & 1) === 1) return t - r;
    }
    return r;
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings;
    i
      ? ((r.endingStart = Ga), (r.endingEnd = Ga))
      : (e
          ? (r.endingStart = this.zeroSlopeAtStart ? Ga : za)
          : (r.endingStart = eh),
        t ? (r.endingEnd = this.zeroSlopeAtEnd ? Ga : za) : (r.endingEnd = eh));
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer,
      s = r.time;
    let o = this._weightInterpolant;
    o === null &&
      ((o = r._lendControlInterpolant()), (this._weightInterpolant = o));
    const a = o.parameterPositions,
      l = o.sampleValues;
    return (a[0] = s), (l[0] = t), (a[1] = s + e), (l[1] = i), this;
  }
}
const xV = new Float32Array(1);
class _V extends Ss {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root,
      r = e._clip.tracks,
      s = r.length,
      o = e._propertyBindings,
      a = e._interpolants,
      l = i.uuid,
      u = this._bindingsByRootAndName;
    let h = u[l];
    h === void 0 && ((h = {}), (u[l] = h));
    for (let d = 0; d !== s; ++d) {
      const p = r[d],
        m = p.name;
      let y = h[m];
      if (y !== void 0) ++y.referenceCount, (o[d] = y);
      else {
        if (((y = o[d]), y !== void 0)) {
          y._cacheIndex === null &&
            (++y.referenceCount, this._addInactiveBinding(y, l, m));
          continue;
        }
        const M = t && t._propertyBindings[d].binding.parsedPath;
        (y = new eL(bt.create(i, m, M), p.ValueTypeName, p.getValueSize())),
          ++y.referenceCount,
          this._addInactiveBinding(y, l, m),
          (o[d] = y);
      }
      a[d].resultBuffer = y.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid,
          r = e._clip.uuid,
          s = this._actionsByClip[r];
        this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, r, i);
      }
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions,
      s = this._actionsByClip;
    let o = s[t];
    if (o === void 0)
      (o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = o);
    else {
      const a = o.knownActions;
      (e._byClipCacheIndex = a.length), a.push(e);
    }
    (e._cacheIndex = r.length), r.push(e), (o.actionByRoot[i] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      i = t[t.length - 1],
      r = e._cacheIndex;
    (i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null);
    const s = e._clip.uuid,
      o = this._actionsByClip,
      a = o[s],
      l = a.knownActions,
      u = l[l.length - 1],
      h = e._byClipCacheIndex;
    (u._byClipCacheIndex = h),
      (l[h] = u),
      l.pop(),
      (e._byClipCacheIndex = null);
    const d = a.actionByRoot,
      p = (e._localRoot || this._root).uuid;
    delete d[p],
      l.length === 0 && delete o[s],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = this._nActiveActions++,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _takeBackAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = --this._nActiveActions,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName,
      s = this._bindings;
    let o = r[t];
    o === void 0 && ((o = {}), (r[t] = o)),
      (o[i] = e),
      (e._cacheIndex = s.length),
      s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      i = e.binding,
      r = i.rootNode.uuid,
      s = i.path,
      o = this._bindingsByRootAndName,
      a = o[r],
      l = t[t.length - 1],
      u = e._cacheIndex;
    (l._cacheIndex = u),
      (t[u] = l),
      t.pop(),
      delete a[s],
      Object.keys(a).length === 0 && delete o[r];
  }
  _lendBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = this._nActiveBindings++,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = --this._nActiveBindings,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let i = e[t];
    return (
      i === void 0 &&
        ((i = new X1(new Float32Array(2), new Float32Array(2), 1, xV)),
        (i.__cacheIndex = t),
        (e[t] = i)),
      i
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      i = e.__cacheIndex,
      r = --this._nActiveControlInterpolants,
      s = t[r];
    (e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s);
  }
  clipAction(e, t, i) {
    const r = t || this._root,
      s = r.uuid;
    let o = typeof e == "string" ? $c.findByName(r, e) : e;
    const a = o !== null ? o.uuid : e,
      l = this._actionsByClip[a];
    let u = null;
    if (
      (i === void 0 && (o !== null ? (i = o.blendMode) : (i = Ng)),
      l !== void 0)
    ) {
      const d = l.actionByRoot[s];
      if (d !== void 0 && d.blendMode === i) return d;
      (u = l.knownActions[0]), o === null && (o = u._clip);
    }
    if (o === null) return null;
    const h = new tL(this, o, t, i);
    return this._bindAction(h, u), this._addInactiveAction(h, a, s), h;
  }
  existingAction(e, t) {
    const i = t || this._root,
      r = i.uuid,
      s = typeof e == "string" ? $c.findByName(i, e) : e,
      o = s ? s.uuid : e,
      a = this._actionsByClip[o];
    return (a !== void 0 && a.actionByRoot[r]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i) e[i].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      i = this._nActiveActions,
      r = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1);
    for (let u = 0; u !== i; ++u) t[u]._update(r, e, s, o);
    const a = this._bindings,
      l = this._nActiveBindings;
    for (let u = 0; u !== l; ++u) a[u].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      i = e.uuid,
      r = this._actionsByClip,
      s = r[i];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const u = o[a];
        this._deactivateAction(u);
        const h = u._cacheIndex,
          d = t[t.length - 1];
        (u._cacheIndex = null),
          (u._byClipCacheIndex = null),
          (d._cacheIndex = h),
          (t[h] = d),
          t.pop(),
          this._removeInactiveBindingsForAction(u);
      }
      delete r[i];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      i = this._actionsByClip;
    for (const o in i) {
      const a = i[o].actionByRoot,
        l = a[t];
      l !== void 0 &&
        (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const r = this._bindingsByRootAndName,
      s = r[t];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class iS {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new iS(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let AV = 0;
class SV extends Ss {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: AV++ }),
      (this.name = ""),
      (this.usage = th),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, r = t.length; i < r; i++) this.uniforms.push(t[i].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class MV extends bh {
  constructor(e, t, i = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class EV {
  constructor(e, t, i, r, s) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = i),
      (this.elementSize = r),
      (this.count = s),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
class nL {
  constructor(e, t, i = 0, r = 1 / 0) {
    (this.ray = new au(e, t)),
      (this.near = i),
      (this.far = r),
      (this.camera = null),
      (this.layers = new Za()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, i = []) {
    return H_(e, this, i, t), i.sort(zT), i;
  }
  intersectObjects(e, t = !0, i = []) {
    for (let r = 0, s = e.length; r < s; r++) H_(e[r], this, i, t);
    return i.sort(zT), i;
  }
}
function zT(n, e) {
  return n.distance - e.distance;
}
function H_(n, e, t, i) {
  if ((n.layers.test(e.layers) && n.raycast(e, t), i === !0)) {
    const r = n.children;
    for (let s = 0, o = r.length; s < o; s++) H_(r[s], e, t, !0);
  }
}
class z_ {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  set(e, t, i) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + i * i)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)),
          (this.phi = Math.acos(vn(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class wV {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.theta = t), (this.y = i), this;
  }
  set(e, t, i) {
    return (this.radius = e), (this.theta = t), (this.y = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + i * i)),
      (this.theta = Math.atan2(e, i)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const GT = new ve();
class TV {
  constructor(e = new ve(1 / 0, 1 / 0), t = new ve(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = GT.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, GT).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const VT = new F(),
  kp = new F();
class CV {
  constructor(e = new F(), t = new F()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    VT.subVectors(e, this.start), kp.subVectors(this.end, this.start);
    const i = kp.dot(kp);
    let s = kp.dot(VT) / i;
    return t && (s = vn(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, i) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const WT = new F();
class bV extends Rt {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const i = new gt(),
      r = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
      const u = (o / l) * Math.PI * 2,
        h = (a / l) * Math.PI * 2;
      r.push(Math.cos(u), Math.sin(u), 1, Math.cos(h), Math.sin(h), 1);
    }
    i.setAttribute("position", new Ye(r, 3));
    const s = new ci({ fog: !1, toneMapped: !1 });
    (this.cone = new Qr(i, s)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      WT.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(WT),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const yo = new F(),
  Hp = new rt(),
  Ry = new rt();
class RV extends Qr {
  constructor(e) {
    const t = iL(e),
      i = new gt(),
      r = [],
      s = [],
      o = new Ue(0, 0, 1),
      a = new Ue(0, 1, 0);
    for (let u = 0; u < t.length; u++) {
      const h = t[u];
      h.parent &&
        h.parent.isBone &&
        (r.push(0, 0, 0),
        r.push(0, 0, 0),
        s.push(o.r, o.g, o.b),
        s.push(a.r, a.g, a.b));
    }
    i.setAttribute("position", new Ye(r, 3)),
      i.setAttribute("color", new Ye(s, 3));
    const l = new ci({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(i, l),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      i = this.geometry,
      r = i.getAttribute("position");
    Ry.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s];
      a.parent &&
        a.parent.isBone &&
        (Hp.multiplyMatrices(Ry, a.matrixWorld),
        yo.setFromMatrixPosition(Hp),
        r.setXYZ(o, yo.x, yo.y, yo.z),
        Hp.multiplyMatrices(Ry, a.parent.matrixWorld),
        yo.setFromMatrixPosition(Hp),
        r.setXYZ(o + 1, yo.x, yo.y, yo.z),
        (o += 2));
    }
    (i.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function iL(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, iL(n.children[t]));
  return e;
}
class PV extends Gn {
  constructor(e, t, i) {
    const r = new Ih(t, 4, 2),
      s = new Ji({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(r, s),
      (this.light = e),
      (this.color = i),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const BV = new F(),
  jT = new Ue(),
  XT = new Ue();
class LV extends Rt {
  constructor(e, t, i) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = "HemisphereLightHelper");
    const r = new Lh(t);
    r.rotateY(Math.PI * 0.5),
      (this.material = new Ji({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const s = r.getAttribute("position"),
      o = new Float32Array(s.count * 3);
    r.setAttribute("color", new Ft(o, 3)),
      this.add(new Gn(r, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      jT.copy(this.light.color), XT.copy(this.light.groundColor);
      for (let i = 0, r = t.count; i < r; i++) {
        const s = i < r / 2 ? jT : XT;
        t.setXYZ(i, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(BV.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class IV extends Qr {
  constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
    (i = new Ue(i)), (r = new Ue(r));
    const s = t / 2,
      o = e / t,
      a = e / 2,
      l = [],
      u = [];
    for (let p = 0, m = 0, y = -a; p <= t; p++, y += o) {
      l.push(-a, 0, y, a, 0, y), l.push(y, 0, -a, y, 0, a);
      const M = p === s ? i : r;
      M.toArray(u, m),
        (m += 3),
        M.toArray(u, m),
        (m += 3),
        M.toArray(u, m),
        (m += 3),
        M.toArray(u, m),
        (m += 3);
    }
    const h = new gt();
    h.setAttribute("position", new Ye(l, 3)),
      h.setAttribute("color", new Ye(u, 3));
    const d = new ci({ vertexColors: !0, toneMapped: !1 });
    super(h, d), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class DV extends Qr {
  constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) {
    (s = new Ue(s)), (o = new Ue(o));
    const a = [],
      l = [];
    if (t > 1)
      for (let d = 0; d < t; d++) {
        const p = (d / t) * (Math.PI * 2),
          m = Math.sin(p) * e,
          y = Math.cos(p) * e;
        a.push(0, 0, 0), a.push(m, 0, y);
        const M = d & 1 ? s : o;
        l.push(M.r, M.g, M.b), l.push(M.r, M.g, M.b);
      }
    for (let d = 0; d < i; d++) {
      const p = d & 1 ? s : o,
        m = e - (e / i) * d;
      for (let y = 0; y < r; y++) {
        let M = (y / r) * (Math.PI * 2),
          A = Math.sin(M) * m,
          g = Math.cos(M) * m;
        a.push(A, 0, g),
          l.push(p.r, p.g, p.b),
          (M = ((y + 1) / r) * (Math.PI * 2)),
          (A = Math.sin(M) * m),
          (g = Math.cos(M) * m),
          a.push(A, 0, g),
          l.push(p.r, p.g, p.b);
      }
    }
    const u = new gt();
    u.setAttribute("position", new Ye(a, 3)),
      u.setAttribute("color", new Ye(l, 3));
    const h = new ci({ vertexColors: !0, toneMapped: !1 });
    super(u, h), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const JT = new F(),
  zp = new F(),
  KT = new F();
class FV extends Rt {
  constructor(e, t, i) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let r = new gt();
    r.setAttribute(
      "position",
      new Ye([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    );
    const s = new ci({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new $s(r, s)),
      this.add(this.lightPlane),
      (r = new gt()),
      r.setAttribute("position", new Ye([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new $s(r, s)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      JT.setFromMatrixPosition(this.light.matrixWorld),
      zp.setFromMatrixPosition(this.light.target.matrixWorld),
      KT.subVectors(zp, JT),
      this.lightPlane.lookAt(zp),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(zp),
      (this.targetLine.scale.z = KT.length());
  }
}
const Gp = new F(),
  pn = new wh();
class NV extends Qr {
  constructor(e) {
    const t = new gt(),
      i = new ci({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      r = [],
      s = [],
      o = {};
    a("n1", "n2"),
      a("n2", "n4"),
      a("n4", "n3"),
      a("n3", "n1"),
      a("f1", "f2"),
      a("f2", "f4"),
      a("f4", "f3"),
      a("f3", "f1"),
      a("n1", "f1"),
      a("n2", "f2"),
      a("n3", "f3"),
      a("n4", "f4"),
      a("p", "n1"),
      a("p", "n2"),
      a("p", "n3"),
      a("p", "n4"),
      a("u1", "u2"),
      a("u2", "u3"),
      a("u3", "u1"),
      a("c", "t"),
      a("p", "c"),
      a("cn1", "cn2"),
      a("cn3", "cn4"),
      a("cf1", "cf2"),
      a("cf3", "cf4");
    function a(y, M) {
      l(y), l(M);
    }
    function l(y) {
      r.push(0, 0, 0),
        s.push(0, 0, 0),
        o[y] === void 0 && (o[y] = []),
        o[y].push(r.length / 3 - 1);
    }
    t.setAttribute("position", new Ye(r, 3)),
      t.setAttribute("color", new Ye(s, 3)),
      super(t, i),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update();
    const u = new Ue(16755200),
      h = new Ue(16711680),
      d = new Ue(43775),
      p = new Ue(16777215),
      m = new Ue(3355443);
    this.setColors(u, h, d, p, m);
  }
  setColors(e, t, i, r, s) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b),
      a.setXYZ(1, e.r, e.g, e.b),
      a.setXYZ(2, e.r, e.g, e.b),
      a.setXYZ(3, e.r, e.g, e.b),
      a.setXYZ(4, e.r, e.g, e.b),
      a.setXYZ(5, e.r, e.g, e.b),
      a.setXYZ(6, e.r, e.g, e.b),
      a.setXYZ(7, e.r, e.g, e.b),
      a.setXYZ(8, e.r, e.g, e.b),
      a.setXYZ(9, e.r, e.g, e.b),
      a.setXYZ(10, e.r, e.g, e.b),
      a.setXYZ(11, e.r, e.g, e.b),
      a.setXYZ(12, e.r, e.g, e.b),
      a.setXYZ(13, e.r, e.g, e.b),
      a.setXYZ(14, e.r, e.g, e.b),
      a.setXYZ(15, e.r, e.g, e.b),
      a.setXYZ(16, e.r, e.g, e.b),
      a.setXYZ(17, e.r, e.g, e.b),
      a.setXYZ(18, e.r, e.g, e.b),
      a.setXYZ(19, e.r, e.g, e.b),
      a.setXYZ(20, e.r, e.g, e.b),
      a.setXYZ(21, e.r, e.g, e.b),
      a.setXYZ(22, e.r, e.g, e.b),
      a.setXYZ(23, e.r, e.g, e.b),
      a.setXYZ(24, t.r, t.g, t.b),
      a.setXYZ(25, t.r, t.g, t.b),
      a.setXYZ(26, t.r, t.g, t.b),
      a.setXYZ(27, t.r, t.g, t.b),
      a.setXYZ(28, t.r, t.g, t.b),
      a.setXYZ(29, t.r, t.g, t.b),
      a.setXYZ(30, t.r, t.g, t.b),
      a.setXYZ(31, t.r, t.g, t.b),
      a.setXYZ(32, i.r, i.g, i.b),
      a.setXYZ(33, i.r, i.g, i.b),
      a.setXYZ(34, i.r, i.g, i.b),
      a.setXYZ(35, i.r, i.g, i.b),
      a.setXYZ(36, i.r, i.g, i.b),
      a.setXYZ(37, i.r, i.g, i.b),
      a.setXYZ(38, r.r, r.g, r.b),
      a.setXYZ(39, r.r, r.g, r.b),
      a.setXYZ(40, s.r, s.g, s.b),
      a.setXYZ(41, s.r, s.g, s.b),
      a.setXYZ(42, s.r, s.g, s.b),
      a.setXYZ(43, s.r, s.g, s.b),
      a.setXYZ(44, s.r, s.g, s.b),
      a.setXYZ(45, s.r, s.g, s.b),
      a.setXYZ(46, s.r, s.g, s.b),
      a.setXYZ(47, s.r, s.g, s.b),
      a.setXYZ(48, s.r, s.g, s.b),
      a.setXYZ(49, s.r, s.g, s.b),
      (a.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      i = 1,
      r = 1;
    pn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      xn("c", t, e, pn, 0, 0, -1),
      xn("t", t, e, pn, 0, 0, 1),
      xn("n1", t, e, pn, -i, -r, -1),
      xn("n2", t, e, pn, i, -r, -1),
      xn("n3", t, e, pn, -i, r, -1),
      xn("n4", t, e, pn, i, r, -1),
      xn("f1", t, e, pn, -i, -r, 1),
      xn("f2", t, e, pn, i, -r, 1),
      xn("f3", t, e, pn, -i, r, 1),
      xn("f4", t, e, pn, i, r, 1),
      xn("u1", t, e, pn, i * 0.7, r * 1.1, -1),
      xn("u2", t, e, pn, -i * 0.7, r * 1.1, -1),
      xn("u3", t, e, pn, 0, r * 2, -1),
      xn("cf1", t, e, pn, -i, 0, 1),
      xn("cf2", t, e, pn, i, 0, 1),
      xn("cf3", t, e, pn, 0, -r, 1),
      xn("cf4", t, e, pn, 0, r, 1),
      xn("cn1", t, e, pn, -i, 0, -1),
      xn("cn2", t, e, pn, i, 0, -1),
      xn("cn3", t, e, pn, 0, -r, -1),
      xn("cn4", t, e, pn, 0, r, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function xn(n, e, t, i, r, s, o) {
  Gp.set(r, s, o).unproject(i);
  const a = e[n];
  if (a !== void 0) {
    const l = t.getAttribute("position");
    for (let u = 0, h = a.length; u < h; u++) l.setXYZ(a[u], Gp.x, Gp.y, Gp.z);
  }
}
const Vp = new Yr();
class UV extends Qr {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = new Float32Array(8 * 3),
      s = new gt();
    s.setIndex(new Ft(i, 1)),
      s.setAttribute("position", new Ft(r, 3)),
      super(s, new ci({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && Vp.setFromObject(this.object),
      Vp.isEmpty())
    )
      return;
    const t = Vp.min,
      i = Vp.max,
      r = this.geometry.attributes.position,
      s = r.array;
    (s[0] = i.x),
      (s[1] = i.y),
      (s[2] = i.z),
      (s[3] = t.x),
      (s[4] = i.y),
      (s[5] = i.z),
      (s[6] = t.x),
      (s[7] = t.y),
      (s[8] = i.z),
      (s[9] = i.x),
      (s[10] = t.y),
      (s[11] = i.z),
      (s[12] = i.x),
      (s[13] = i.y),
      (s[14] = t.z),
      (s[15] = t.x),
      (s[16] = i.y),
      (s[17] = t.z),
      (s[18] = t.x),
      (s[19] = t.y),
      (s[20] = t.z),
      (s[21] = i.x),
      (s[22] = t.y),
      (s[23] = t.z),
      (r.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class OV extends Qr {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new gt();
    s.setIndex(new Ft(i, 1)),
      s.setAttribute("position", new Ye(r, 3)),
      super(s, new ci({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class kV extends $s {
  constructor(e, t = 1, i = 16776960) {
    const r = i,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      o = new gt();
    o.setAttribute("position", new Ye(s, 3)),
      o.computeBoundingSphere(),
      super(o, new ci({ color: r, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      l = new gt();
    l.setAttribute("position", new Ye(a, 3)),
      l.computeBoundingSphere(),
      this.add(
        new Gn(
          l,
          new Ji({
            color: r,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const YT = new F();
let Wp, Py;
class HV extends Rt {
  constructor(
    e = new F(0, 0, 1),
    t = new F(0, 0, 0),
    i = 1,
    r = 16776960,
    s = i * 0.2,
    o = s * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      Wp === void 0 &&
        ((Wp = new gt()),
        Wp.setAttribute("position", new Ye([0, 0, 0, 0, 1, 0], 3)),
        (Py = new cu(0, 0.5, 1, 5, 1)),
        Py.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new $s(Wp, new ci({ color: r, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new Gn(Py, new Ji({ color: r, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(i, s, o);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      YT.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(YT, t);
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(i, t, i),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class zV extends Qr {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      i = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      r = new gt();
    r.setAttribute("position", new Ye(t, 3)),
      r.setAttribute("color", new Ye(i, 3));
    const s = new ci({ vertexColors: !0, toneMapped: !1 });
    super(r, s), (this.type = "AxesHelper");
  }
  setColors(e, t, i) {
    const r = new Ue(),
      s = this.geometry.attributes.color.array;
    return (
      r.set(e),
      r.toArray(s, 0),
      r.toArray(s, 3),
      r.set(t),
      r.toArray(s, 6),
      r.toArray(s, 9),
      r.set(i),
      r.toArray(s, 12),
      r.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class GV {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new Ue()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new rh()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    return this.currentPath.quadraticCurveTo(e, t, i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(g) {
      const x = [];
      for (let _ = 0, E = g.length; _ < E; _++) {
        const T = g[_],
          R = new $a();
        (R.curves = T.curves), x.push(R);
      }
      return x;
    }
    function i(g, x) {
      const _ = x.length;
      let E = !1;
      for (let T = _ - 1, R = 0; R < _; T = R++) {
        let P = x[T],
          B = x[R],
          b = B.x - P.x,
          L = B.y - P.y;
        if (Math.abs(L) > Number.EPSILON) {
          if (
            (L < 0 && ((P = x[R]), (b = -b), (B = x[T]), (L = -L)),
            g.y < P.y || g.y > B.y)
          )
            continue;
          if (g.y === P.y) {
            if (g.x === P.x) return !0;
          } else {
            const z = L * (g.x - P.x) - b * (g.y - P.y);
            if (z === 0) return !0;
            if (z < 0) continue;
            E = !E;
          }
        } else {
          if (g.y !== P.y) continue;
          if ((B.x <= g.x && g.x <= P.x) || (P.x <= g.x && g.x <= B.x))
            return !0;
        }
      }
      return E;
    }
    const r = gs.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    let o, a, l;
    const u = [];
    if (s.length === 1)
      return (a = s[0]), (l = new $a()), (l.curves = a.curves), u.push(l), u;
    let h = !r(s[0].getPoints());
    h = e ? !h : h;
    const d = [],
      p = [];
    let m = [],
      y = 0,
      M;
    (p[y] = void 0), (m[y] = []);
    for (let g = 0, x = s.length; g < x; g++)
      (a = s[g]),
        (M = a.getPoints()),
        (o = r(M)),
        (o = e ? !o : o),
        o
          ? (!h && p[y] && y++,
            (p[y] = { s: new $a(), p: M }),
            (p[y].s.curves = a.curves),
            h && y++,
            (m[y] = []))
          : m[y].push({ h: a, p: M[0] });
    if (!p[0]) return t(s);
    if (p.length > 1) {
      let g = !1,
        x = 0;
      for (let _ = 0, E = p.length; _ < E; _++) d[_] = [];
      for (let _ = 0, E = p.length; _ < E; _++) {
        const T = m[_];
        for (let R = 0; R < T.length; R++) {
          const P = T[R];
          let B = !0;
          for (let b = 0; b < p.length; b++)
            i(P.p, p[b].p) &&
              (_ !== b && x++, B ? ((B = !1), d[b].push(P)) : (g = !0));
          B && d[_].push(P);
        }
      }
      x > 0 && g === !1 && (m = d);
    }
    let A;
    for (let g = 0, x = p.length; g < x; g++) {
      (l = p[g].s), u.push(l), (A = m[g]);
      for (let _ = 0, E = A.length; _ < E; _++) l.holes.push(A[_].h);
    }
    return u;
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Sh } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Sh));
const VV = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: u1,
      AddEquation: Fa,
      AddOperation: R2,
      AdditiveAnimationBlendMode: v1,
      AdditiveBlending: r_,
      AlphaFormat: N2,
      AlwaysCompare: rB,
      AlwaysDepth: S2,
      AlwaysStencilFunc: Q2,
      AmbientLight: JB,
      AmbientLightProbe: nV,
      AnimationAction: tL,
      AnimationClip: $c,
      AnimationLoader: j4,
      AnimationMixer: _V,
      AnimationObjectGroup: yV,
      AnimationUtils: z4,
      ArcCurve: MB,
      ArrayCamera: vB,
      ArrowHelper: HV,
      Audio: $B,
      AudioAnalyser: lV,
      AudioContext: $1,
      AudioListener: sV,
      AudioLoader: eV,
      AxesHelper: zV,
      BackSide: xi,
      BasicDepthPacking: J2,
      BasicShadowMap: l2,
      Bone: Gg,
      BooleanKeyframeTrack: dl,
      Box2: TV,
      Box3: Yr,
      Box3Helper: OV,
      BoxGeometry: hl,
      BoxHelper: UV,
      BufferAttribute: Ft,
      BufferGeometry: gt,
      BufferGeometryLoader: qB,
      ByteType: D2,
      Cache: cl,
      Camera: wh,
      CameraHelper: NV,
      CanvasTexture: f4,
      CapsuleGeometry: jg,
      CatmullRomCurve3: EB,
      CineonToneMapping: L2,
      CircleGeometry: Xg,
      ClampToEdgeWrapping: Kn,
      Clock: eS,
      Color: Ue,
      ColorKeyframeTrack: J1,
      ColorManagement: mr,
      CompressedArrayTexture: u4,
      CompressedTexture: U1,
      CompressedTextureLoader: X4,
      ConeGeometry: Jg,
      CubeCamera: T1,
      CubeReflectionMapping: Jo,
      CubeRefractionMapping: Ko,
      CubeTexture: Th,
      CubeTextureLoader: J4,
      CubeUVReflectionMapping: ou,
      CubicBezierCurve: k1,
      CubicBezierCurve3: wB,
      CubicInterpolant: GB,
      CullFaceBack: i_,
      CullFaceFront: a2,
      CullFaceFrontBack: cU,
      CullFaceNone: o2,
      Curve: qr,
      CurvePath: CB,
      CustomBlending: c2,
      CustomToneMapping: I2,
      CylinderGeometry: cu,
      Cylindrical: wV,
      Data3DTexture: M1,
      DataArrayTexture: Ug,
      DataTexture: Dc,
      DataTextureLoader: K4,
      DataUtils: vO,
      DecrementStencilOp: yU,
      DecrementWrapStencilOp: _U,
      DefaultLoadingManager: _c,
      DepthFormat: Ho,
      DepthStencilFormat: ol,
      DepthTexture: yB,
      DirectionalLight: Z1,
      DirectionalLightHelper: FV,
      DiscreteInterpolant: VB,
      DisplayP3ColorSpace: _1,
      DodecahedronGeometry: Kg,
      DoubleSide: Ar,
      DstAlphaFactor: g2,
      DstColorFactor: y2,
      DynamicCopyUsage: DU,
      DynamicDrawUsage: Qa,
      DynamicReadUsage: BU,
      EdgesGeometry: bB,
      EllipseCurve: Vg,
      EqualCompare: $2,
      EqualDepth: E2,
      EqualStencilFunc: EU,
      EquirectangularReflectionMapping: qf,
      EquirectangularRefractionMapping: Zf,
      Euler: Eh,
      EventDispatcher: Ss,
      ExtrudeGeometry: Qg,
      FileLoader: $i,
      Float16BufferAttribute: MO,
      Float32BufferAttribute: Ye,
      Float64BufferAttribute: EO,
      FloatType: fs,
      Fog: zg,
      FogExp2: Hg,
      FramebufferTexture: c4,
      FrontSide: xs,
      Frustum: Og,
      GLBufferAttribute: EV,
      GLSL1: NU,
      GLSL3: L_,
      GreaterCompare: tB,
      GreaterDepth: T2,
      GreaterEqualCompare: iB,
      GreaterEqualDepth: w2,
      GreaterEqualStencilFunc: bU,
      GreaterStencilFunc: TU,
      GridHelper: IV,
      Group: Vs,
      HalfFloatType: Xc,
      HemisphereLight: XB,
      HemisphereLightHelper: LV,
      HemisphereLightProbe: tV,
      IcosahedronGeometry: qg,
      ImageBitmapLoader: ZB,
      ImageLoader: lh,
      ImageUtils: S1,
      IncrementStencilOp: vU,
      IncrementWrapStencilOp: xU,
      InstancedBufferAttribute: Qc,
      InstancedBufferGeometry: QB,
      InstancedInterleavedBuffer: MV,
      InstancedMesh: D1,
      Int16BufferAttribute: AO,
      Int32BufferAttribute: SO,
      Int8BufferAttribute: yO,
      IntType: f1,
      InterleavedBuffer: bh,
      InterleavedBufferAttribute: Qo,
      Interpolant: uu,
      InterpolateDiscrete: Jc,
      InterpolateLinear: al,
      InterpolateSmooth: vm,
      InvertStencilOp: AU,
      KeepStencilOp: ym,
      KeyframeTrack: Zr,
      LOD: SB,
      LatheGeometry: Bh,
      Layers: Za,
      LessCompare: Z2,
      LessDepth: M2,
      LessEqualCompare: eB,
      LessEqualDepth: Ym,
      LessEqualStencilFunc: wU,
      LessStencilFunc: MU,
      Light: sa,
      LightProbe: r0,
      Line: $s,
      Line3: CV,
      LineBasicMaterial: ci,
      LineCurve: Wg,
      LineCurve3: TB,
      LineDashedMaterial: HB,
      LineLoop: F1,
      LineSegments: Qr,
      LinearEncoding: x1,
      LinearFilter: sn,
      LinearInterpolant: X1,
      LinearMipMapLinearFilter: pU,
      LinearMipMapNearestFilter: dU,
      LinearMipmapLinearFilter: _s,
      LinearMipmapNearestFilter: Dg,
      LinearSRGBColorSpace: Xr,
      LinearToneMapping: P2,
      Loader: ui,
      LoaderUtils: vs,
      LoadingManager: K1,
      LoopOnce: V2,
      LoopPingPong: j2,
      LoopRepeat: W2,
      LuminanceAlphaFormat: O2,
      LuminanceFormat: U2,
      MOUSE: Pa,
      Material: bn,
      MaterialLoader: s0,
      MathUtils: oB,
      Matrix3: _t,
      Matrix4: rt,
      MaxEquation: l_,
      Mesh: Gn,
      MeshBasicMaterial: Ji,
      MeshDepthMaterial: R1,
      MeshDistanceMaterial: P1,
      MeshLambertMaterial: OB,
      MeshMatcapMaterial: kB,
      MeshNormalMaterial: UB,
      MeshPhongMaterial: FB,
      MeshPhysicalMaterial: Ms,
      MeshStandardMaterial: Dh,
      MeshToonMaterial: NB,
      MinEquation: a_,
      MirroredRepeatWrapping: jc,
      MixOperation: b2,
      MultiplyBlending: o_,
      MultiplyOperation: Mh,
      NearestFilter: gn,
      NearestMipMapLinearFilter: hU,
      NearestMipMapNearestFilter: fU,
      NearestMipmapLinearFilter: Lc,
      NearestMipmapNearestFilter: $f,
      NeverCompare: q2,
      NeverDepth: A2,
      NeverStencilFunc: SU,
      NoBlending: Xs,
      NoColorSpace: Go,
      NoToneMapping: Vr,
      NormalAnimationBlendMode: Ng,
      NormalBlending: Ya,
      NotEqualCompare: nB,
      NotEqualDepth: C2,
      NotEqualStencilFunc: CU,
      NumberKeyframeTrack: qc,
      Object3D: Rt,
      ObjectLoader: Z4,
      ObjectSpaceNormalMap: Y2,
      OctahedronGeometry: Lh,
      OneFactor: d2,
      OneMinusDstAlphaFactor: v2,
      OneMinusDstColorFactor: x2,
      OneMinusSrcAlphaFactor: c1,
      OneMinusSrcColorFactor: m2,
      OrthographicCamera: Wr,
      PCFShadowMap: Lg,
      PCFSoftShadowMap: Mf,
      PMREMGenerator: D_,
      Path: rh,
      PerspectiveCamera: $t,
      Plane: Mo,
      PlaneGeometry: Ch,
      PlaneHelper: kV,
      PointLight: q1,
      PointLightHelper: PV,
      Points: N1,
      PointsMaterial: Ph,
      PolarGridHelper: DV,
      PolyhedronGeometry: ra,
      PositionalAudio: aV,
      PropertyBinding: bt,
      PropertyMixer: eL,
      QuadraticBezierCurve: H1,
      QuadraticBezierCurve3: z1,
      Quaternion: Wn,
      QuaternionKeyframeTrack: qo,
      QuaternionLinearInterpolant: WB,
      RED_GREEN_RGTC2_Format: P_,
      RED_RGTC1_Format: G2,
      REVISION: Sh,
      RGBADepthPacking: K2,
      RGBAFormat: bi,
      RGBAIntegerFormat: g1,
      RGBA_ASTC_10x10_Format: T_,
      RGBA_ASTC_10x5_Format: M_,
      RGBA_ASTC_10x6_Format: E_,
      RGBA_ASTC_10x8_Format: w_,
      RGBA_ASTC_12x10_Format: C_,
      RGBA_ASTC_12x12_Format: b_,
      RGBA_ASTC_4x4_Format: m_,
      RGBA_ASTC_5x4_Format: g_,
      RGBA_ASTC_5x5_Format: v_,
      RGBA_ASTC_6x5_Format: y_,
      RGBA_ASTC_6x6_Format: x_,
      RGBA_ASTC_8x5_Format: __,
      RGBA_ASTC_8x6_Format: A_,
      RGBA_ASTC_8x8_Format: S_,
      RGBA_BPTC_Format: gm,
      RGBA_ETC2_EAC_Format: p_,
      RGBA_PVRTC_2BPPV1_Format: h_,
      RGBA_PVRTC_4BPPV1_Format: f_,
      RGBA_S3TC_DXT1_Format: dm,
      RGBA_S3TC_DXT3_Format: pm,
      RGBA_S3TC_DXT5_Format: mm,
      RGB_ETC1_Format: z2,
      RGB_ETC2_Format: d_,
      RGB_PVRTC_2BPPV1_Format: u_,
      RGB_PVRTC_4BPPV1_Format: c_,
      RGB_S3TC_DXT1_Format: hm,
      RGFormat: H2,
      RGIntegerFormat: m1,
      RawShaderMaterial: DB,
      Ray: au,
      Raycaster: nL,
      RectAreaLight: KB,
      RedFormat: k2,
      RedIntegerFormat: p1,
      ReinhardToneMapping: B2,
      RepeatWrapping: Yo,
      ReplaceStencilOp: gU,
      ReverseSubtractEquation: f2,
      RingGeometry: Zg,
      SIGNED_RED_GREEN_RGTC2_Format: B_,
      SIGNED_RED_RGTC1_Format: R_,
      SRGBColorSpace: mt,
      Scene: $m,
      ShaderChunk: yt,
      ShaderLib: kr,
      ShaderMaterial: As,
      ShadowMaterial: IB,
      Shape: $a,
      ShapeGeometry: $g,
      ShapePath: GV,
      ShapeUtils: gs,
      ShortType: F2,
      Skeleton: Rh,
      SkeletonHelper: RV,
      SkinnedMesh: I1,
      Source: Va,
      Sphere: Tr,
      SphereGeometry: Ih,
      Spherical: z_,
      SphericalHarmonics3: YB,
      SplineCurve: G1,
      SpotLight: Q1,
      SpotLightHelper: bV,
      Sprite: AB,
      SpriteMaterial: L1,
      SrcAlphaFactor: l1,
      SrcAlphaSaturateFactor: _2,
      SrcColorFactor: p2,
      StaticCopyUsage: IU,
      StaticDrawUsage: th,
      StaticReadUsage: PU,
      StereoCamera: iV,
      StreamCopyUsage: FU,
      StreamDrawUsage: RU,
      StreamReadUsage: LU,
      StringKeyframeTrack: pl,
      SubtractEquation: u2,
      SubtractiveBlending: s_,
      TOUCH: Ba,
      TangentSpaceNormalMap: ia,
      TetrahedronGeometry: e0,
      Texture: en,
      TextureLoader: jB,
      TorusGeometry: t0,
      TorusKnotGeometry: n0,
      Triangle: Ci,
      TriangleFanDrawMode: Qm,
      TriangleStripDrawMode: y1,
      TrianglesDrawMode: X2,
      TubeGeometry: i0,
      TwoPassDoubleSide: uU,
      UVMapping: Ig,
      Uint16BufferAttribute: E1,
      Uint32BufferAttribute: w1,
      Uint8BufferAttribute: xO,
      Uint8ClampedBufferAttribute: _O,
      Uniform: iS,
      UniformsGroup: SV,
      UniformsLib: Ne,
      UniformsUtils: uB,
      UnsignedByteType: ms,
      UnsignedInt248Type: ko,
      UnsignedIntType: Gs,
      UnsignedShort4444Type: h1,
      UnsignedShort5551Type: d1,
      UnsignedShortType: Fg,
      VSMShadowMap: Nr,
      Vector2: ve,
      Vector3: F,
      Vector4: Ut,
      VectorKeyframeTrack: Zc,
      VideoTexture: l4,
      WebGL1Renderer: xB,
      WebGL3DRenderTarget: oO,
      WebGLArrayRenderTarget: sO,
      WebGLCoordinateSystem: hs,
      WebGLCubeRenderTarget: C1,
      WebGLMultipleRenderTargets: aO,
      WebGLRenderTarget: Jr,
      WebGLRenderer: B1,
      WebGLUtils: gB,
      WebGPUCoordinateSystem: nh,
      WireframeGeometry: LB,
      WrapAroundEnding: eh,
      ZeroCurvatureEnding: za,
      ZeroFactor: h2,
      ZeroSlopeEnding: Ga,
      ZeroStencilOp: mU,
      _SRGBAFormat: qm,
      sRGBEncoding: zo,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var rL = { exports: {} },
  ml = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ml.ConcurrentRoot = 1;
ml.ContinuousEventPriority = 4;
ml.DefaultEventPriority = 16;
ml.DiscreteEventPriority = 1;
ml.IdleEventPriority = 536870912;
ml.LegacyRoot = 0;
rL.exports = ml;
var Ac = rL.exports;
function WV(n) {
  let e;
  const t = new Set(),
    i = (u, h) => {
      const d = typeof u == "function" ? u(e) : u;
      if (d !== e) {
        const p = e;
        (e = h ? d : Object.assign({}, e, d)), t.forEach((m) => m(e, p));
      }
    },
    r = () => e,
    s = (u, h = r, d = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let p = h(e);
      function m() {
        const y = h(e);
        if (!d(p, y)) {
          const M = p;
          u((p = y), M);
        }
      }
      return t.add(m), () => t.delete(m);
    },
    l = {
      setState: i,
      getState: r,
      subscribe: (u, h, d) =>
        h || d ? s(u, h, d) : (t.add(u), () => t.delete(u)),
      destroy: () => t.clear(),
    };
  return (e = n(i, r, l)), l;
}
const jV =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  QT = jV ? W.useEffect : W.useLayoutEffect;
function sL(n) {
  const e = typeof n == "function" ? WV(n) : n,
    t = (i = e.getState, r = Object.is) => {
      const [, s] = W.useReducer((A) => A + 1, 0),
        o = e.getState(),
        a = W.useRef(o),
        l = W.useRef(i),
        u = W.useRef(r),
        h = W.useRef(!1),
        d = W.useRef();
      d.current === void 0 && (d.current = i(o));
      let p,
        m = !1;
      (a.current !== o || l.current !== i || u.current !== r || h.current) &&
        ((p = i(o)), (m = !r(d.current, p))),
        QT(() => {
          m && (d.current = p),
            (a.current = o),
            (l.current = i),
            (u.current = r),
            (h.current = !1);
        });
      const y = W.useRef(o);
      QT(() => {
        const A = () => {
            try {
              const x = e.getState(),
                _ = l.current(x);
              u.current(d.current, _) ||
                ((a.current = x), (d.current = _), s());
            } catch {
              (h.current = !0), s();
            }
          },
          g = e.subscribe(A);
        return e.getState() !== y.current && A(), g;
      }, []);
      const M = m ? p : d.current;
      return W.useDebugValue(M), M;
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const i = [t, e];
      return {
        next() {
          const r = i.length <= 0;
          return { value: i.shift(), done: r };
        },
      };
    }),
    t
  );
}
var oL = { exports: {} },
  By = { exports: {} },
  Ly = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var qT;
function XV() {
  return (
    qT ||
      ((qT = 1),
      (function (n) {
        function e(I, G) {
          var k = I.length;
          I.push(G);
          e: for (; 0 < k; ) {
            var U = (k - 1) >>> 1,
              j = I[U];
            if (0 < r(j, G)) (I[U] = G), (I[k] = j), (k = U);
            else break e;
          }
        }
        function t(I) {
          return I.length === 0 ? null : I[0];
        }
        function i(I) {
          if (I.length === 0) return null;
          var G = I[0],
            k = I.pop();
          if (k !== G) {
            I[0] = k;
            e: for (var U = 0, j = I.length, he = j >>> 1; U < he; ) {
              var ae = 2 * (U + 1) - 1,
                xe = I[ae],
                Ae = ae + 1,
                Le = I[Ae];
              if (0 > r(xe, k))
                Ae < j && 0 > r(Le, xe)
                  ? ((I[U] = Le), (I[Ae] = k), (U = Ae))
                  : ((I[U] = xe), (I[ae] = k), (U = ae));
              else if (Ae < j && 0 > r(Le, k))
                (I[U] = Le), (I[Ae] = k), (U = Ae);
              else break e;
            }
          }
          return G;
        }
        function r(I, G) {
          var k = I.sortIndex - G.sortIndex;
          return k !== 0 ? k : I.id - G.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var s = performance;
          n.unstable_now = function () {
            return s.now();
          };
        } else {
          var o = Date,
            a = o.now();
          n.unstable_now = function () {
            return o.now() - a;
          };
        }
        var l = [],
          u = [],
          h = 1,
          d = null,
          p = 3,
          m = !1,
          y = !1,
          M = !1,
          A = typeof setTimeout == "function" ? setTimeout : null,
          g = typeof clearTimeout == "function" ? clearTimeout : null,
          x = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function _(I) {
          for (var G = t(u); G !== null; ) {
            if (G.callback === null) i(u);
            else if (G.startTime <= I)
              i(u), (G.sortIndex = G.expirationTime), e(l, G);
            else break;
            G = t(u);
          }
        }
        function E(I) {
          if (((M = !1), _(I), !y))
            if (t(l) !== null) (y = !0), ie(T);
            else {
              var G = t(u);
              G !== null && ee(E, G.startTime - I);
            }
        }
        function T(I, G) {
          (y = !1), M && ((M = !1), g(B), (B = -1)), (m = !0);
          var k = p;
          try {
            for (
              _(G), d = t(l);
              d !== null && (!(d.expirationTime > G) || (I && !z()));

            ) {
              var U = d.callback;
              if (typeof U == "function") {
                (d.callback = null), (p = d.priorityLevel);
                var j = U(d.expirationTime <= G);
                (G = n.unstable_now()),
                  typeof j == "function"
                    ? (d.callback = j)
                    : d === t(l) && i(l),
                  _(G);
              } else i(l);
              d = t(l);
            }
            if (d !== null) var he = !0;
            else {
              var ae = t(u);
              ae !== null && ee(E, ae.startTime - G), (he = !1);
            }
            return he;
          } finally {
            (d = null), (p = k), (m = !1);
          }
        }
        var R = !1,
          P = null,
          B = -1,
          b = 5,
          L = -1;
        function z() {
          return !(n.unstable_now() - L < b);
        }
        function $() {
          if (P !== null) {
            var I = n.unstable_now();
            L = I;
            var G = !0;
            try {
              G = P(!0, I);
            } finally {
              G ? X() : ((R = !1), (P = null));
            }
          } else R = !1;
        }
        var X;
        if (typeof x == "function")
          X = function () {
            x($);
          };
        else if (typeof MessageChannel < "u") {
          var Y = new MessageChannel(),
            K = Y.port2;
          (Y.port1.onmessage = $),
            (X = function () {
              K.postMessage(null);
            });
        } else
          X = function () {
            A($, 0);
          };
        function ie(I) {
          (P = I), R || ((R = !0), X());
        }
        function ee(I, G) {
          B = A(function () {
            I(n.unstable_now());
          }, G);
        }
        (n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (I) {
            I.callback = null;
          }),
          (n.unstable_continueExecution = function () {
            y || m || ((y = !0), ie(T));
          }),
          (n.unstable_forceFrameRate = function (I) {
            0 > I || 125 < I
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (b = 0 < I ? Math.floor(1e3 / I) : 5);
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return p;
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(l);
          }),
          (n.unstable_next = function (I) {
            switch (p) {
              case 1:
              case 2:
              case 3:
                var G = 3;
                break;
              default:
                G = p;
            }
            var k = p;
            p = G;
            try {
              return I();
            } finally {
              p = k;
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (I, G) {
            switch (I) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                I = 3;
            }
            var k = p;
            p = I;
            try {
              return G();
            } finally {
              p = k;
            }
          }),
          (n.unstable_scheduleCallback = function (I, G, k) {
            var U = n.unstable_now();
            switch (
              (typeof k == "object" && k !== null
                ? ((k = k.delay),
                  (k = typeof k == "number" && 0 < k ? U + k : U))
                : (k = U),
              I)
            ) {
              case 1:
                var j = -1;
                break;
              case 2:
                j = 250;
                break;
              case 5:
                j = 1073741823;
                break;
              case 4:
                j = 1e4;
                break;
              default:
                j = 5e3;
            }
            return (
              (j = k + j),
              (I = {
                id: h++,
                callback: G,
                priorityLevel: I,
                startTime: k,
                expirationTime: j,
                sortIndex: -1,
              }),
              k > U
                ? ((I.sortIndex = k),
                  e(u, I),
                  t(l) === null &&
                    I === t(u) &&
                    (M ? (g(B), (B = -1)) : (M = !0), ee(E, k - U)))
                : ((I.sortIndex = j), e(l, I), y || m || ((y = !0), ie(T))),
              I
            );
          }),
          (n.unstable_shouldYield = z),
          (n.unstable_wrapCallback = function (I) {
            var G = p;
            return function () {
              var k = p;
              p = G;
              try {
                return I.apply(this, arguments);
              } finally {
                p = k;
              }
            };
          });
      })(Ly)),
    Ly
  );
}
var ZT;
function JV() {
  return ZT || ((ZT = 1), (By.exports = XV())), By.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var KV = function (e) {
  var t = {},
    i = W,
    r = JV(),
    s = Object.assign;
  function o(c) {
    for (
      var f = "https://reactjs.org/docs/error-decoder.html?invariant=" + c,
        v = 1;
      v < arguments.length;
      v++
    )
      f += "&args[]=" + encodeURIComponent(arguments[v]);
    return (
      "Minified React error #" +
      c +
      "; visit " +
      f +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    l = Symbol.for("react.element"),
    u = Symbol.for("react.portal"),
    h = Symbol.for("react.fragment"),
    d = Symbol.for("react.strict_mode"),
    p = Symbol.for("react.profiler"),
    m = Symbol.for("react.provider"),
    y = Symbol.for("react.context"),
    M = Symbol.for("react.forward_ref"),
    A = Symbol.for("react.suspense"),
    g = Symbol.for("react.suspense_list"),
    x = Symbol.for("react.memo"),
    _ = Symbol.for("react.lazy"),
    E = Symbol.for("react.offscreen"),
    T = Symbol.iterator;
  function R(c) {
    return c === null || typeof c != "object"
      ? null
      : ((c = (T && c[T]) || c["@@iterator"]),
        typeof c == "function" ? c : null);
  }
  function P(c) {
    if (c == null) return null;
    if (typeof c == "function") return c.displayName || c.name || null;
    if (typeof c == "string") return c;
    switch (c) {
      case h:
        return "Fragment";
      case u:
        return "Portal";
      case p:
        return "Profiler";
      case d:
        return "StrictMode";
      case A:
        return "Suspense";
      case g:
        return "SuspenseList";
    }
    if (typeof c == "object")
      switch (c.$$typeof) {
        case y:
          return (c.displayName || "Context") + ".Consumer";
        case m:
          return (c._context.displayName || "Context") + ".Provider";
        case M:
          var f = c.render;
          return (
            (c = c.displayName),
            c ||
              ((c = f.displayName || f.name || ""),
              (c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef")),
            c
          );
        case x:
          return (
            (f = c.displayName || null), f !== null ? f : P(c.type) || "Memo"
          );
        case _:
          (f = c._payload), (c = c._init);
          try {
            return P(c(f));
          } catch {}
      }
    return null;
  }
  function B(c) {
    var f = c.type;
    switch (c.tag) {
      case 24:
        return "Cache";
      case 9:
        return (f.displayName || "Context") + ".Consumer";
      case 10:
        return (f._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (c = f.render),
          (c = c.displayName || c.name || ""),
          f.displayName || (c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return f;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return P(f);
      case 8:
        return f === d ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof f == "function") return f.displayName || f.name || null;
        if (typeof f == "string") return f;
    }
    return null;
  }
  function b(c) {
    var f = c,
      v = c;
    if (c.alternate) for (; f.return; ) f = f.return;
    else {
      c = f;
      do (f = c), f.flags & 4098 && (v = f.return), (c = f.return);
      while (c);
    }
    return f.tag === 3 ? v : null;
  }
  function L(c) {
    if (b(c) !== c) throw Error(o(188));
  }
  function z(c) {
    var f = c.alternate;
    if (!f) {
      if (((f = b(c)), f === null)) throw Error(o(188));
      return f !== c ? null : c;
    }
    for (var v = c, S = f; ; ) {
      var w = v.return;
      if (w === null) break;
      var C = w.alternate;
      if (C === null) {
        if (((S = w.return), S !== null)) {
          v = S;
          continue;
        }
        break;
      }
      if (w.child === C.child) {
        for (C = w.child; C; ) {
          if (C === v) return L(w), c;
          if (C === S) return L(w), f;
          C = C.sibling;
        }
        throw Error(o(188));
      }
      if (v.return !== S.return) (v = w), (S = C);
      else {
        for (var O = !1, Z = w.child; Z; ) {
          if (Z === v) {
            (O = !0), (v = w), (S = C);
            break;
          }
          if (Z === S) {
            (O = !0), (S = w), (v = C);
            break;
          }
          Z = Z.sibling;
        }
        if (!O) {
          for (Z = C.child; Z; ) {
            if (Z === v) {
              (O = !0), (v = C), (S = w);
              break;
            }
            if (Z === S) {
              (O = !0), (S = C), (v = w);
              break;
            }
            Z = Z.sibling;
          }
          if (!O) throw Error(o(189));
        }
      }
      if (v.alternate !== S) throw Error(o(190));
    }
    if (v.tag !== 3) throw Error(o(188));
    return v.stateNode.current === v ? c : f;
  }
  function $(c) {
    return (c = z(c)), c !== null ? X(c) : null;
  }
  function X(c) {
    if (c.tag === 5 || c.tag === 6) return c;
    for (c = c.child; c !== null; ) {
      var f = X(c);
      if (f !== null) return f;
      c = c.sibling;
    }
    return null;
  }
  function Y(c) {
    if (c.tag === 5 || c.tag === 6) return c;
    for (c = c.child; c !== null; ) {
      if (c.tag !== 4) {
        var f = Y(c);
        if (f !== null) return f;
      }
      c = c.sibling;
    }
    return null;
  }
  var K = Array.isArray,
    ie = e.getPublicInstance,
    ee = e.getRootHostContext,
    I = e.getChildHostContext,
    G = e.prepareForCommit,
    k = e.resetAfterCommit,
    U = e.createInstance,
    j = e.appendInitialChild,
    he = e.finalizeInitialChildren,
    ae = e.prepareUpdate,
    xe = e.shouldSetTextContent,
    Ae = e.createTextInstance,
    Le = e.scheduleTimeout,
    Ve = e.cancelTimeout,
    ct = e.noTimeout,
    tt = e.isPrimaryRenderer,
    Me = e.supportsMutation,
    V = e.supportsPersistence,
    ye = e.supportsHydration,
    me = e.getInstanceFromNode,
    Ee = e.preparePortalMount,
    _e = e.getCurrentEventPriority,
    We = e.detachDeletedInstance,
    Oe = e.supportsMicrotasks,
    Ge = e.scheduleMicrotask,
    Ze = e.supportsTestSelectors,
    vt = e.findFiberRoot,
    kt = e.getBoundingRect,
    H = e.getTextContent,
    D = e.isHiddenSubtree,
    ce = e.matchAccessibilityRole,
    we = e.setFocusIfFocusable,
    Se = e.setupIntersectionObserver,
    Fe = e.appendChild,
    Ke = e.appendChildToContainer,
    Ie = e.commitTextUpdate,
    de = e.commitMount,
    J = e.commitUpdate,
    fe = e.insertBefore,
    Te = e.insertInContainerBefore,
    be = e.removeChild,
    De = e.removeChildFromContainer,
    nt = e.resetTextContent,
    Pt = e.hideInstance,
    Q = e.hideTextInstance,
    Pe = e.unhideInstance,
    oe = e.unhideTextInstance,
    Be = e.clearContainer,
    He = e.cloneInstance,
    Tt = e.createContainerChildSet,
    Vt = e.appendChildToContainerChildSet,
    An = e.finalizeContainerChildren,
    Di = e.replaceContainerChildren,
    Xt = e.cloneHiddenInstance,
    Fi = e.cloneHiddenTextInstance,
    jn = e.canHydrateInstance,
    Wh = e.canHydrateTextInstance,
    jh = e.canHydrateSuspenseInstance,
    Xh = e.isSuspenseInstancePending,
    no = e.isSuspenseInstanceFallback,
    Jh = e.registerSuspenseInstanceRetry,
    $r = e.getNextHydratableSibling,
    Kh = e.getFirstHydratableChild,
    y0 = e.getFirstHydratableChildWithinContainer,
    x0 = e.getFirstHydratableChildWithinSuspenseInstance,
    _0 = e.hydrateInstance,
    N = e.hydrateTextInstance,
    se = e.hydrateSuspenseInstance,
    pe = e.getNextHydratableInstanceAfterSuspenseInstance,
    ne = e.commitHydratedContainer,
    ge = e.commitHydratedSuspenseInstance,
    Xe = e.clearSuspenseBoundary,
    $e = e.clearSuspenseBoundaryFromContainer,
    st = e.shouldDeleteUnhydratedTailInstances,
    ot = e.didNotMatchHydratedContainerTextInstance,
    St = e.didNotMatchHydratedTextInstance,
    at;
  function lt(c) {
    if (at === void 0)
      try {
        throw Error();
      } catch (v) {
        var f = v.stack.trim().match(/\n( *(at )?)/);
        at = (f && f[1]) || "";
      }
    return (
      `
` +
      at +
      c
    );
  }
  var Wt = !1;
  function Jt(c, f) {
    if (!c || Wt) return "";
    Wt = !0;
    var v = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (f)
        if (
          ((f = function () {
            throw Error();
          }),
          Object.defineProperty(f.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(f, []);
          } catch (Re) {
            var S = Re;
          }
          Reflect.construct(c, [], f);
        } else {
          try {
            f.call();
          } catch (Re) {
            S = Re;
          }
          c.call(f.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Re) {
          S = Re;
        }
        c();
      }
    } catch (Re) {
      if (Re && S && typeof Re.stack == "string") {
        for (
          var w = Re.stack.split(`
`),
            C = S.stack.split(`
`),
            O = w.length - 1,
            Z = C.length - 1;
          1 <= O && 0 <= Z && w[O] !== C[Z];

        )
          Z--;
        for (; 1 <= O && 0 <= Z; O--, Z--)
          if (w[O] !== C[Z]) {
            if (O !== 1 || Z !== 1)
              do
                if ((O--, Z--, 0 > Z || w[O] !== C[Z])) {
                  var ue =
                    `
` + w[O].replace(" at new ", " at ");
                  return (
                    c.displayName &&
                      ue.includes("<anonymous>") &&
                      (ue = ue.replace("<anonymous>", c.displayName)),
                    ue
                  );
                }
              while (1 <= O && 0 <= Z);
            break;
          }
      }
    } finally {
      (Wt = !1), (Error.prepareStackTrace = v);
    }
    return (c = c ? c.displayName || c.name : "") ? lt(c) : "";
  }
  var Ni = Object.prototype.hasOwnProperty,
    Ui = [],
    zt = -1;
  function ft(c) {
    return { current: c };
  }
  function Nt(c) {
    0 > zt || ((c.current = Ui[zt]), (Ui[zt] = null), zt--);
  }
  function ut(c, f) {
    zt++, (Ui[zt] = c.current), (c.current = f);
  }
  var qn = {},
    Rn = ft(qn),
    Sn = ft(!1),
    Cr = qn;
  function fn(c, f) {
    var v = c.type.contextTypes;
    if (!v) return qn;
    var S = c.stateNode;
    if (S && S.__reactInternalMemoizedUnmaskedChildContext === f)
      return S.__reactInternalMemoizedMaskedChildContext;
    var w = {},
      C;
    for (C in v) w[C] = f[C];
    return (
      S &&
        ((c = c.stateNode),
        (c.__reactInternalMemoizedUnmaskedChildContext = f),
        (c.__reactInternalMemoizedMaskedChildContext = w)),
      w
    );
  }
  function hn(c) {
    return (c = c.childContextTypes), c != null;
  }
  function io() {
    Nt(Sn), Nt(Rn);
  }
  function Zn(c, f, v) {
    if (Rn.current !== qn) throw Error(o(168));
    ut(Rn, f), ut(Sn, v);
  }
  function yl(c, f, v) {
    var S = c.stateNode;
    if (((f = f.childContextTypes), typeof S.getChildContext != "function"))
      return v;
    S = S.getChildContext();
    for (var w in S) if (!(w in f)) throw Error(o(108, B(c) || "Unknown", w));
    return s({}, v, S);
  }
  function xl(c) {
    return (
      (c =
        ((c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext) ||
        qn),
      (Cr = Rn.current),
      ut(Rn, c),
      ut(Sn, Sn.current),
      !0
    );
  }
  function hu(c, f, v) {
    var S = c.stateNode;
    if (!S) throw Error(o(169));
    v
      ? ((c = yl(c, f, Cr)),
        (S.__reactInternalMemoizedMergedChildContext = c),
        Nt(Sn),
        Nt(Rn),
        ut(Rn, c))
      : Nt(Sn),
      ut(Sn, v);
  }
  var br = Math.clz32 ? Math.clz32 : AD,
    xD = Math.log,
    _D = Math.LN2;
  function AD(c) {
    return (c >>>= 0), c === 0 ? 32 : (31 - ((xD(c) / _D) | 0)) | 0;
  }
  var Yh = 64,
    Qh = 4194304;
  function du(c) {
    switch (c & -c) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return c & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return c;
    }
  }
  function qh(c, f) {
    var v = c.pendingLanes;
    if (v === 0) return 0;
    var S = 0,
      w = c.suspendedLanes,
      C = c.pingedLanes,
      O = v & 268435455;
    if (O !== 0) {
      var Z = O & ~w;
      Z !== 0 ? (S = du(Z)) : ((C &= O), C !== 0 && (S = du(C)));
    } else (O = v & ~w), O !== 0 ? (S = du(O)) : C !== 0 && (S = du(C));
    if (S === 0) return 0;
    if (
      f !== 0 &&
      f !== S &&
      !(f & w) &&
      ((w = S & -S), (C = f & -f), w >= C || (w === 16 && (C & 4194240) !== 0))
    )
      return f;
    if ((S & 4 && (S |= v & 16), (f = c.entangledLanes), f !== 0))
      for (c = c.entanglements, f &= S; 0 < f; )
        (v = 31 - br(f)), (w = 1 << v), (S |= c[v]), (f &= ~w);
    return S;
  }
  function SD(c, f) {
    switch (c) {
      case 1:
      case 2:
      case 4:
        return f + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return f + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function MD(c, f) {
    for (
      var v = c.suspendedLanes,
        S = c.pingedLanes,
        w = c.expirationTimes,
        C = c.pendingLanes;
      0 < C;

    ) {
      var O = 31 - br(C),
        Z = 1 << O,
        ue = w[O];
      ue === -1
        ? (!(Z & v) || Z & S) && (w[O] = SD(Z, f))
        : ue <= f && (c.expiredLanes |= Z),
        (C &= ~Z);
    }
  }
  function A0(c) {
    return (
      (c = c.pendingLanes & -1073741825),
      c !== 0 ? c : c & 1073741824 ? 1073741824 : 0
    );
  }
  function S0(c) {
    for (var f = [], v = 0; 31 > v; v++) f.push(c);
    return f;
  }
  function pu(c, f, v) {
    (c.pendingLanes |= f),
      f !== 536870912 && ((c.suspendedLanes = 0), (c.pingedLanes = 0)),
      (c = c.eventTimes),
      (f = 31 - br(f)),
      (c[f] = v);
  }
  function ED(c, f) {
    var v = c.pendingLanes & ~f;
    (c.pendingLanes = f),
      (c.suspendedLanes = 0),
      (c.pingedLanes = 0),
      (c.expiredLanes &= f),
      (c.mutableReadLanes &= f),
      (c.entangledLanes &= f),
      (f = c.entanglements);
    var S = c.eventTimes;
    for (c = c.expirationTimes; 0 < v; ) {
      var w = 31 - br(v),
        C = 1 << w;
      (f[w] = 0), (S[w] = -1), (c[w] = -1), (v &= ~C);
    }
  }
  function M0(c, f) {
    var v = (c.entangledLanes |= f);
    for (c = c.entanglements; v; ) {
      var S = 31 - br(v),
        w = 1 << S;
      (w & f) | (c[S] & f) && (c[S] |= f), (v &= ~w);
    }
  }
  var Lt = 0;
  function BS(c) {
    return (
      (c &= -c), 1 < c ? (4 < c ? (c & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var E0 = r.unstable_scheduleCallback,
    LS = r.unstable_cancelCallback,
    wD = r.unstable_shouldYield,
    TD = r.unstable_requestPaint,
    Nn = r.unstable_now,
    w0 = r.unstable_ImmediatePriority,
    CD = r.unstable_UserBlockingPriority,
    T0 = r.unstable_NormalPriority,
    bD = r.unstable_IdlePriority,
    Zh = null,
    es = null;
  function RD(c) {
    if (es && typeof es.onCommitFiberRoot == "function")
      try {
        es.onCommitFiberRoot(Zh, c, void 0, (c.current.flags & 128) === 128);
      } catch {}
  }
  function PD(c, f) {
    return (c === f && (c !== 0 || 1 / c === 1 / f)) || (c !== c && f !== f);
  }
  var ts = typeof Object.is == "function" ? Object.is : PD,
    Es = null,
    $h = !1,
    C0 = !1;
  function IS(c) {
    Es === null ? (Es = [c]) : Es.push(c);
  }
  function BD(c) {
    ($h = !0), IS(c);
  }
  function ns() {
    if (!C0 && Es !== null) {
      C0 = !0;
      var c = 0,
        f = Lt;
      try {
        var v = Es;
        for (Lt = 1; c < v.length; c++) {
          var S = v[c];
          do S = S(!0);
          while (S !== null);
        }
        (Es = null), ($h = !1);
      } catch (w) {
        throw (Es !== null && (Es = Es.slice(c + 1)), E0(w0, ns), w);
      } finally {
        (Lt = f), (C0 = !1);
      }
    }
    return null;
  }
  var LD = a.ReactCurrentBatchConfig;
  function ed(c, f) {
    if (ts(c, f)) return !0;
    if (
      typeof c != "object" ||
      c === null ||
      typeof f != "object" ||
      f === null
    )
      return !1;
    var v = Object.keys(c),
      S = Object.keys(f);
    if (v.length !== S.length) return !1;
    for (S = 0; S < v.length; S++) {
      var w = v[S];
      if (!Ni.call(f, w) || !ts(c[w], f[w])) return !1;
    }
    return !0;
  }
  function ID(c) {
    switch (c.tag) {
      case 5:
        return lt(c.type);
      case 16:
        return lt("Lazy");
      case 13:
        return lt("Suspense");
      case 19:
        return lt("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (c = Jt(c.type, !1)), c;
      case 11:
        return (c = Jt(c.type.render, !1)), c;
      case 1:
        return (c = Jt(c.type, !0)), c;
      default:
        return "";
    }
  }
  function Rr(c, f) {
    if (c && c.defaultProps) {
      (f = s({}, f)), (c = c.defaultProps);
      for (var v in c) f[v] === void 0 && (f[v] = c[v]);
      return f;
    }
    return f;
  }
  var td = ft(null),
    nd = null,
    _l = null,
    b0 = null;
  function R0() {
    b0 = _l = nd = null;
  }
  function DS(c, f, v) {
    tt
      ? (ut(td, f._currentValue), (f._currentValue = v))
      : (ut(td, f._currentValue2), (f._currentValue2 = v));
  }
  function P0(c) {
    var f = td.current;
    Nt(td), tt ? (c._currentValue = f) : (c._currentValue2 = f);
  }
  function B0(c, f, v) {
    for (; c !== null; ) {
      var S = c.alternate;
      if (
        ((c.childLanes & f) !== f
          ? ((c.childLanes |= f), S !== null && (S.childLanes |= f))
          : S !== null && (S.childLanes & f) !== f && (S.childLanes |= f),
        c === v)
      )
        break;
      c = c.return;
    }
  }
  function Al(c, f) {
    (nd = c),
      (b0 = _l = null),
      (c = c.dependencies),
      c !== null &&
        c.firstContext !== null &&
        (c.lanes & f && (Hi = !0), (c.firstContext = null));
  }
  function rr(c) {
    var f = tt ? c._currentValue : c._currentValue2;
    if (b0 !== c)
      if (((c = { context: c, memoizedValue: f, next: null }), _l === null)) {
        if (nd === null) throw Error(o(308));
        (_l = c), (nd.dependencies = { lanes: 0, firstContext: c });
      } else _l = _l.next = c;
    return f;
  }
  var is = null,
    ro = !1;
  function L0(c) {
    c.updateQueue = {
      baseState: c.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function FS(c, f) {
    (c = c.updateQueue),
      f.updateQueue === c &&
        (f.updateQueue = {
          baseState: c.baseState,
          firstBaseUpdate: c.firstBaseUpdate,
          lastBaseUpdate: c.lastBaseUpdate,
          shared: c.shared,
          effects: c.effects,
        });
  }
  function ws(c, f) {
    return {
      eventTime: c,
      lane: f,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function so(c, f) {
    var v = c.updateQueue;
    v !== null &&
      ((v = v.shared),
      Mn !== null && c.mode & 1 && !(Mt & 2)
        ? ((c = v.interleaved),
          c === null
            ? ((f.next = f), is === null ? (is = [v]) : is.push(v))
            : ((f.next = c.next), (c.next = f)),
          (v.interleaved = f))
        : ((c = v.pending),
          c === null ? (f.next = f) : ((f.next = c.next), (c.next = f)),
          (v.pending = f)));
  }
  function id(c, f, v) {
    if (
      ((f = f.updateQueue), f !== null && ((f = f.shared), (v & 4194240) !== 0))
    ) {
      var S = f.lanes;
      (S &= c.pendingLanes), (v |= S), (f.lanes = v), M0(c, v);
    }
  }
  function NS(c, f) {
    var v = c.updateQueue,
      S = c.alternate;
    if (S !== null && ((S = S.updateQueue), v === S)) {
      var w = null,
        C = null;
      if (((v = v.firstBaseUpdate), v !== null)) {
        do {
          var O = {
            eventTime: v.eventTime,
            lane: v.lane,
            tag: v.tag,
            payload: v.payload,
            callback: v.callback,
            next: null,
          };
          C === null ? (w = C = O) : (C = C.next = O), (v = v.next);
        } while (v !== null);
        C === null ? (w = C = f) : (C = C.next = f);
      } else w = C = f;
      (v = {
        baseState: S.baseState,
        firstBaseUpdate: w,
        lastBaseUpdate: C,
        shared: S.shared,
        effects: S.effects,
      }),
        (c.updateQueue = v);
      return;
    }
    (c = v.lastBaseUpdate),
      c === null ? (v.firstBaseUpdate = f) : (c.next = f),
      (v.lastBaseUpdate = f);
  }
  function rd(c, f, v, S) {
    var w = c.updateQueue;
    ro = !1;
    var C = w.firstBaseUpdate,
      O = w.lastBaseUpdate,
      Z = w.shared.pending;
    if (Z !== null) {
      w.shared.pending = null;
      var ue = Z,
        Re = ue.next;
      (ue.next = null), O === null ? (C = Re) : (O.next = Re), (O = ue);
      var Je = c.alternate;
      Je !== null &&
        ((Je = Je.updateQueue),
        (Z = Je.lastBaseUpdate),
        Z !== O &&
          (Z === null ? (Je.firstBaseUpdate = Re) : (Z.next = Re),
          (Je.lastBaseUpdate = ue)));
    }
    if (C !== null) {
      var ht = w.baseState;
      (O = 0), (Je = Re = ue = null), (Z = C);
      do {
        var et = Z.lane,
          Gt = Z.eventTime;
        if ((S & et) === et) {
          Je !== null &&
            (Je = Je.next =
              {
                eventTime: Gt,
                lane: 0,
                tag: Z.tag,
                payload: Z.payload,
                callback: Z.callback,
                next: null,
              });
          e: {
            var qe = c,
              ni = Z;
            switch (((et = f), (Gt = v), ni.tag)) {
              case 1:
                if (((qe = ni.payload), typeof qe == "function")) {
                  ht = qe.call(Gt, ht, et);
                  break e;
                }
                ht = qe;
                break e;
              case 3:
                qe.flags = (qe.flags & -65537) | 128;
              case 0:
                if (
                  ((qe = ni.payload),
                  (et = typeof qe == "function" ? qe.call(Gt, ht, et) : qe),
                  et == null)
                )
                  break e;
                ht = s({}, ht, et);
                break e;
              case 2:
                ro = !0;
            }
          }
          Z.callback !== null &&
            Z.lane !== 0 &&
            ((c.flags |= 64),
            (et = w.effects),
            et === null ? (w.effects = [Z]) : et.push(Z));
        } else
          (Gt = {
            eventTime: Gt,
            lane: et,
            tag: Z.tag,
            payload: Z.payload,
            callback: Z.callback,
            next: null,
          }),
            Je === null ? ((Re = Je = Gt), (ue = ht)) : (Je = Je.next = Gt),
            (O |= et);
        if (((Z = Z.next), Z === null)) {
          if (((Z = w.shared.pending), Z === null)) break;
          (et = Z),
            (Z = et.next),
            (et.next = null),
            (w.lastBaseUpdate = et),
            (w.shared.pending = null);
        }
      } while (1);
      if (
        (Je === null && (ue = ht),
        (w.baseState = ue),
        (w.firstBaseUpdate = Re),
        (w.lastBaseUpdate = Je),
        (f = w.shared.interleaved),
        f !== null)
      ) {
        w = f;
        do (O |= w.lane), (w = w.next);
        while (w !== f);
      } else C === null && (w.shared.lanes = 0);
      (Pl |= O), (c.lanes = O), (c.memoizedState = ht);
    }
  }
  function US(c, f, v) {
    if (((c = f.effects), (f.effects = null), c !== null))
      for (f = 0; f < c.length; f++) {
        var S = c[f],
          w = S.callback;
        if (w !== null) {
          if (((S.callback = null), (S = v), typeof w != "function"))
            throw Error(o(191, w));
          w.call(S);
        }
      }
  }
  var OS = new i.Component().refs;
  function I0(c, f, v, S) {
    (f = c.memoizedState),
      (v = v(S, f)),
      (v = v == null ? f : s({}, f, v)),
      (c.memoizedState = v),
      c.lanes === 0 && (c.updateQueue.baseState = v);
  }
  var sd = {
    isMounted: function (c) {
      return (c = c._reactInternals) ? b(c) === c : !1;
    },
    enqueueSetState: function (c, f, v) {
      c = c._reactInternals;
      var S = hi(),
        w = lo(c),
        C = ws(S, w);
      (C.payload = f),
        v != null && (C.callback = v),
        so(c, C),
        (f = cr(c, w, S)),
        f !== null && id(f, c, w);
    },
    enqueueReplaceState: function (c, f, v) {
      c = c._reactInternals;
      var S = hi(),
        w = lo(c),
        C = ws(S, w);
      (C.tag = 1),
        (C.payload = f),
        v != null && (C.callback = v),
        so(c, C),
        (f = cr(c, w, S)),
        f !== null && id(f, c, w);
    },
    enqueueForceUpdate: function (c, f) {
      c = c._reactInternals;
      var v = hi(),
        S = lo(c),
        w = ws(v, S);
      (w.tag = 2),
        f != null && (w.callback = f),
        so(c, w),
        (f = cr(c, S, v)),
        f !== null && id(f, c, S);
    },
  };
  function kS(c, f, v, S, w, C, O) {
    return (
      (c = c.stateNode),
      typeof c.shouldComponentUpdate == "function"
        ? c.shouldComponentUpdate(S, C, O)
        : f.prototype && f.prototype.isPureReactComponent
        ? !ed(v, S) || !ed(w, C)
        : !0
    );
  }
  function HS(c, f, v) {
    var S = !1,
      w = qn,
      C = f.contextType;
    return (
      typeof C == "object" && C !== null
        ? (C = rr(C))
        : ((w = hn(f) ? Cr : Rn.current),
          (S = f.contextTypes),
          (C = (S = S != null) ? fn(c, w) : qn)),
      (f = new f(v, C)),
      (c.memoizedState =
        f.state !== null && f.state !== void 0 ? f.state : null),
      (f.updater = sd),
      (c.stateNode = f),
      (f._reactInternals = c),
      S &&
        ((c = c.stateNode),
        (c.__reactInternalMemoizedUnmaskedChildContext = w),
        (c.__reactInternalMemoizedMaskedChildContext = C)),
      f
    );
  }
  function zS(c, f, v, S) {
    (c = f.state),
      typeof f.componentWillReceiveProps == "function" &&
        f.componentWillReceiveProps(v, S),
      typeof f.UNSAFE_componentWillReceiveProps == "function" &&
        f.UNSAFE_componentWillReceiveProps(v, S),
      f.state !== c && sd.enqueueReplaceState(f, f.state, null);
  }
  function D0(c, f, v, S) {
    var w = c.stateNode;
    (w.props = v), (w.state = c.memoizedState), (w.refs = OS), L0(c);
    var C = f.contextType;
    typeof C == "object" && C !== null
      ? (w.context = rr(C))
      : ((C = hn(f) ? Cr : Rn.current), (w.context = fn(c, C))),
      (w.state = c.memoizedState),
      (C = f.getDerivedStateFromProps),
      typeof C == "function" && (I0(c, f, C, v), (w.state = c.memoizedState)),
      typeof f.getDerivedStateFromProps == "function" ||
        typeof w.getSnapshotBeforeUpdate == "function" ||
        (typeof w.UNSAFE_componentWillMount != "function" &&
          typeof w.componentWillMount != "function") ||
        ((f = w.state),
        typeof w.componentWillMount == "function" && w.componentWillMount(),
        typeof w.UNSAFE_componentWillMount == "function" &&
          w.UNSAFE_componentWillMount(),
        f !== w.state && sd.enqueueReplaceState(w, w.state, null),
        rd(c, v, w, S),
        (w.state = c.memoizedState)),
      typeof w.componentDidMount == "function" && (c.flags |= 4194308);
  }
  var Sl = [],
    Ml = 0,
    od = null,
    ad = 0,
    sr = [],
    or = 0,
    aa = null,
    Ts = 1,
    Cs = "";
  function la(c, f) {
    (Sl[Ml++] = ad), (Sl[Ml++] = od), (od = c), (ad = f);
  }
  function GS(c, f, v) {
    (sr[or++] = Ts), (sr[or++] = Cs), (sr[or++] = aa), (aa = c);
    var S = Ts;
    c = Cs;
    var w = 32 - br(S) - 1;
    (S &= ~(1 << w)), (v += 1);
    var C = 32 - br(f) + w;
    if (30 < C) {
      var O = w - (w % 5);
      (C = (S & ((1 << O) - 1)).toString(32)),
        (S >>= O),
        (w -= O),
        (Ts = (1 << (32 - br(f) + w)) | (v << w) | S),
        (Cs = C + c);
    } else (Ts = (1 << C) | (v << w) | S), (Cs = c);
  }
  function F0(c) {
    c.return !== null && (la(c, 1), GS(c, 1, 0));
  }
  function N0(c) {
    for (; c === od; )
      (od = Sl[--Ml]), (Sl[Ml] = null), (ad = Sl[--Ml]), (Sl[Ml] = null);
    for (; c === aa; )
      (aa = sr[--or]),
        (sr[or] = null),
        (Cs = sr[--or]),
        (sr[or] = null),
        (Ts = sr[--or]),
        (sr[or] = null);
  }
  var Oi = null,
    ki = null,
    qt = !1,
    mu = !1,
    Pr = null;
  function VS(c, f) {
    var v = ur(5, null, null, 0);
    (v.elementType = "DELETED"),
      (v.stateNode = f),
      (v.return = c),
      (f = c.deletions),
      f === null ? ((c.deletions = [v]), (c.flags |= 16)) : f.push(v);
  }
  function WS(c, f) {
    switch (c.tag) {
      case 5:
        return (
          (f = jn(f, c.type, c.pendingProps)),
          f !== null ? ((c.stateNode = f), (Oi = c), (ki = Kh(f)), !0) : !1
        );
      case 6:
        return (
          (f = Wh(f, c.pendingProps)),
          f !== null ? ((c.stateNode = f), (Oi = c), (ki = null), !0) : !1
        );
      case 13:
        if (((f = jh(f)), f !== null)) {
          var v = aa !== null ? { id: Ts, overflow: Cs } : null;
          return (
            (c.memoizedState = {
              dehydrated: f,
              treeContext: v,
              retryLane: 1073741824,
            }),
            (v = ur(18, null, null, 0)),
            (v.stateNode = f),
            (v.return = c),
            (c.child = v),
            (Oi = c),
            (ki = null),
            !0
          );
        }
        return !1;
      default:
        return !1;
    }
  }
  function U0(c) {
    return (c.mode & 1) !== 0 && (c.flags & 128) === 0;
  }
  function O0(c) {
    if (qt) {
      var f = ki;
      if (f) {
        var v = f;
        if (!WS(c, f)) {
          if (U0(c)) throw Error(o(418));
          f = $r(v);
          var S = Oi;
          f && WS(c, f)
            ? VS(S, v)
            : ((c.flags = (c.flags & -4097) | 2), (qt = !1), (Oi = c));
        }
      } else {
        if (U0(c)) throw Error(o(418));
        (c.flags = (c.flags & -4097) | 2), (qt = !1), (Oi = c);
      }
    }
  }
  function jS(c) {
    for (
      c = c.return;
      c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13;

    )
      c = c.return;
    Oi = c;
  }
  function gu(c) {
    if (!ye || c !== Oi) return !1;
    if (!qt) return jS(c), (qt = !0), !1;
    if (
      c.tag !== 3 &&
      (c.tag !== 5 || (st(c.type) && !xe(c.type, c.memoizedProps)))
    ) {
      var f = ki;
      if (f) {
        if (U0(c)) {
          for (c = ki; c; ) c = $r(c);
          throw Error(o(418));
        }
        for (; f; ) VS(c, f), (f = $r(f));
      }
    }
    if ((jS(c), c.tag === 13)) {
      if (!ye) throw Error(o(316));
      if (((c = c.memoizedState), (c = c !== null ? c.dehydrated : null), !c))
        throw Error(o(317));
      ki = pe(c);
    } else ki = Oi ? $r(c.stateNode) : null;
    return !0;
  }
  function El() {
    ye && ((ki = Oi = null), (mu = qt = !1));
  }
  function k0(c) {
    Pr === null ? (Pr = [c]) : Pr.push(c);
  }
  function vu(c, f, v) {
    if (
      ((c = v.ref),
      c !== null && typeof c != "function" && typeof c != "object")
    ) {
      if (v._owner) {
        if (((v = v._owner), v)) {
          if (v.tag !== 1) throw Error(o(309));
          var S = v.stateNode;
        }
        if (!S) throw Error(o(147, c));
        var w = S,
          C = "" + c;
        return f !== null &&
          f.ref !== null &&
          typeof f.ref == "function" &&
          f.ref._stringRef === C
          ? f.ref
          : ((f = function (O) {
              var Z = w.refs;
              Z === OS && (Z = w.refs = {}),
                O === null ? delete Z[C] : (Z[C] = O);
            }),
            (f._stringRef = C),
            f);
      }
      if (typeof c != "string") throw Error(o(284));
      if (!v._owner) throw Error(o(290, c));
    }
    return c;
  }
  function ld(c, f) {
    throw (
      ((c = Object.prototype.toString.call(f)),
      Error(
        o(
          31,
          c === "[object Object]"
            ? "object with keys {" + Object.keys(f).join(", ") + "}"
            : c
        )
      ))
    );
  }
  function XS(c) {
    var f = c._init;
    return f(c._payload);
  }
  function JS(c) {
    function f(re, te) {
      if (c) {
        var le = re.deletions;
        le === null ? ((re.deletions = [te]), (re.flags |= 16)) : le.push(te);
      }
    }
    function v(re, te) {
      if (!c) return null;
      for (; te !== null; ) f(re, te), (te = te.sibling);
      return null;
    }
    function S(re, te) {
      for (re = new Map(); te !== null; )
        te.key !== null ? re.set(te.key, te) : re.set(te.index, te),
          (te = te.sibling);
      return re;
    }
    function w(re, te) {
      return (re = uo(re, te)), (re.index = 0), (re.sibling = null), re;
    }
    function C(re, te, le) {
      return (
        (re.index = le),
        c
          ? ((le = re.alternate),
            le !== null
              ? ((le = le.index), le < te ? ((re.flags |= 2), te) : le)
              : ((re.flags |= 2), te))
          : ((re.flags |= 1048576), te)
      );
    }
    function O(re) {
      return c && re.alternate === null && (re.flags |= 2), re;
    }
    function Z(re, te, le, ze) {
      return te === null || te.tag !== 6
        ? ((te = Sv(le, re.mode, ze)), (te.return = re), te)
        : ((te = w(te, le)), (te.return = re), te);
    }
    function ue(re, te, le, ze) {
      var Qe = le.type;
      return Qe === h
        ? Je(re, te, le.props.children, ze, le.key)
        : te !== null &&
          (te.elementType === Qe ||
            (typeof Qe == "object" &&
              Qe !== null &&
              Qe.$$typeof === _ &&
              XS(Qe) === te.type))
        ? ((ze = w(te, le.props)),
          (ze.ref = vu(re, te, le)),
          (ze.return = re),
          ze)
        : ((ze = kd(le.type, le.key, le.props, null, re.mode, ze)),
          (ze.ref = vu(re, te, le)),
          (ze.return = re),
          ze);
    }
    function Re(re, te, le, ze) {
      return te === null ||
        te.tag !== 4 ||
        te.stateNode.containerInfo !== le.containerInfo ||
        te.stateNode.implementation !== le.implementation
        ? ((te = Mv(le, re.mode, ze)), (te.return = re), te)
        : ((te = w(te, le.children || [])), (te.return = re), te);
    }
    function Je(re, te, le, ze, Qe) {
      return te === null || te.tag !== 7
        ? ((te = ma(le, re.mode, ze, Qe)), (te.return = re), te)
        : ((te = w(te, le)), (te.return = re), te);
    }
    function ht(re, te, le) {
      if ((typeof te == "string" && te !== "") || typeof te == "number")
        return (te = Sv("" + te, re.mode, le)), (te.return = re), te;
      if (typeof te == "object" && te !== null) {
        switch (te.$$typeof) {
          case l:
            return (
              (le = kd(te.type, te.key, te.props, null, re.mode, le)),
              (le.ref = vu(re, null, te)),
              (le.return = re),
              le
            );
          case u:
            return (te = Mv(te, re.mode, le)), (te.return = re), te;
          case _:
            var ze = te._init;
            return ht(re, ze(te._payload), le);
        }
        if (K(te) || R(te))
          return (te = ma(te, re.mode, le, null)), (te.return = re), te;
        ld(re, te);
      }
      return null;
    }
    function et(re, te, le, ze) {
      var Qe = te !== null ? te.key : null;
      if ((typeof le == "string" && le !== "") || typeof le == "number")
        return Qe !== null ? null : Z(re, te, "" + le, ze);
      if (typeof le == "object" && le !== null) {
        switch (le.$$typeof) {
          case l:
            return le.key === Qe ? ue(re, te, le, ze) : null;
          case u:
            return le.key === Qe ? Re(re, te, le, ze) : null;
          case _:
            return (Qe = le._init), et(re, te, Qe(le._payload), ze);
        }
        if (K(le) || R(le))
          return Qe !== null ? null : Je(re, te, le, ze, null);
        ld(re, le);
      }
      return null;
    }
    function Gt(re, te, le, ze, Qe) {
      if ((typeof ze == "string" && ze !== "") || typeof ze == "number")
        return (re = re.get(le) || null), Z(te, re, "" + ze, Qe);
      if (typeof ze == "object" && ze !== null) {
        switch (ze.$$typeof) {
          case l:
            return (
              (re = re.get(ze.key === null ? le : ze.key) || null),
              ue(te, re, ze, Qe)
            );
          case u:
            return (
              (re = re.get(ze.key === null ? le : ze.key) || null),
              Re(te, re, ze, Qe)
            );
          case _:
            var xt = ze._init;
            return Gt(re, te, le, xt(ze._payload), Qe);
        }
        if (K(ze) || R(ze))
          return (re = re.get(le) || null), Je(te, re, ze, Qe, null);
        ld(te, ze);
      }
      return null;
    }
    function qe(re, te, le, ze) {
      for (
        var Qe = null, xt = null, dt = te, It = (te = 0), On = null;
        dt !== null && It < le.length;
        It++
      ) {
        dt.index > It ? ((On = dt), (dt = null)) : (On = dt.sibling);
        var Dt = et(re, dt, le[It], ze);
        if (Dt === null) {
          dt === null && (dt = On);
          break;
        }
        c && dt && Dt.alternate === null && f(re, dt),
          (te = C(Dt, te, It)),
          xt === null ? (Qe = Dt) : (xt.sibling = Dt),
          (xt = Dt),
          (dt = On);
      }
      if (It === le.length) return v(re, dt), qt && la(re, It), Qe;
      if (dt === null) {
        for (; It < le.length; It++)
          (dt = ht(re, le[It], ze)),
            dt !== null &&
              ((te = C(dt, te, It)),
              xt === null ? (Qe = dt) : (xt.sibling = dt),
              (xt = dt));
        return qt && la(re, It), Qe;
      }
      for (dt = S(re, dt); It < le.length; It++)
        (On = Gt(dt, re, It, le[It], ze)),
          On !== null &&
            (c &&
              On.alternate !== null &&
              dt.delete(On.key === null ? It : On.key),
            (te = C(On, te, It)),
            xt === null ? (Qe = On) : (xt.sibling = On),
            (xt = On));
      return (
        c &&
          dt.forEach(function (fo) {
            return f(re, fo);
          }),
        qt && la(re, It),
        Qe
      );
    }
    function ni(re, te, le, ze) {
      var Qe = R(le);
      if (typeof Qe != "function") throw Error(o(150));
      if (((le = Qe.call(le)), le == null)) throw Error(o(151));
      for (
        var xt = (Qe = null), dt = te, It = (te = 0), On = null, Dt = le.next();
        dt !== null && !Dt.done;
        It++, Dt = le.next()
      ) {
        dt.index > It ? ((On = dt), (dt = null)) : (On = dt.sibling);
        var fo = et(re, dt, Dt.value, ze);
        if (fo === null) {
          dt === null && (dt = On);
          break;
        }
        c && dt && fo.alternate === null && f(re, dt),
          (te = C(fo, te, It)),
          xt === null ? (Qe = fo) : (xt.sibling = fo),
          (xt = fo),
          (dt = On);
      }
      if (Dt.done) return v(re, dt), qt && la(re, It), Qe;
      if (dt === null) {
        for (; !Dt.done; It++, Dt = le.next())
          (Dt = ht(re, Dt.value, ze)),
            Dt !== null &&
              ((te = C(Dt, te, It)),
              xt === null ? (Qe = Dt) : (xt.sibling = Dt),
              (xt = Dt));
        return qt && la(re, It), Qe;
      }
      for (dt = S(re, dt); !Dt.done; It++, Dt = le.next())
        (Dt = Gt(dt, re, It, Dt.value, ze)),
          Dt !== null &&
            (c &&
              Dt.alternate !== null &&
              dt.delete(Dt.key === null ? It : Dt.key),
            (te = C(Dt, te, It)),
            xt === null ? (Qe = Dt) : (xt.sibling = Dt),
            (xt = Dt));
      return (
        c &&
          dt.forEach(function (c3) {
            return f(re, c3);
          }),
        qt && la(re, It),
        Qe
      );
    }
    function fr(re, te, le, ze) {
      if (
        (typeof le == "object" &&
          le !== null &&
          le.type === h &&
          le.key === null &&
          (le = le.props.children),
        typeof le == "object" && le !== null)
      ) {
        switch (le.$$typeof) {
          case l:
            e: {
              for (var Qe = le.key, xt = te; xt !== null; ) {
                if (xt.key === Qe) {
                  if (((Qe = le.type), Qe === h)) {
                    if (xt.tag === 7) {
                      v(re, xt.sibling),
                        (te = w(xt, le.props.children)),
                        (te.return = re),
                        (re = te);
                      break e;
                    }
                  } else if (
                    xt.elementType === Qe ||
                    (typeof Qe == "object" &&
                      Qe !== null &&
                      Qe.$$typeof === _ &&
                      XS(Qe) === xt.type)
                  ) {
                    v(re, xt.sibling),
                      (te = w(xt, le.props)),
                      (te.ref = vu(re, xt, le)),
                      (te.return = re),
                      (re = te);
                    break e;
                  }
                  v(re, xt);
                  break;
                } else f(re, xt);
                xt = xt.sibling;
              }
              le.type === h
                ? ((te = ma(le.props.children, re.mode, ze, le.key)),
                  (te.return = re),
                  (re = te))
                : ((ze = kd(le.type, le.key, le.props, null, re.mode, ze)),
                  (ze.ref = vu(re, te, le)),
                  (ze.return = re),
                  (re = ze));
            }
            return O(re);
          case u:
            e: {
              for (xt = le.key; te !== null; ) {
                if (te.key === xt)
                  if (
                    te.tag === 4 &&
                    te.stateNode.containerInfo === le.containerInfo &&
                    te.stateNode.implementation === le.implementation
                  ) {
                    v(re, te.sibling),
                      (te = w(te, le.children || [])),
                      (te.return = re),
                      (re = te);
                    break e;
                  } else {
                    v(re, te);
                    break;
                  }
                else f(re, te);
                te = te.sibling;
              }
              (te = Mv(le, re.mode, ze)), (te.return = re), (re = te);
            }
            return O(re);
          case _:
            return (xt = le._init), fr(re, te, xt(le._payload), ze);
        }
        if (K(le)) return qe(re, te, le, ze);
        if (R(le)) return ni(re, te, le, ze);
        ld(re, le);
      }
      return (typeof le == "string" && le !== "") || typeof le == "number"
        ? ((le = "" + le),
          te !== null && te.tag === 6
            ? (v(re, te.sibling), (te = w(te, le)), (te.return = re), (re = te))
            : (v(re, te),
              (te = Sv(le, re.mode, ze)),
              (te.return = re),
              (re = te)),
          O(re))
        : v(re, te);
    }
    return fr;
  }
  var wl = JS(!0),
    KS = JS(!1),
    yu = {},
    ar = ft(yu),
    xu = ft(yu),
    Tl = ft(yu);
  function rs(c) {
    if (c === yu) throw Error(o(174));
    return c;
  }
  function H0(c, f) {
    ut(Tl, f), ut(xu, c), ut(ar, yu), (c = ee(f)), Nt(ar), ut(ar, c);
  }
  function Cl() {
    Nt(ar), Nt(xu), Nt(Tl);
  }
  function YS(c) {
    var f = rs(Tl.current),
      v = rs(ar.current);
    (f = I(v, c.type, f)), v !== f && (ut(xu, c), ut(ar, f));
  }
  function z0(c) {
    xu.current === c && (Nt(ar), Nt(xu));
  }
  var tn = ft(0);
  function cd(c) {
    for (var f = c; f !== null; ) {
      if (f.tag === 13) {
        var v = f.memoizedState;
        if (v !== null && ((v = v.dehydrated), v === null || Xh(v) || no(v)))
          return f;
      } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
        if (f.flags & 128) return f;
      } else if (f.child !== null) {
        (f.child.return = f), (f = f.child);
        continue;
      }
      if (f === c) break;
      for (; f.sibling === null; ) {
        if (f.return === null || f.return === c) return null;
        f = f.return;
      }
      (f.sibling.return = f.return), (f = f.sibling);
    }
    return null;
  }
  var G0 = [];
  function V0() {
    for (var c = 0; c < G0.length; c++) {
      var f = G0[c];
      tt
        ? (f._workInProgressVersionPrimary = null)
        : (f._workInProgressVersionSecondary = null);
    }
    G0.length = 0;
  }
  var ud = a.ReactCurrentDispatcher,
    lr = a.ReactCurrentBatchConfig,
    bl = 0,
    dn = null,
    $n = null,
    Un = null,
    fd = !1,
    _u = !1,
    Au = 0,
    DD = 0;
  function ei() {
    throw Error(o(321));
  }
  function W0(c, f) {
    if (f === null) return !1;
    for (var v = 0; v < f.length && v < c.length; v++)
      if (!ts(c[v], f[v])) return !1;
    return !0;
  }
  function j0(c, f, v, S, w, C) {
    if (
      ((bl = C),
      (dn = f),
      (f.memoizedState = null),
      (f.updateQueue = null),
      (f.lanes = 0),
      (ud.current = c === null || c.memoizedState === null ? OD : kD),
      (c = v(S, w)),
      _u)
    ) {
      C = 0;
      do {
        if (((_u = !1), (Au = 0), 25 <= C)) throw Error(o(301));
        (C += 1),
          (Un = $n = null),
          (f.updateQueue = null),
          (ud.current = HD),
          (c = v(S, w));
      } while (_u);
    }
    if (
      ((ud.current = gd),
      (f = $n !== null && $n.next !== null),
      (bl = 0),
      (Un = $n = dn = null),
      (fd = !1),
      f)
    )
      throw Error(o(300));
    return c;
  }
  function X0() {
    var c = Au !== 0;
    return (Au = 0), c;
  }
  function bs() {
    var c = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Un === null ? (dn.memoizedState = Un = c) : (Un = Un.next = c), Un;
  }
  function ss() {
    if ($n === null) {
      var c = dn.alternate;
      c = c !== null ? c.memoizedState : null;
    } else c = $n.next;
    var f = Un === null ? dn.memoizedState : Un.next;
    if (f !== null) (Un = f), ($n = c);
    else {
      if (c === null) throw Error(o(310));
      ($n = c),
        (c = {
          memoizedState: $n.memoizedState,
          baseState: $n.baseState,
          baseQueue: $n.baseQueue,
          queue: $n.queue,
          next: null,
        }),
        Un === null ? (dn.memoizedState = Un = c) : (Un = Un.next = c);
    }
    return Un;
  }
  function ca(c, f) {
    return typeof f == "function" ? f(c) : f;
  }
  function hd(c) {
    var f = ss(),
      v = f.queue;
    if (v === null) throw Error(o(311));
    v.lastRenderedReducer = c;
    var S = $n,
      w = S.baseQueue,
      C = v.pending;
    if (C !== null) {
      if (w !== null) {
        var O = w.next;
        (w.next = C.next), (C.next = O);
      }
      (S.baseQueue = w = C), (v.pending = null);
    }
    if (w !== null) {
      (C = w.next), (S = S.baseState);
      var Z = (O = null),
        ue = null,
        Re = C;
      do {
        var Je = Re.lane;
        if ((bl & Je) === Je)
          ue !== null &&
            (ue = ue.next =
              {
                lane: 0,
                action: Re.action,
                hasEagerState: Re.hasEagerState,
                eagerState: Re.eagerState,
                next: null,
              }),
            (S = Re.hasEagerState ? Re.eagerState : c(S, Re.action));
        else {
          var ht = {
            lane: Je,
            action: Re.action,
            hasEagerState: Re.hasEagerState,
            eagerState: Re.eagerState,
            next: null,
          };
          ue === null ? ((Z = ue = ht), (O = S)) : (ue = ue.next = ht),
            (dn.lanes |= Je),
            (Pl |= Je);
        }
        Re = Re.next;
      } while (Re !== null && Re !== C);
      ue === null ? (O = S) : (ue.next = Z),
        ts(S, f.memoizedState) || (Hi = !0),
        (f.memoizedState = S),
        (f.baseState = O),
        (f.baseQueue = ue),
        (v.lastRenderedState = S);
    }
    if (((c = v.interleaved), c !== null)) {
      w = c;
      do (C = w.lane), (dn.lanes |= C), (Pl |= C), (w = w.next);
      while (w !== c);
    } else w === null && (v.lanes = 0);
    return [f.memoizedState, v.dispatch];
  }
  function dd(c) {
    var f = ss(),
      v = f.queue;
    if (v === null) throw Error(o(311));
    v.lastRenderedReducer = c;
    var S = v.dispatch,
      w = v.pending,
      C = f.memoizedState;
    if (w !== null) {
      v.pending = null;
      var O = (w = w.next);
      do (C = c(C, O.action)), (O = O.next);
      while (O !== w);
      ts(C, f.memoizedState) || (Hi = !0),
        (f.memoizedState = C),
        f.baseQueue === null && (f.baseState = C),
        (v.lastRenderedState = C);
    }
    return [C, S];
  }
  function QS() {}
  function qS(c, f) {
    var v = dn,
      S = ss(),
      w = f(),
      C = !ts(S.memoizedState, w);
    if (
      (C && ((S.memoizedState = w), (Hi = !0)),
      (S = S.queue),
      Mu(eM.bind(null, v, S, c), [c]),
      S.getSnapshot !== f || C || (Un !== null && Un.memoizedState.tag & 1))
    ) {
      if (
        ((v.flags |= 2048),
        Su(9, $S.bind(null, v, S, w, f), void 0, null),
        Mn === null)
      )
        throw Error(o(349));
      bl & 30 || ZS(v, f, w);
    }
    return w;
  }
  function ZS(c, f, v) {
    (c.flags |= 16384),
      (c = { getSnapshot: f, value: v }),
      (f = dn.updateQueue),
      f === null
        ? ((f = { lastEffect: null, stores: null }),
          (dn.updateQueue = f),
          (f.stores = [c]))
        : ((v = f.stores), v === null ? (f.stores = [c]) : v.push(c));
  }
  function $S(c, f, v, S) {
    (f.value = v), (f.getSnapshot = S), tM(f) && cr(c, 1, -1);
  }
  function eM(c, f, v) {
    return v(function () {
      tM(f) && cr(c, 1, -1);
    });
  }
  function tM(c) {
    var f = c.getSnapshot;
    c = c.value;
    try {
      var v = f();
      return !ts(c, v);
    } catch {
      return !0;
    }
  }
  function J0(c) {
    var f = bs();
    return (
      typeof c == "function" && (c = c()),
      (f.memoizedState = f.baseState = c),
      (c = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ca,
        lastRenderedState: c,
      }),
      (f.queue = c),
      (c = c.dispatch = UD.bind(null, dn, c)),
      [f.memoizedState, c]
    );
  }
  function Su(c, f, v, S) {
    return (
      (c = { tag: c, create: f, destroy: v, deps: S, next: null }),
      (f = dn.updateQueue),
      f === null
        ? ((f = { lastEffect: null, stores: null }),
          (dn.updateQueue = f),
          (f.lastEffect = c.next = c))
        : ((v = f.lastEffect),
          v === null
            ? (f.lastEffect = c.next = c)
            : ((S = v.next), (v.next = c), (c.next = S), (f.lastEffect = c))),
      c
    );
  }
  function nM() {
    return ss().memoizedState;
  }
  function pd(c, f, v, S) {
    var w = bs();
    (dn.flags |= c),
      (w.memoizedState = Su(1 | f, v, void 0, S === void 0 ? null : S));
  }
  function md(c, f, v, S) {
    var w = ss();
    S = S === void 0 ? null : S;
    var C = void 0;
    if ($n !== null) {
      var O = $n.memoizedState;
      if (((C = O.destroy), S !== null && W0(S, O.deps))) {
        w.memoizedState = Su(f, v, C, S);
        return;
      }
    }
    (dn.flags |= c), (w.memoizedState = Su(1 | f, v, C, S));
  }
  function K0(c, f) {
    return pd(8390656, 8, c, f);
  }
  function Mu(c, f) {
    return md(2048, 8, c, f);
  }
  function iM(c, f) {
    return md(4, 2, c, f);
  }
  function rM(c, f) {
    return md(4, 4, c, f);
  }
  function sM(c, f) {
    if (typeof f == "function")
      return (
        (c = c()),
        f(c),
        function () {
          f(null);
        }
      );
    if (f != null)
      return (
        (c = c()),
        (f.current = c),
        function () {
          f.current = null;
        }
      );
  }
  function oM(c, f, v) {
    return (
      (v = v != null ? v.concat([c]) : null), md(4, 4, sM.bind(null, f, c), v)
    );
  }
  function Y0() {}
  function aM(c, f) {
    var v = ss();
    f = f === void 0 ? null : f;
    var S = v.memoizedState;
    return S !== null && f !== null && W0(f, S[1])
      ? S[0]
      : ((v.memoizedState = [c, f]), c);
  }
  function lM(c, f) {
    var v = ss();
    f = f === void 0 ? null : f;
    var S = v.memoizedState;
    return S !== null && f !== null && W0(f, S[1])
      ? S[0]
      : ((c = c()), (v.memoizedState = [c, f]), c);
  }
  function FD(c, f) {
    var v = Lt;
    (Lt = v !== 0 && 4 > v ? v : 4), c(!0);
    var S = lr.transition;
    lr.transition = {};
    try {
      c(!1), f();
    } finally {
      (Lt = v), (lr.transition = S);
    }
  }
  function cM() {
    return ss().memoizedState;
  }
  function ND(c, f, v) {
    var S = lo(c);
    (v = {
      lane: S,
      action: v,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      uM(c)
        ? fM(f, v)
        : (hM(c, f, v),
          (v = hi()),
          (c = cr(c, S, v)),
          c !== null && dM(c, f, S));
  }
  function UD(c, f, v) {
    var S = lo(c),
      w = {
        lane: S,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (uM(c)) fM(f, w);
    else {
      hM(c, f, w);
      var C = c.alternate;
      if (
        c.lanes === 0 &&
        (C === null || C.lanes === 0) &&
        ((C = f.lastRenderedReducer), C !== null)
      )
        try {
          var O = f.lastRenderedState,
            Z = C(O, v);
          if (((w.hasEagerState = !0), (w.eagerState = Z), ts(Z, O))) return;
        } catch {
        } finally {
        }
      (v = hi()), (c = cr(c, S, v)), c !== null && dM(c, f, S);
    }
  }
  function uM(c) {
    var f = c.alternate;
    return c === dn || (f !== null && f === dn);
  }
  function fM(c, f) {
    _u = fd = !0;
    var v = c.pending;
    v === null ? (f.next = f) : ((f.next = v.next), (v.next = f)),
      (c.pending = f);
  }
  function hM(c, f, v) {
    Mn !== null && c.mode & 1 && !(Mt & 2)
      ? ((c = f.interleaved),
        c === null
          ? ((v.next = v), is === null ? (is = [f]) : is.push(f))
          : ((v.next = c.next), (c.next = v)),
        (f.interleaved = v))
      : ((c = f.pending),
        c === null ? (v.next = v) : ((v.next = c.next), (c.next = v)),
        (f.pending = v));
  }
  function dM(c, f, v) {
    if (v & 4194240) {
      var S = f.lanes;
      (S &= c.pendingLanes), (v |= S), (f.lanes = v), M0(c, v);
    }
  }
  var gd = {
      readContext: rr,
      useCallback: ei,
      useContext: ei,
      useEffect: ei,
      useImperativeHandle: ei,
      useInsertionEffect: ei,
      useLayoutEffect: ei,
      useMemo: ei,
      useReducer: ei,
      useRef: ei,
      useState: ei,
      useDebugValue: ei,
      useDeferredValue: ei,
      useTransition: ei,
      useMutableSource: ei,
      useSyncExternalStore: ei,
      useId: ei,
      unstable_isNewReconciler: !1,
    },
    OD = {
      readContext: rr,
      useCallback: function (c, f) {
        return (bs().memoizedState = [c, f === void 0 ? null : f]), c;
      },
      useContext: rr,
      useEffect: K0,
      useImperativeHandle: function (c, f, v) {
        return (
          (v = v != null ? v.concat([c]) : null),
          pd(4194308, 4, sM.bind(null, f, c), v)
        );
      },
      useLayoutEffect: function (c, f) {
        return pd(4194308, 4, c, f);
      },
      useInsertionEffect: function (c, f) {
        return pd(4, 2, c, f);
      },
      useMemo: function (c, f) {
        var v = bs();
        return (
          (f = f === void 0 ? null : f),
          (c = c()),
          (v.memoizedState = [c, f]),
          c
        );
      },
      useReducer: function (c, f, v) {
        var S = bs();
        return (
          (f = v !== void 0 ? v(f) : f),
          (S.memoizedState = S.baseState = f),
          (c = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: c,
            lastRenderedState: f,
          }),
          (S.queue = c),
          (c = c.dispatch = ND.bind(null, dn, c)),
          [S.memoizedState, c]
        );
      },
      useRef: function (c) {
        var f = bs();
        return (c = { current: c }), (f.memoizedState = c);
      },
      useState: J0,
      useDebugValue: Y0,
      useDeferredValue: function (c) {
        var f = J0(c),
          v = f[0],
          S = f[1];
        return (
          K0(
            function () {
              var w = lr.transition;
              lr.transition = {};
              try {
                S(c);
              } finally {
                lr.transition = w;
              }
            },
            [c]
          ),
          v
        );
      },
      useTransition: function () {
        var c = J0(!1),
          f = c[0];
        return (c = FD.bind(null, c[1])), (bs().memoizedState = c), [f, c];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (c, f, v) {
        var S = dn,
          w = bs();
        if (qt) {
          if (v === void 0) throw Error(o(407));
          v = v();
        } else {
          if (((v = f()), Mn === null)) throw Error(o(349));
          bl & 30 || ZS(S, f, v);
        }
        w.memoizedState = v;
        var C = { value: v, getSnapshot: f };
        return (
          (w.queue = C),
          K0(eM.bind(null, S, C, c), [c]),
          (S.flags |= 2048),
          Su(9, $S.bind(null, S, C, v, f), void 0, null),
          v
        );
      },
      useId: function () {
        var c = bs(),
          f = Mn.identifierPrefix;
        if (qt) {
          var v = Cs,
            S = Ts;
          (v = (S & ~(1 << (32 - br(S) - 1))).toString(32) + v),
            (f = ":" + f + "R" + v),
            (v = Au++),
            0 < v && (f += "H" + v.toString(32)),
            (f += ":");
        } else (v = DD++), (f = ":" + f + "r" + v.toString(32) + ":");
        return (c.memoizedState = f);
      },
      unstable_isNewReconciler: !1,
    },
    kD = {
      readContext: rr,
      useCallback: aM,
      useContext: rr,
      useEffect: Mu,
      useImperativeHandle: oM,
      useInsertionEffect: iM,
      useLayoutEffect: rM,
      useMemo: lM,
      useReducer: hd,
      useRef: nM,
      useState: function () {
        return hd(ca);
      },
      useDebugValue: Y0,
      useDeferredValue: function (c) {
        var f = hd(ca),
          v = f[0],
          S = f[1];
        return (
          Mu(
            function () {
              var w = lr.transition;
              lr.transition = {};
              try {
                S(c);
              } finally {
                lr.transition = w;
              }
            },
            [c]
          ),
          v
        );
      },
      useTransition: function () {
        var c = hd(ca)[0],
          f = ss().memoizedState;
        return [c, f];
      },
      useMutableSource: QS,
      useSyncExternalStore: qS,
      useId: cM,
      unstable_isNewReconciler: !1,
    },
    HD = {
      readContext: rr,
      useCallback: aM,
      useContext: rr,
      useEffect: Mu,
      useImperativeHandle: oM,
      useInsertionEffect: iM,
      useLayoutEffect: rM,
      useMemo: lM,
      useReducer: dd,
      useRef: nM,
      useState: function () {
        return dd(ca);
      },
      useDebugValue: Y0,
      useDeferredValue: function (c) {
        var f = dd(ca),
          v = f[0],
          S = f[1];
        return (
          Mu(
            function () {
              var w = lr.transition;
              lr.transition = {};
              try {
                S(c);
              } finally {
                lr.transition = w;
              }
            },
            [c]
          ),
          v
        );
      },
      useTransition: function () {
        var c = dd(ca)[0],
          f = ss().memoizedState;
        return [c, f];
      },
      useMutableSource: QS,
      useSyncExternalStore: qS,
      useId: cM,
      unstable_isNewReconciler: !1,
    };
  function Q0(c, f) {
    try {
      var v = "",
        S = f;
      do (v += ID(S)), (S = S.return);
      while (S);
      var w = v;
    } catch (C) {
      w =
        `
Error generating stack: ` +
        C.message +
        `
` +
        C.stack;
    }
    return { value: c, source: f, stack: w };
  }
  function q0(c, f) {
    try {
      console.error(f.value);
    } catch (v) {
      setTimeout(function () {
        throw v;
      });
    }
  }
  var zD = typeof WeakMap == "function" ? WeakMap : Map;
  function pM(c, f, v) {
    (v = ws(-1, v)), (v.tag = 3), (v.payload = { element: null });
    var S = f.value;
    return (
      (v.callback = function () {
        Ld || ((Ld = !0), (mv = S)), q0(c, f);
      }),
      v
    );
  }
  function mM(c, f, v) {
    (v = ws(-1, v)), (v.tag = 3);
    var S = c.type.getDerivedStateFromError;
    if (typeof S == "function") {
      var w = f.value;
      (v.payload = function () {
        return S(w);
      }),
        (v.callback = function () {
          q0(c, f);
        });
    }
    var C = c.stateNode;
    return (
      C !== null &&
        typeof C.componentDidCatch == "function" &&
        (v.callback = function () {
          q0(c, f),
            typeof S != "function" &&
              (oo === null ? (oo = new Set([this])) : oo.add(this));
          var O = f.stack;
          this.componentDidCatch(f.value, {
            componentStack: O !== null ? O : "",
          });
        }),
      v
    );
  }
  function gM(c, f, v) {
    var S = c.pingCache;
    if (S === null) {
      S = c.pingCache = new zD();
      var w = new Set();
      S.set(f, w);
    } else (w = S.get(f)), w === void 0 && ((w = new Set()), S.set(f, w));
    w.has(v) || (w.add(v), (c = t3.bind(null, c, f, v)), f.then(c, c));
  }
  function vM(c) {
    do {
      var f;
      if (
        ((f = c.tag === 13) &&
          ((f = c.memoizedState),
          (f = f !== null ? f.dehydrated !== null : !0)),
        f)
      )
        return c;
      c = c.return;
    } while (c !== null);
    return null;
  }
  function yM(c, f, v, S, w) {
    return c.mode & 1
      ? ((c.flags |= 65536), (c.lanes = w), c)
      : (c === f
          ? (c.flags |= 65536)
          : ((c.flags |= 128),
            (v.flags |= 131072),
            (v.flags &= -52805),
            v.tag === 1 &&
              (v.alternate === null
                ? (v.tag = 17)
                : ((f = ws(-1, 1)), (f.tag = 2), so(v, f))),
            (v.lanes |= 1)),
        c);
  }
  function os(c) {
    c.flags |= 4;
  }
  function xM(c, f) {
    if (c !== null && c.child === f.child) return !0;
    if (f.flags & 16) return !1;
    for (c = f.child; c !== null; ) {
      if (c.flags & 12854 || c.subtreeFlags & 12854) return !1;
      c = c.sibling;
    }
    return !0;
  }
  var Eu, wu, vd, yd;
  if (Me)
    (Eu = function (c, f) {
      for (var v = f.child; v !== null; ) {
        if (v.tag === 5 || v.tag === 6) j(c, v.stateNode);
        else if (v.tag !== 4 && v.child !== null) {
          (v.child.return = v), (v = v.child);
          continue;
        }
        if (v === f) break;
        for (; v.sibling === null; ) {
          if (v.return === null || v.return === f) return;
          v = v.return;
        }
        (v.sibling.return = v.return), (v = v.sibling);
      }
    }),
      (wu = function () {}),
      (vd = function (c, f, v, S, w) {
        if (((c = c.memoizedProps), c !== S)) {
          var C = f.stateNode,
            O = rs(ar.current);
          (v = ae(C, v, c, S, w, O)), (f.updateQueue = v) && os(f);
        }
      }),
      (yd = function (c, f, v, S) {
        v !== S && os(f);
      });
  else if (V) {
    Eu = function (c, f, v, S) {
      for (var w = f.child; w !== null; ) {
        if (w.tag === 5) {
          var C = w.stateNode;
          v && S && (C = Xt(C, w.type, w.memoizedProps, w)), j(c, C);
        } else if (w.tag === 6)
          (C = w.stateNode), v && S && (C = Fi(C, w.memoizedProps, w)), j(c, C);
        else if (w.tag !== 4) {
          if (w.tag === 22 && w.memoizedState !== null)
            (C = w.child), C !== null && (C.return = w), Eu(c, w, !0, !0);
          else if (w.child !== null) {
            (w.child.return = w), (w = w.child);
            continue;
          }
        }
        if (w === f) break;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === f) return;
          w = w.return;
        }
        (w.sibling.return = w.return), (w = w.sibling);
      }
    };
    var _M = function (c, f, v, S) {
      for (var w = f.child; w !== null; ) {
        if (w.tag === 5) {
          var C = w.stateNode;
          v && S && (C = Xt(C, w.type, w.memoizedProps, w)), Vt(c, C);
        } else if (w.tag === 6)
          (C = w.stateNode),
            v && S && (C = Fi(C, w.memoizedProps, w)),
            Vt(c, C);
        else if (w.tag !== 4) {
          if (w.tag === 22 && w.memoizedState !== null)
            (C = w.child), C !== null && (C.return = w), _M(c, w, !0, !0);
          else if (w.child !== null) {
            (w.child.return = w), (w = w.child);
            continue;
          }
        }
        if (w === f) break;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === f) return;
          w = w.return;
        }
        (w.sibling.return = w.return), (w = w.sibling);
      }
    };
    (wu = function (c, f) {
      var v = f.stateNode;
      if (!xM(c, f)) {
        c = v.containerInfo;
        var S = Tt(c);
        _M(S, f, !1, !1), (v.pendingChildren = S), os(f), An(c, S);
      }
    }),
      (vd = function (c, f, v, S, w) {
        var C = c.stateNode,
          O = c.memoizedProps;
        if ((c = xM(c, f)) && O === S) f.stateNode = C;
        else {
          var Z = f.stateNode,
            ue = rs(ar.current),
            Re = null;
          O !== S && (Re = ae(Z, v, O, S, w, ue)),
            c && Re === null
              ? (f.stateNode = C)
              : ((C = He(C, Re, v, O, S, f, c, Z)),
                he(C, v, S, w, ue) && os(f),
                (f.stateNode = C),
                c ? os(f) : Eu(C, f, !1, !1));
        }
      }),
      (yd = function (c, f, v, S) {
        v !== S
          ? ((c = rs(Tl.current)),
            (v = rs(ar.current)),
            (f.stateNode = Ae(S, c, v, f)),
            os(f))
          : (f.stateNode = c.stateNode);
      });
  } else (wu = function () {}), (vd = function () {}), (yd = function () {});
  function Tu(c, f) {
    if (!qt)
      switch (c.tailMode) {
        case "hidden":
          f = c.tail;
          for (var v = null; f !== null; )
            f.alternate !== null && (v = f), (f = f.sibling);
          v === null ? (c.tail = null) : (v.sibling = null);
          break;
        case "collapsed":
          v = c.tail;
          for (var S = null; v !== null; )
            v.alternate !== null && (S = v), (v = v.sibling);
          S === null
            ? f || c.tail === null
              ? (c.tail = null)
              : (c.tail.sibling = null)
            : (S.sibling = null);
      }
  }
  function ti(c) {
    var f = c.alternate !== null && c.alternate.child === c.child,
      v = 0,
      S = 0;
    if (f)
      for (var w = c.child; w !== null; )
        (v |= w.lanes | w.childLanes),
          (S |= w.subtreeFlags & 14680064),
          (S |= w.flags & 14680064),
          (w.return = c),
          (w = w.sibling);
    else
      for (w = c.child; w !== null; )
        (v |= w.lanes | w.childLanes),
          (S |= w.subtreeFlags),
          (S |= w.flags),
          (w.return = c),
          (w = w.sibling);
    return (c.subtreeFlags |= S), (c.childLanes = v), f;
  }
  function GD(c, f, v) {
    var S = f.pendingProps;
    switch ((N0(f), f.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ti(f), null;
      case 1:
        return hn(f.type) && io(), ti(f), null;
      case 3:
        return (
          (S = f.stateNode),
          Cl(),
          Nt(Sn),
          Nt(Rn),
          V0(),
          S.pendingContext &&
            ((S.context = S.pendingContext), (S.pendingContext = null)),
          (c === null || c.child === null) &&
            (gu(f)
              ? os(f)
              : c === null ||
                (c.memoizedState.isDehydrated && !(f.flags & 256)) ||
                ((f.flags |= 1024), Pr !== null && (yv(Pr), (Pr = null)))),
          wu(c, f),
          ti(f),
          null
        );
      case 5:
        z0(f), (v = rs(Tl.current));
        var w = f.type;
        if (c !== null && f.stateNode != null)
          vd(c, f, w, S, v),
            c.ref !== f.ref && ((f.flags |= 512), (f.flags |= 2097152));
        else {
          if (!S) {
            if (f.stateNode === null) throw Error(o(166));
            return ti(f), null;
          }
          if (((c = rs(ar.current)), gu(f))) {
            if (!ye) throw Error(o(175));
            (c = _0(f.stateNode, f.type, f.memoizedProps, v, c, f, !mu)),
              (f.updateQueue = c),
              c !== null && os(f);
          } else {
            var C = U(w, S, v, c, f);
            Eu(C, f, !1, !1), (f.stateNode = C), he(C, w, S, v, c) && os(f);
          }
          f.ref !== null && ((f.flags |= 512), (f.flags |= 2097152));
        }
        return ti(f), null;
      case 6:
        if (c && f.stateNode != null) yd(c, f, c.memoizedProps, S);
        else {
          if (typeof S != "string" && f.stateNode === null) throw Error(o(166));
          if (((c = rs(Tl.current)), (v = rs(ar.current)), gu(f))) {
            if (!ye) throw Error(o(176));
            if (
              ((c = f.stateNode),
              (S = f.memoizedProps),
              (v = N(c, S, f, !mu)) && ((w = Oi), w !== null))
            )
              switch (((C = (w.mode & 1) !== 0), w.tag)) {
                case 3:
                  ot(w.stateNode.containerInfo, c, S, C);
                  break;
                case 5:
                  St(w.type, w.memoizedProps, w.stateNode, c, S, C);
              }
            v && os(f);
          } else f.stateNode = Ae(S, c, v, f);
        }
        return ti(f), null;
      case 13:
        if (
          (Nt(tn),
          (S = f.memoizedState),
          qt && ki !== null && f.mode & 1 && !(f.flags & 128))
        ) {
          for (c = ki; c; ) c = $r(c);
          return El(), (f.flags |= 98560), f;
        }
        if (S !== null && S.dehydrated !== null) {
          if (((S = gu(f)), c === null)) {
            if (!S) throw Error(o(318));
            if (!ye) throw Error(o(344));
            if (
              ((c = f.memoizedState),
              (c = c !== null ? c.dehydrated : null),
              !c)
            )
              throw Error(o(317));
            se(c, f);
          } else
            El(), !(f.flags & 128) && (f.memoizedState = null), (f.flags |= 4);
          return ti(f), null;
        }
        return (
          Pr !== null && (yv(Pr), (Pr = null)),
          f.flags & 128
            ? ((f.lanes = v), f)
            : ((S = S !== null),
              (v = !1),
              c === null ? gu(f) : (v = c.memoizedState !== null),
              S &&
                !v &&
                ((f.child.flags |= 8192),
                f.mode & 1 &&
                  (c === null || tn.current & 1 ? Pn === 0 && (Pn = 3) : _v())),
              f.updateQueue !== null && (f.flags |= 4),
              ti(f),
              null)
        );
      case 4:
        return (
          Cl(),
          wu(c, f),
          c === null && Ee(f.stateNode.containerInfo),
          ti(f),
          null
        );
      case 10:
        return P0(f.type._context), ti(f), null;
      case 17:
        return hn(f.type) && io(), ti(f), null;
      case 19:
        if ((Nt(tn), (w = f.memoizedState), w === null)) return ti(f), null;
        if (((S = (f.flags & 128) !== 0), (C = w.rendering), C === null))
          if (S) Tu(w, !1);
          else {
            if (Pn !== 0 || (c !== null && c.flags & 128))
              for (c = f.child; c !== null; ) {
                if (((C = cd(c)), C !== null)) {
                  for (
                    f.flags |= 128,
                      Tu(w, !1),
                      c = C.updateQueue,
                      c !== null && ((f.updateQueue = c), (f.flags |= 4)),
                      f.subtreeFlags = 0,
                      c = v,
                      S = f.child;
                    S !== null;

                  )
                    (v = S),
                      (w = c),
                      (v.flags &= 14680066),
                      (C = v.alternate),
                      C === null
                        ? ((v.childLanes = 0),
                          (v.lanes = w),
                          (v.child = null),
                          (v.subtreeFlags = 0),
                          (v.memoizedProps = null),
                          (v.memoizedState = null),
                          (v.updateQueue = null),
                          (v.dependencies = null),
                          (v.stateNode = null))
                        : ((v.childLanes = C.childLanes),
                          (v.lanes = C.lanes),
                          (v.child = C.child),
                          (v.subtreeFlags = 0),
                          (v.deletions = null),
                          (v.memoizedProps = C.memoizedProps),
                          (v.memoizedState = C.memoizedState),
                          (v.updateQueue = C.updateQueue),
                          (v.type = C.type),
                          (w = C.dependencies),
                          (v.dependencies =
                            w === null
                              ? null
                              : {
                                  lanes: w.lanes,
                                  firstContext: w.firstContext,
                                })),
                      (S = S.sibling);
                  return ut(tn, (tn.current & 1) | 2), f.child;
                }
                c = c.sibling;
              }
            w.tail !== null &&
              Nn() > pv &&
              ((f.flags |= 128), (S = !0), Tu(w, !1), (f.lanes = 4194304));
          }
        else {
          if (!S)
            if (((c = cd(C)), c !== null)) {
              if (
                ((f.flags |= 128),
                (S = !0),
                (c = c.updateQueue),
                c !== null && ((f.updateQueue = c), (f.flags |= 4)),
                Tu(w, !0),
                w.tail === null &&
                  w.tailMode === "hidden" &&
                  !C.alternate &&
                  !qt)
              )
                return ti(f), null;
            } else
              2 * Nn() - w.renderingStartTime > pv &&
                v !== 1073741824 &&
                ((f.flags |= 128), (S = !0), Tu(w, !1), (f.lanes = 4194304));
          w.isBackwards
            ? ((C.sibling = f.child), (f.child = C))
            : ((c = w.last),
              c !== null ? (c.sibling = C) : (f.child = C),
              (w.last = C));
        }
        return w.tail !== null
          ? ((f = w.tail),
            (w.rendering = f),
            (w.tail = f.sibling),
            (w.renderingStartTime = Nn()),
            (f.sibling = null),
            (c = tn.current),
            ut(tn, S ? (c & 1) | 2 : c & 1),
            f)
          : (ti(f), null);
      case 22:
      case 23:
        return (
          xv(),
          (S = f.memoizedState !== null),
          c !== null && (c.memoizedState !== null) !== S && (f.flags |= 8192),
          S && f.mode & 1
            ? zi & 1073741824 &&
              (ti(f), Me && f.subtreeFlags & 6 && (f.flags |= 8192))
            : ti(f),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(o(156, f.tag));
  }
  var VD = a.ReactCurrentOwner,
    Hi = !1;
  function fi(c, f, v, S) {
    f.child = c === null ? KS(f, null, v, S) : wl(f, c.child, v, S);
  }
  function AM(c, f, v, S, w) {
    v = v.render;
    var C = f.ref;
    return (
      Al(f, w),
      (S = j0(c, f, v, S, C, w)),
      (v = X0()),
      c !== null && !Hi
        ? ((f.updateQueue = c.updateQueue),
          (f.flags &= -2053),
          (c.lanes &= ~w),
          Rs(c, f, w))
        : (qt && v && F0(f), (f.flags |= 1), fi(c, f, S, w), f.child)
    );
  }
  function SM(c, f, v, S, w) {
    if (c === null) {
      var C = v.type;
      return typeof C == "function" &&
        !Av(C) &&
        C.defaultProps === void 0 &&
        v.compare === null &&
        v.defaultProps === void 0
        ? ((f.tag = 15), (f.type = C), MM(c, f, C, S, w))
        : ((c = kd(v.type, null, S, f, f.mode, w)),
          (c.ref = f.ref),
          (c.return = f),
          (f.child = c));
    }
    if (((C = c.child), !(c.lanes & w))) {
      var O = C.memoizedProps;
      if (
        ((v = v.compare), (v = v !== null ? v : ed), v(O, S) && c.ref === f.ref)
      )
        return Rs(c, f, w);
    }
    return (
      (f.flags |= 1),
      (c = uo(C, S)),
      (c.ref = f.ref),
      (c.return = f),
      (f.child = c)
    );
  }
  function MM(c, f, v, S, w) {
    if (c !== null && ed(c.memoizedProps, S) && c.ref === f.ref)
      if (((Hi = !1), (c.lanes & w) !== 0)) c.flags & 131072 && (Hi = !0);
      else return (f.lanes = c.lanes), Rs(c, f, w);
    return Z0(c, f, v, S, w);
  }
  function EM(c, f, v) {
    var S = f.pendingProps,
      w = S.children,
      C = c !== null ? c.memoizedState : null;
    if (S.mode === "hidden")
      if (!(f.mode & 1))
        (f.memoizedState = { baseLanes: 0, cachePool: null }),
          ut(Rl, zi),
          (zi |= v);
      else if (v & 1073741824)
        (f.memoizedState = { baseLanes: 0, cachePool: null }),
          (S = C !== null ? C.baseLanes : v),
          ut(Rl, zi),
          (zi |= S);
      else
        return (
          (c = C !== null ? C.baseLanes | v : v),
          (f.lanes = f.childLanes = 1073741824),
          (f.memoizedState = { baseLanes: c, cachePool: null }),
          (f.updateQueue = null),
          ut(Rl, zi),
          (zi |= c),
          null
        );
    else
      C !== null ? ((S = C.baseLanes | v), (f.memoizedState = null)) : (S = v),
        ut(Rl, zi),
        (zi |= S);
    return fi(c, f, w, v), f.child;
  }
  function wM(c, f) {
    var v = f.ref;
    ((c === null && v !== null) || (c !== null && c.ref !== v)) &&
      ((f.flags |= 512), (f.flags |= 2097152));
  }
  function Z0(c, f, v, S, w) {
    var C = hn(v) ? Cr : Rn.current;
    return (
      (C = fn(f, C)),
      Al(f, w),
      (v = j0(c, f, v, S, C, w)),
      (S = X0()),
      c !== null && !Hi
        ? ((f.updateQueue = c.updateQueue),
          (f.flags &= -2053),
          (c.lanes &= ~w),
          Rs(c, f, w))
        : (qt && S && F0(f), (f.flags |= 1), fi(c, f, v, w), f.child)
    );
  }
  function TM(c, f, v, S, w) {
    if (hn(v)) {
      var C = !0;
      xl(f);
    } else C = !1;
    if ((Al(f, w), f.stateNode === null))
      c !== null &&
        ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
        HS(f, v, S),
        D0(f, v, S, w),
        (S = !0);
    else if (c === null) {
      var O = f.stateNode,
        Z = f.memoizedProps;
      O.props = Z;
      var ue = O.context,
        Re = v.contextType;
      typeof Re == "object" && Re !== null
        ? (Re = rr(Re))
        : ((Re = hn(v) ? Cr : Rn.current), (Re = fn(f, Re)));
      var Je = v.getDerivedStateFromProps,
        ht =
          typeof Je == "function" ||
          typeof O.getSnapshotBeforeUpdate == "function";
      ht ||
        (typeof O.UNSAFE_componentWillReceiveProps != "function" &&
          typeof O.componentWillReceiveProps != "function") ||
        ((Z !== S || ue !== Re) && zS(f, O, S, Re)),
        (ro = !1);
      var et = f.memoizedState;
      (O.state = et),
        rd(f, S, O, w),
        (ue = f.memoizedState),
        Z !== S || et !== ue || Sn.current || ro
          ? (typeof Je == "function" &&
              (I0(f, v, Je, S), (ue = f.memoizedState)),
            (Z = ro || kS(f, v, Z, S, et, ue, Re))
              ? (ht ||
                  (typeof O.UNSAFE_componentWillMount != "function" &&
                    typeof O.componentWillMount != "function") ||
                  (typeof O.componentWillMount == "function" &&
                    O.componentWillMount(),
                  typeof O.UNSAFE_componentWillMount == "function" &&
                    O.UNSAFE_componentWillMount()),
                typeof O.componentDidMount == "function" &&
                  (f.flags |= 4194308))
              : (typeof O.componentDidMount == "function" &&
                  (f.flags |= 4194308),
                (f.memoizedProps = S),
                (f.memoizedState = ue)),
            (O.props = S),
            (O.state = ue),
            (O.context = Re),
            (S = Z))
          : (typeof O.componentDidMount == "function" && (f.flags |= 4194308),
            (S = !1));
    } else {
      (O = f.stateNode),
        FS(c, f),
        (Z = f.memoizedProps),
        (Re = f.type === f.elementType ? Z : Rr(f.type, Z)),
        (O.props = Re),
        (ht = f.pendingProps),
        (et = O.context),
        (ue = v.contextType),
        typeof ue == "object" && ue !== null
          ? (ue = rr(ue))
          : ((ue = hn(v) ? Cr : Rn.current), (ue = fn(f, ue)));
      var Gt = v.getDerivedStateFromProps;
      (Je =
        typeof Gt == "function" ||
        typeof O.getSnapshotBeforeUpdate == "function") ||
        (typeof O.UNSAFE_componentWillReceiveProps != "function" &&
          typeof O.componentWillReceiveProps != "function") ||
        ((Z !== ht || et !== ue) && zS(f, O, S, ue)),
        (ro = !1),
        (et = f.memoizedState),
        (O.state = et),
        rd(f, S, O, w);
      var qe = f.memoizedState;
      Z !== ht || et !== qe || Sn.current || ro
        ? (typeof Gt == "function" && (I0(f, v, Gt, S), (qe = f.memoizedState)),
          (Re = ro || kS(f, v, Re, S, et, qe, ue) || !1)
            ? (Je ||
                (typeof O.UNSAFE_componentWillUpdate != "function" &&
                  typeof O.componentWillUpdate != "function") ||
                (typeof O.componentWillUpdate == "function" &&
                  O.componentWillUpdate(S, qe, ue),
                typeof O.UNSAFE_componentWillUpdate == "function" &&
                  O.UNSAFE_componentWillUpdate(S, qe, ue)),
              typeof O.componentDidUpdate == "function" && (f.flags |= 4),
              typeof O.getSnapshotBeforeUpdate == "function" &&
                (f.flags |= 1024))
            : (typeof O.componentDidUpdate != "function" ||
                (Z === c.memoizedProps && et === c.memoizedState) ||
                (f.flags |= 4),
              typeof O.getSnapshotBeforeUpdate != "function" ||
                (Z === c.memoizedProps && et === c.memoizedState) ||
                (f.flags |= 1024),
              (f.memoizedProps = S),
              (f.memoizedState = qe)),
          (O.props = S),
          (O.state = qe),
          (O.context = ue),
          (S = Re))
        : (typeof O.componentDidUpdate != "function" ||
            (Z === c.memoizedProps && et === c.memoizedState) ||
            (f.flags |= 4),
          typeof O.getSnapshotBeforeUpdate != "function" ||
            (Z === c.memoizedProps && et === c.memoizedState) ||
            (f.flags |= 1024),
          (S = !1));
    }
    return $0(c, f, v, S, C, w);
  }
  function $0(c, f, v, S, w, C) {
    wM(c, f);
    var O = (f.flags & 128) !== 0;
    if (!S && !O) return w && hu(f, v, !1), Rs(c, f, C);
    (S = f.stateNode), (VD.current = f);
    var Z =
      O && typeof v.getDerivedStateFromError != "function" ? null : S.render();
    return (
      (f.flags |= 1),
      c !== null && O
        ? ((f.child = wl(f, c.child, null, C)), (f.child = wl(f, null, Z, C)))
        : fi(c, f, Z, C),
      (f.memoizedState = S.state),
      w && hu(f, v, !0),
      f.child
    );
  }
  function CM(c) {
    var f = c.stateNode;
    f.pendingContext
      ? Zn(c, f.pendingContext, f.pendingContext !== f.context)
      : f.context && Zn(c, f.context, !1),
      H0(c, f.containerInfo);
  }
  function bM(c, f, v, S, w) {
    return El(), k0(w), (f.flags |= 256), fi(c, f, v, S), f.child;
  }
  var xd = { dehydrated: null, treeContext: null, retryLane: 0 };
  function _d(c) {
    return { baseLanes: c, cachePool: null };
  }
  function RM(c, f, v) {
    var S = f.pendingProps,
      w = tn.current,
      C = !1,
      O = (f.flags & 128) !== 0,
      Z;
    if (
      ((Z = O) ||
        (Z = c !== null && c.memoizedState === null ? !1 : (w & 2) !== 0),
      Z
        ? ((C = !0), (f.flags &= -129))
        : (c === null || c.memoizedState !== null) && (w |= 1),
      ut(tn, w & 1),
      c === null)
    )
      return (
        O0(f),
        (c = f.memoizedState),
        c !== null && ((c = c.dehydrated), c !== null)
          ? (f.mode & 1
              ? no(c)
                ? (f.lanes = 8)
                : (f.lanes = 1073741824)
              : (f.lanes = 1),
            null)
          : ((w = S.children),
            (c = S.fallback),
            C
              ? ((S = f.mode),
                (C = f.child),
                (w = { mode: "hidden", children: w }),
                !(S & 1) && C !== null
                  ? ((C.childLanes = 0), (C.pendingProps = w))
                  : (C = Hd(w, S, 0, null)),
                (c = ma(c, S, v, null)),
                (C.return = f),
                (c.return = f),
                (C.sibling = c),
                (f.child = C),
                (f.child.memoizedState = _d(v)),
                (f.memoizedState = xd),
                c)
              : ev(f, w))
      );
    if (((w = c.memoizedState), w !== null)) {
      if (((Z = w.dehydrated), Z !== null)) {
        if (O)
          return f.flags & 256
            ? ((f.flags &= -257), Ad(c, f, v, Error(o(422))))
            : f.memoizedState !== null
            ? ((f.child = c.child), (f.flags |= 128), null)
            : ((C = S.fallback),
              (w = f.mode),
              (S = Hd({ mode: "visible", children: S.children }, w, 0, null)),
              (C = ma(C, w, v, null)),
              (C.flags |= 2),
              (S.return = f),
              (C.return = f),
              (S.sibling = C),
              (f.child = S),
              f.mode & 1 && wl(f, c.child, null, v),
              (f.child.memoizedState = _d(v)),
              (f.memoizedState = xd),
              C);
        if (!(f.mode & 1)) f = Ad(c, f, v, null);
        else if (no(Z)) f = Ad(c, f, v, Error(o(419)));
        else if (((S = (v & c.childLanes) !== 0), Hi || S)) {
          if (((S = Mn), S !== null)) {
            switch (v & -v) {
              case 4:
                C = 2;
                break;
              case 16:
                C = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                C = 32;
                break;
              case 536870912:
                C = 268435456;
                break;
              default:
                C = 0;
            }
            (S = C & (S.suspendedLanes | v) ? 0 : C),
              S !== 0 && S !== w.retryLane && ((w.retryLane = S), cr(c, S, -1));
          }
          _v(), (f = Ad(c, f, v, Error(o(421))));
        } else
          Xh(Z)
            ? ((f.flags |= 128),
              (f.child = c.child),
              (f = n3.bind(null, c)),
              Jh(Z, f),
              (f = null))
            : ((v = w.treeContext),
              ye &&
                ((ki = x0(Z)),
                (Oi = f),
                (qt = !0),
                (Pr = null),
                (mu = !1),
                v !== null &&
                  ((sr[or++] = Ts),
                  (sr[or++] = Cs),
                  (sr[or++] = aa),
                  (Ts = v.id),
                  (Cs = v.overflow),
                  (aa = f))),
              (f = ev(f, f.pendingProps.children)),
              (f.flags |= 4096));
        return f;
      }
      return C
        ? ((S = BM(c, f, S.children, S.fallback, v)),
          (C = f.child),
          (w = c.child.memoizedState),
          (C.memoizedState =
            w === null
              ? _d(v)
              : { baseLanes: w.baseLanes | v, cachePool: null }),
          (C.childLanes = c.childLanes & ~v),
          (f.memoizedState = xd),
          S)
        : ((v = PM(c, f, S.children, v)), (f.memoizedState = null), v);
    }
    return C
      ? ((S = BM(c, f, S.children, S.fallback, v)),
        (C = f.child),
        (w = c.child.memoizedState),
        (C.memoizedState =
          w === null ? _d(v) : { baseLanes: w.baseLanes | v, cachePool: null }),
        (C.childLanes = c.childLanes & ~v),
        (f.memoizedState = xd),
        S)
      : ((v = PM(c, f, S.children, v)), (f.memoizedState = null), v);
  }
  function ev(c, f) {
    return (
      (f = Hd({ mode: "visible", children: f }, c.mode, 0, null)),
      (f.return = c),
      (c.child = f)
    );
  }
  function PM(c, f, v, S) {
    var w = c.child;
    return (
      (c = w.sibling),
      (v = uo(w, { mode: "visible", children: v })),
      !(f.mode & 1) && (v.lanes = S),
      (v.return = f),
      (v.sibling = null),
      c !== null &&
        ((S = f.deletions),
        S === null ? ((f.deletions = [c]), (f.flags |= 16)) : S.push(c)),
      (f.child = v)
    );
  }
  function BM(c, f, v, S, w) {
    var C = f.mode;
    c = c.child;
    var O = c.sibling,
      Z = { mode: "hidden", children: v };
    return (
      !(C & 1) && f.child !== c
        ? ((v = f.child),
          (v.childLanes = 0),
          (v.pendingProps = Z),
          (f.deletions = null))
        : ((v = uo(c, Z)), (v.subtreeFlags = c.subtreeFlags & 14680064)),
      O !== null ? (S = uo(O, S)) : ((S = ma(S, C, w, null)), (S.flags |= 2)),
      (S.return = f),
      (v.return = f),
      (v.sibling = S),
      (f.child = v),
      S
    );
  }
  function Ad(c, f, v, S) {
    return (
      S !== null && k0(S),
      wl(f, c.child, null, v),
      (c = ev(f, f.pendingProps.children)),
      (c.flags |= 2),
      (f.memoizedState = null),
      c
    );
  }
  function LM(c, f, v) {
    c.lanes |= f;
    var S = c.alternate;
    S !== null && (S.lanes |= f), B0(c.return, f, v);
  }
  function tv(c, f, v, S, w) {
    var C = c.memoizedState;
    C === null
      ? (c.memoizedState = {
          isBackwards: f,
          rendering: null,
          renderingStartTime: 0,
          last: S,
          tail: v,
          tailMode: w,
        })
      : ((C.isBackwards = f),
        (C.rendering = null),
        (C.renderingStartTime = 0),
        (C.last = S),
        (C.tail = v),
        (C.tailMode = w));
  }
  function IM(c, f, v) {
    var S = f.pendingProps,
      w = S.revealOrder,
      C = S.tail;
    if ((fi(c, f, S.children, v), (S = tn.current), S & 2))
      (S = (S & 1) | 2), (f.flags |= 128);
    else {
      if (c !== null && c.flags & 128)
        e: for (c = f.child; c !== null; ) {
          if (c.tag === 13) c.memoizedState !== null && LM(c, v, f);
          else if (c.tag === 19) LM(c, v, f);
          else if (c.child !== null) {
            (c.child.return = c), (c = c.child);
            continue;
          }
          if (c === f) break e;
          for (; c.sibling === null; ) {
            if (c.return === null || c.return === f) break e;
            c = c.return;
          }
          (c.sibling.return = c.return), (c = c.sibling);
        }
      S &= 1;
    }
    if ((ut(tn, S), !(f.mode & 1))) f.memoizedState = null;
    else
      switch (w) {
        case "forwards":
          for (v = f.child, w = null; v !== null; )
            (c = v.alternate),
              c !== null && cd(c) === null && (w = v),
              (v = v.sibling);
          (v = w),
            v === null
              ? ((w = f.child), (f.child = null))
              : ((w = v.sibling), (v.sibling = null)),
            tv(f, !1, w, v, C);
          break;
        case "backwards":
          for (v = null, w = f.child, f.child = null; w !== null; ) {
            if (((c = w.alternate), c !== null && cd(c) === null)) {
              f.child = w;
              break;
            }
            (c = w.sibling), (w.sibling = v), (v = w), (w = c);
          }
          tv(f, !0, v, null, C);
          break;
        case "together":
          tv(f, !1, null, null, void 0);
          break;
        default:
          f.memoizedState = null;
      }
    return f.child;
  }
  function Rs(c, f, v) {
    if (
      (c !== null && (f.dependencies = c.dependencies),
      (Pl |= f.lanes),
      !(v & f.childLanes))
    )
      return null;
    if (c !== null && f.child !== c.child) throw Error(o(153));
    if (f.child !== null) {
      for (
        c = f.child, v = uo(c, c.pendingProps), f.child = v, v.return = f;
        c.sibling !== null;

      )
        (c = c.sibling),
          (v = v.sibling = uo(c, c.pendingProps)),
          (v.return = f);
      v.sibling = null;
    }
    return f.child;
  }
  function WD(c, f, v) {
    switch (f.tag) {
      case 3:
        CM(f), El();
        break;
      case 5:
        YS(f);
        break;
      case 1:
        hn(f.type) && xl(f);
        break;
      case 4:
        H0(f, f.stateNode.containerInfo);
        break;
      case 10:
        DS(f, f.type._context, f.memoizedProps.value);
        break;
      case 13:
        var S = f.memoizedState;
        if (S !== null)
          return S.dehydrated !== null
            ? (ut(tn, tn.current & 1), (f.flags |= 128), null)
            : v & f.child.childLanes
            ? RM(c, f, v)
            : (ut(tn, tn.current & 1),
              (c = Rs(c, f, v)),
              c !== null ? c.sibling : null);
        ut(tn, tn.current & 1);
        break;
      case 19:
        if (((S = (v & f.childLanes) !== 0), c.flags & 128)) {
          if (S) return IM(c, f, v);
          f.flags |= 128;
        }
        var w = f.memoizedState;
        if (
          (w !== null &&
            ((w.rendering = null), (w.tail = null), (w.lastEffect = null)),
          ut(tn, tn.current),
          S)
        )
          break;
        return null;
      case 22:
      case 23:
        return (f.lanes = 0), EM(c, f, v);
    }
    return Rs(c, f, v);
  }
  function jD(c, f) {
    switch ((N0(f), f.tag)) {
      case 1:
        return (
          hn(f.type) && io(),
          (c = f.flags),
          c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
        );
      case 3:
        return (
          Cl(),
          Nt(Sn),
          Nt(Rn),
          V0(),
          (c = f.flags),
          c & 65536 && !(c & 128) ? ((f.flags = (c & -65537) | 128), f) : null
        );
      case 5:
        return z0(f), null;
      case 13:
        if (
          (Nt(tn), (c = f.memoizedState), c !== null && c.dehydrated !== null)
        ) {
          if (f.alternate === null) throw Error(o(340));
          El();
        }
        return (
          (c = f.flags), c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
        );
      case 19:
        return Nt(tn), null;
      case 4:
        return Cl(), null;
      case 10:
        return P0(f.type._context), null;
      case 22:
      case 23:
        return xv(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Sd = !1,
    ua = !1,
    XD = typeof WeakSet == "function" ? WeakSet : Set,
    ke = null;
  function Md(c, f) {
    var v = c.ref;
    if (v !== null)
      if (typeof v == "function")
        try {
          v(null);
        } catch (S) {
          Ei(c, f, S);
        }
      else v.current = null;
  }
  function nv(c, f, v) {
    try {
      v();
    } catch (S) {
      Ei(c, f, S);
    }
  }
  var DM = !1;
  function JD(c, f) {
    for (G(c.containerInfo), ke = f; ke !== null; )
      if (
        ((c = ke), (f = c.child), (c.subtreeFlags & 1028) !== 0 && f !== null)
      )
        (f.return = c), (ke = f);
      else
        for (; ke !== null; ) {
          c = ke;
          try {
            var v = c.alternate;
            if (c.flags & 1024)
              switch (c.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (v !== null) {
                    var S = v.memoizedProps,
                      w = v.memoizedState,
                      C = c.stateNode,
                      O = C.getSnapshotBeforeUpdate(
                        c.elementType === c.type ? S : Rr(c.type, S),
                        w
                      );
                    C.__reactInternalSnapshotBeforeUpdate = O;
                  }
                  break;
                case 3:
                  Me && Be(c.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(o(163));
              }
          } catch (Z) {
            Ei(c, c.return, Z);
          }
          if (((f = c.sibling), f !== null)) {
            (f.return = c.return), (ke = f);
            break;
          }
          ke = c.return;
        }
    return (v = DM), (DM = !1), v;
  }
  function fa(c, f, v) {
    var S = f.updateQueue;
    if (((S = S !== null ? S.lastEffect : null), S !== null)) {
      var w = (S = S.next);
      do {
        if ((w.tag & c) === c) {
          var C = w.destroy;
          (w.destroy = void 0), C !== void 0 && nv(f, v, C);
        }
        w = w.next;
      } while (w !== S);
    }
  }
  function Cu(c, f) {
    if (
      ((f = f.updateQueue), (f = f !== null ? f.lastEffect : null), f !== null)
    ) {
      var v = (f = f.next);
      do {
        if ((v.tag & c) === c) {
          var S = v.create;
          v.destroy = S();
        }
        v = v.next;
      } while (v !== f);
    }
  }
  function iv(c) {
    var f = c.ref;
    if (f !== null) {
      var v = c.stateNode;
      switch (c.tag) {
        case 5:
          c = ie(v);
          break;
        default:
          c = v;
      }
      typeof f == "function" ? f(c) : (f.current = c);
    }
  }
  function FM(c, f, v) {
    if (es && typeof es.onCommitFiberUnmount == "function")
      try {
        es.onCommitFiberUnmount(Zh, f);
      } catch {}
    switch (f.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((c = f.updateQueue), c !== null && ((c = c.lastEffect), c !== null))
        ) {
          var S = (c = c.next);
          do {
            var w = S,
              C = w.destroy;
            (w = w.tag),
              C !== void 0 && (w & 2 || w & 4) && nv(f, v, C),
              (S = S.next);
          } while (S !== c);
        }
        break;
      case 1:
        if (
          (Md(f, v),
          (c = f.stateNode),
          typeof c.componentWillUnmount == "function")
        )
          try {
            (c.props = f.memoizedProps),
              (c.state = f.memoizedState),
              c.componentWillUnmount();
          } catch (O) {
            Ei(f, v, O);
          }
        break;
      case 5:
        Md(f, v);
        break;
      case 4:
        Me
          ? zM(c, f, v)
          : V && V && ((f = f.stateNode.containerInfo), (v = Tt(f)), Di(f, v));
    }
  }
  function NM(c, f, v) {
    for (var S = f; ; )
      if ((FM(c, S, v), S.child === null || (Me && S.tag === 4))) {
        if (S === f) break;
        for (; S.sibling === null; ) {
          if (S.return === null || S.return === f) return;
          S = S.return;
        }
        (S.sibling.return = S.return), (S = S.sibling);
      } else (S.child.return = S), (S = S.child);
  }
  function UM(c) {
    var f = c.alternate;
    f !== null && ((c.alternate = null), UM(f)),
      (c.child = null),
      (c.deletions = null),
      (c.sibling = null),
      c.tag === 5 && ((f = c.stateNode), f !== null && We(f)),
      (c.stateNode = null),
      (c.return = null),
      (c.dependencies = null),
      (c.memoizedProps = null),
      (c.memoizedState = null),
      (c.pendingProps = null),
      (c.stateNode = null),
      (c.updateQueue = null);
  }
  function OM(c) {
    return c.tag === 5 || c.tag === 3 || c.tag === 4;
  }
  function kM(c) {
    e: for (;;) {
      for (; c.sibling === null; ) {
        if (c.return === null || OM(c.return)) return null;
        c = c.return;
      }
      for (
        c.sibling.return = c.return, c = c.sibling;
        c.tag !== 5 && c.tag !== 6 && c.tag !== 18;

      ) {
        if (c.flags & 2 || c.child === null || c.tag === 4) continue e;
        (c.child.return = c), (c = c.child);
      }
      if (!(c.flags & 2)) return c.stateNode;
    }
  }
  function HM(c) {
    if (Me) {
      e: {
        for (var f = c.return; f !== null; ) {
          if (OM(f)) break e;
          f = f.return;
        }
        throw Error(o(160));
      }
      var v = f;
      switch (v.tag) {
        case 5:
          (f = v.stateNode),
            v.flags & 32 && (nt(f), (v.flags &= -33)),
            (v = kM(c)),
            sv(c, v, f);
          break;
        case 3:
        case 4:
          (f = v.stateNode.containerInfo), (v = kM(c)), rv(c, v, f);
          break;
        default:
          throw Error(o(161));
      }
    }
  }
  function rv(c, f, v) {
    var S = c.tag;
    if (S === 5 || S === 6) (c = c.stateNode), f ? Te(v, c, f) : Ke(v, c);
    else if (S !== 4 && ((c = c.child), c !== null))
      for (rv(c, f, v), c = c.sibling; c !== null; )
        rv(c, f, v), (c = c.sibling);
  }
  function sv(c, f, v) {
    var S = c.tag;
    if (S === 5 || S === 6) (c = c.stateNode), f ? fe(v, c, f) : Fe(v, c);
    else if (S !== 4 && ((c = c.child), c !== null))
      for (sv(c, f, v), c = c.sibling; c !== null; )
        sv(c, f, v), (c = c.sibling);
  }
  function zM(c, f, v) {
    for (var S = f, w = !1, C, O; ; ) {
      if (!w) {
        w = S.return;
        e: for (;;) {
          if (w === null) throw Error(o(160));
          switch (((C = w.stateNode), w.tag)) {
            case 5:
              O = !1;
              break e;
            case 3:
              (C = C.containerInfo), (O = !0);
              break e;
            case 4:
              (C = C.containerInfo), (O = !0);
              break e;
          }
          w = w.return;
        }
        w = !0;
      }
      if (S.tag === 5 || S.tag === 6)
        NM(c, S, v), O ? De(C, S.stateNode) : be(C, S.stateNode);
      else if (S.tag === 18) O ? $e(C, S.stateNode) : Xe(C, S.stateNode);
      else if (S.tag === 4) {
        if (S.child !== null) {
          (C = S.stateNode.containerInfo),
            (O = !0),
            (S.child.return = S),
            (S = S.child);
          continue;
        }
      } else if ((FM(c, S, v), S.child !== null)) {
        (S.child.return = S), (S = S.child);
        continue;
      }
      if (S === f) break;
      for (; S.sibling === null; ) {
        if (S.return === null || S.return === f) return;
        (S = S.return), S.tag === 4 && (w = !1);
      }
      (S.sibling.return = S.return), (S = S.sibling);
    }
  }
  function ov(c, f) {
    if (Me) {
      switch (f.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          fa(3, f, f.return), Cu(3, f), fa(5, f, f.return);
          return;
        case 1:
          return;
        case 5:
          var v = f.stateNode;
          if (v != null) {
            var S = f.memoizedProps;
            c = c !== null ? c.memoizedProps : S;
            var w = f.type,
              C = f.updateQueue;
            (f.updateQueue = null), C !== null && J(v, C, w, c, S, f);
          }
          return;
        case 6:
          if (f.stateNode === null) throw Error(o(162));
          (v = f.memoizedProps),
            Ie(f.stateNode, c !== null ? c.memoizedProps : v, v);
          return;
        case 3:
          ye &&
            c !== null &&
            c.memoizedState.isDehydrated &&
            ne(f.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          Ed(f);
          return;
        case 19:
          Ed(f);
          return;
        case 17:
          return;
      }
      throw Error(o(163));
    }
    switch (f.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        fa(3, f, f.return), Cu(3, f), fa(5, f, f.return);
        return;
      case 12:
        return;
      case 13:
        Ed(f);
        return;
      case 19:
        Ed(f);
        return;
      case 3:
        ye &&
          c !== null &&
          c.memoizedState.isDehydrated &&
          ne(f.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (V) {
      switch (f.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          (f = f.stateNode), Di(f.containerInfo, f.pendingChildren);
          break e;
      }
      throw Error(o(163));
    }
  }
  function Ed(c) {
    var f = c.updateQueue;
    if (f !== null) {
      c.updateQueue = null;
      var v = c.stateNode;
      v === null && (v = c.stateNode = new XD()),
        f.forEach(function (S) {
          var w = i3.bind(null, c, S);
          v.has(S) || (v.add(S), S.then(w, w));
        });
    }
  }
  function KD(c, f) {
    for (ke = f; ke !== null; ) {
      f = ke;
      var v = f.deletions;
      if (v !== null)
        for (var S = 0; S < v.length; S++) {
          var w = v[S];
          try {
            var C = c;
            Me ? zM(C, w, f) : NM(C, w, f);
            var O = w.alternate;
            O !== null && (O.return = null), (w.return = null);
          } catch (Qe) {
            Ei(w, f, Qe);
          }
        }
      if (((v = f.child), f.subtreeFlags & 12854 && v !== null))
        (v.return = f), (ke = v);
      else
        for (; ke !== null; ) {
          f = ke;
          try {
            var Z = f.flags;
            if ((Z & 32 && Me && nt(f.stateNode), Z & 512)) {
              var ue = f.alternate;
              if (ue !== null) {
                var Re = ue.ref;
                Re !== null &&
                  (typeof Re == "function" ? Re(null) : (Re.current = null));
              }
            }
            if (Z & 8192)
              switch (f.tag) {
                case 13:
                  if (f.memoizedState !== null) {
                    var Je = f.alternate;
                    (Je === null || Je.memoizedState === null) && (dv = Nn());
                  }
                  break;
                case 22:
                  var ht = f.memoizedState !== null,
                    et = f.alternate,
                    Gt = et !== null && et.memoizedState !== null;
                  if (((v = f), Me)) {
                    e: if (((S = v), (w = ht), (C = null), Me))
                      for (var qe = S; ; ) {
                        if (qe.tag === 5) {
                          if (C === null) {
                            C = qe;
                            var ni = qe.stateNode;
                            w ? Pt(ni) : Pe(qe.stateNode, qe.memoizedProps);
                          }
                        } else if (qe.tag === 6) {
                          if (C === null) {
                            var fr = qe.stateNode;
                            w ? Q(fr) : oe(fr, qe.memoizedProps);
                          }
                        } else if (
                          ((qe.tag !== 22 && qe.tag !== 23) ||
                            qe.memoizedState === null ||
                            qe === S) &&
                          qe.child !== null
                        ) {
                          (qe.child.return = qe), (qe = qe.child);
                          continue;
                        }
                        if (qe === S) break;
                        for (; qe.sibling === null; ) {
                          if (qe.return === null || qe.return === S) break e;
                          C === qe && (C = null), (qe = qe.return);
                        }
                        C === qe && (C = null),
                          (qe.sibling.return = qe.return),
                          (qe = qe.sibling);
                      }
                  }
                  if (ht && !Gt && v.mode & 1) {
                    ke = v;
                    for (var re = v.child; re !== null; ) {
                      for (v = ke = re; ke !== null; ) {
                        S = ke;
                        var te = S.child;
                        switch (S.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            fa(4, S, S.return);
                            break;
                          case 1:
                            Md(S, S.return);
                            var le = S.stateNode;
                            if (typeof le.componentWillUnmount == "function") {
                              var ze = S.return;
                              try {
                                (le.props = S.memoizedProps),
                                  (le.state = S.memoizedState),
                                  le.componentWillUnmount();
                              } catch (Qe) {
                                Ei(S, ze, Qe);
                              }
                            }
                            break;
                          case 5:
                            Md(S, S.return);
                            break;
                          case 22:
                            if (S.memoizedState !== null) {
                              WM(v);
                              continue;
                            }
                        }
                        te !== null ? ((te.return = S), (ke = te)) : WM(v);
                      }
                      re = re.sibling;
                    }
                  }
              }
            switch (Z & 4102) {
              case 2:
                HM(f), (f.flags &= -3);
                break;
              case 6:
                HM(f), (f.flags &= -3), ov(f.alternate, f);
                break;
              case 4096:
                f.flags &= -4097;
                break;
              case 4100:
                (f.flags &= -4097), ov(f.alternate, f);
                break;
              case 4:
                ov(f.alternate, f);
            }
          } catch (Qe) {
            Ei(f, f.return, Qe);
          }
          if (((v = f.sibling), v !== null)) {
            (v.return = f.return), (ke = v);
            break;
          }
          ke = f.return;
        }
    }
  }
  function YD(c, f, v) {
    (ke = c), GM(c);
  }
  function GM(c, f, v) {
    for (var S = (c.mode & 1) !== 0; ke !== null; ) {
      var w = ke,
        C = w.child;
      if (w.tag === 22 && S) {
        var O = w.memoizedState !== null || Sd;
        if (!O) {
          var Z = w.alternate,
            ue = (Z !== null && Z.memoizedState !== null) || ua;
          Z = Sd;
          var Re = ua;
          if (((Sd = O), (ua = ue) && !Re))
            for (ke = w; ke !== null; )
              (O = ke),
                (ue = O.child),
                O.tag === 22 && O.memoizedState !== null
                  ? jM(w)
                  : ue !== null
                  ? ((ue.return = O), (ke = ue))
                  : jM(w);
          for (; C !== null; ) (ke = C), GM(C), (C = C.sibling);
          (ke = w), (Sd = Z), (ua = Re);
        }
        VM(c);
      } else
        w.subtreeFlags & 8772 && C !== null
          ? ((C.return = w), (ke = C))
          : VM(c);
    }
  }
  function VM(c) {
    for (; ke !== null; ) {
      var f = ke;
      if (f.flags & 8772) {
        var v = f.alternate;
        try {
          if (f.flags & 8772)
            switch (f.tag) {
              case 0:
              case 11:
              case 15:
                ua || Cu(5, f);
                break;
              case 1:
                var S = f.stateNode;
                if (f.flags & 4 && !ua)
                  if (v === null) S.componentDidMount();
                  else {
                    var w =
                      f.elementType === f.type
                        ? v.memoizedProps
                        : Rr(f.type, v.memoizedProps);
                    S.componentDidUpdate(
                      w,
                      v.memoizedState,
                      S.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var C = f.updateQueue;
                C !== null && US(f, C, S);
                break;
              case 3:
                var O = f.updateQueue;
                if (O !== null) {
                  if (((v = null), f.child !== null))
                    switch (f.child.tag) {
                      case 5:
                        v = ie(f.child.stateNode);
                        break;
                      case 1:
                        v = f.child.stateNode;
                    }
                  US(f, O, v);
                }
                break;
              case 5:
                var Z = f.stateNode;
                v === null && f.flags & 4 && de(Z, f.type, f.memoizedProps, f);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (ye && f.memoizedState === null) {
                  var ue = f.alternate;
                  if (ue !== null) {
                    var Re = ue.memoizedState;
                    if (Re !== null) {
                      var Je = Re.dehydrated;
                      Je !== null && ge(Je);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(o(163));
            }
          ua || (f.flags & 512 && iv(f));
        } catch (ht) {
          Ei(f, f.return, ht);
        }
      }
      if (f === c) {
        ke = null;
        break;
      }
      if (((v = f.sibling), v !== null)) {
        (v.return = f.return), (ke = v);
        break;
      }
      ke = f.return;
    }
  }
  function WM(c) {
    for (; ke !== null; ) {
      var f = ke;
      if (f === c) {
        ke = null;
        break;
      }
      var v = f.sibling;
      if (v !== null) {
        (v.return = f.return), (ke = v);
        break;
      }
      ke = f.return;
    }
  }
  function jM(c) {
    for (; ke !== null; ) {
      var f = ke;
      try {
        switch (f.tag) {
          case 0:
          case 11:
          case 15:
            var v = f.return;
            try {
              Cu(4, f);
            } catch (ue) {
              Ei(f, v, ue);
            }
            break;
          case 1:
            var S = f.stateNode;
            if (typeof S.componentDidMount == "function") {
              var w = f.return;
              try {
                S.componentDidMount();
              } catch (ue) {
                Ei(f, w, ue);
              }
            }
            var C = f.return;
            try {
              iv(f);
            } catch (ue) {
              Ei(f, C, ue);
            }
            break;
          case 5:
            var O = f.return;
            try {
              iv(f);
            } catch (ue) {
              Ei(f, O, ue);
            }
        }
      } catch (ue) {
        Ei(f, f.return, ue);
      }
      if (f === c) {
        ke = null;
        break;
      }
      var Z = f.sibling;
      if (Z !== null) {
        (Z.return = f.return), (ke = Z);
        break;
      }
      ke = f.return;
    }
  }
  var wd = 0,
    Td = 1,
    Cd = 2,
    bd = 3,
    Rd = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var bu = Symbol.for;
    (wd = bu("selector.component")),
      (Td = bu("selector.has_pseudo_class")),
      (Cd = bu("selector.role")),
      (bd = bu("selector.test_id")),
      (Rd = bu("selector.text"));
  }
  function av(c) {
    var f = me(c);
    if (f != null) {
      if (typeof f.memoizedProps["data-testname"] != "string")
        throw Error(o(364));
      return f;
    }
    if (((c = vt(c)), c === null)) throw Error(o(362));
    return c.stateNode.current;
  }
  function lv(c, f) {
    switch (f.$$typeof) {
      case wd:
        if (c.type === f.value) return !0;
        break;
      case Td:
        e: {
          (f = f.value), (c = [c, 0]);
          for (var v = 0; v < c.length; ) {
            var S = c[v++],
              w = c[v++],
              C = f[w];
            if (S.tag !== 5 || !D(S)) {
              for (; C != null && lv(S, C); ) w++, (C = f[w]);
              if (w === f.length) {
                f = !0;
                break e;
              } else
                for (S = S.child; S !== null; ) c.push(S, w), (S = S.sibling);
            }
          }
          f = !1;
        }
        return f;
      case Cd:
        if (c.tag === 5 && ce(c.stateNode, f.value)) return !0;
        break;
      case Rd:
        if (
          (c.tag === 5 || c.tag === 6) &&
          ((c = H(c)), c !== null && 0 <= c.indexOf(f.value))
        )
          return !0;
        break;
      case bd:
        if (
          c.tag === 5 &&
          ((c = c.memoizedProps["data-testname"]),
          typeof c == "string" && c.toLowerCase() === f.value.toLowerCase())
        )
          return !0;
        break;
      default:
        throw Error(o(365));
    }
    return !1;
  }
  function cv(c) {
    switch (c.$$typeof) {
      case wd:
        return "<" + (P(c.value) || "Unknown") + ">";
      case Td:
        return ":has(" + (cv(c) || "") + ")";
      case Cd:
        return '[role="' + c.value + '"]';
      case Rd:
        return '"' + c.value + '"';
      case bd:
        return '[data-testname="' + c.value + '"]';
      default:
        throw Error(o(365));
    }
  }
  function XM(c, f) {
    var v = [];
    c = [c, 0];
    for (var S = 0; S < c.length; ) {
      var w = c[S++],
        C = c[S++],
        O = f[C];
      if (w.tag !== 5 || !D(w)) {
        for (; O != null && lv(w, O); ) C++, (O = f[C]);
        if (C === f.length) v.push(w);
        else for (w = w.child; w !== null; ) c.push(w, C), (w = w.sibling);
      }
    }
    return v;
  }
  function uv(c, f) {
    if (!Ze) throw Error(o(363));
    (c = av(c)), (c = XM(c, f)), (f = []), (c = Array.from(c));
    for (var v = 0; v < c.length; ) {
      var S = c[v++];
      if (S.tag === 5) D(S) || f.push(S.stateNode);
      else for (S = S.child; S !== null; ) c.push(S), (S = S.sibling);
    }
    return f;
  }
  var QD = Math.ceil,
    Pd = a.ReactCurrentDispatcher,
    fv = a.ReactCurrentOwner,
    yn = a.ReactCurrentBatchConfig,
    Mt = 0,
    Mn = null,
    En = null,
    Xn = 0,
    zi = 0,
    Rl = ft(0),
    Pn = 0,
    Ru = null,
    Pl = 0,
    Bd = 0,
    hv = 0,
    Pu = null,
    Si = null,
    dv = 0,
    pv = 1 / 0;
  function Bl() {
    pv = Nn() + 500;
  }
  var Ld = !1,
    mv = null,
    oo = null,
    Id = !1,
    ao = null,
    Dd = 0,
    Bu = 0,
    gv = null,
    Fd = -1,
    Nd = 0;
  function hi() {
    return Mt & 6 ? Nn() : Fd !== -1 ? Fd : (Fd = Nn());
  }
  function lo(c) {
    return c.mode & 1
      ? Mt & 2 && Xn !== 0
        ? Xn & -Xn
        : LD.transition !== null
        ? (Nd === 0 &&
            ((c = Yh), (Yh <<= 1), !(Yh & 4194240) && (Yh = 64), (Nd = c)),
          Nd)
        : ((c = Lt), c !== 0 ? c : _e())
      : 1;
  }
  function cr(c, f, v) {
    if (50 < Bu) throw ((Bu = 0), (gv = null), Error(o(185)));
    var S = Ud(c, f);
    return S === null
      ? null
      : (pu(S, f, v),
        (!(Mt & 2) || S !== Mn) &&
          (S === Mn && (!(Mt & 2) && (Bd |= f), Pn === 4 && co(S, Xn)),
          Mi(S, v),
          f === 1 && Mt === 0 && !(c.mode & 1) && (Bl(), $h && ns())),
        S);
  }
  function Ud(c, f) {
    c.lanes |= f;
    var v = c.alternate;
    for (v !== null && (v.lanes |= f), v = c, c = c.return; c !== null; )
      (c.childLanes |= f),
        (v = c.alternate),
        v !== null && (v.childLanes |= f),
        (v = c),
        (c = c.return);
    return v.tag === 3 ? v.stateNode : null;
  }
  function Mi(c, f) {
    var v = c.callbackNode;
    MD(c, f);
    var S = qh(c, c === Mn ? Xn : 0);
    if (S === 0)
      v !== null && LS(v), (c.callbackNode = null), (c.callbackPriority = 0);
    else if (((f = S & -S), c.callbackPriority !== f)) {
      if ((v != null && LS(v), f === 1))
        c.tag === 0 ? BD(KM.bind(null, c)) : IS(KM.bind(null, c)),
          Oe
            ? Ge(function () {
                Mt === 0 && ns();
              })
            : E0(w0, ns),
          (v = null);
      else {
        switch (BS(S)) {
          case 1:
            v = w0;
            break;
          case 4:
            v = CD;
            break;
          case 16:
            v = T0;
            break;
          case 536870912:
            v = bD;
            break;
          default:
            v = T0;
        }
        v = iE(v, JM.bind(null, c));
      }
      (c.callbackPriority = f), (c.callbackNode = v);
    }
  }
  function JM(c, f) {
    if (((Fd = -1), (Nd = 0), Mt & 6)) throw Error(o(327));
    var v = c.callbackNode;
    if (pa() && c.callbackNode !== v) return null;
    var S = qh(c, c === Mn ? Xn : 0);
    if (S === 0) return null;
    if (S & 30 || S & c.expiredLanes || f) f = Od(c, S);
    else {
      f = S;
      var w = Mt;
      Mt |= 2;
      var C = qM();
      (Mn !== c || Xn !== f) && (Bl(), ha(c, f));
      do
        try {
          $D();
          break;
        } catch (Z) {
          QM(c, Z);
        }
      while (1);
      R0(),
        (Pd.current = C),
        (Mt = w),
        En !== null ? (f = 0) : ((Mn = null), (Xn = 0), (f = Pn));
    }
    if (f !== 0) {
      if (
        (f === 2 && ((w = A0(c)), w !== 0 && ((S = w), (f = vv(c, w)))),
        f === 1)
      )
        throw ((v = Ru), ha(c, 0), co(c, S), Mi(c, Nn()), v);
      if (f === 6) co(c, S);
      else {
        if (
          ((w = c.current.alternate),
          !(S & 30) &&
            !qD(w) &&
            ((f = Od(c, S)),
            f === 2 && ((C = A0(c)), C !== 0 && ((S = C), (f = vv(c, C)))),
            f === 1))
        )
          throw ((v = Ru), ha(c, 0), co(c, S), Mi(c, Nn()), v);
        switch (((c.finishedWork = w), (c.finishedLanes = S), f)) {
          case 0:
          case 1:
            throw Error(o(345));
          case 2:
            da(c, Si);
            break;
          case 3:
            if (
              (co(c, S),
              (S & 130023424) === S && ((f = dv + 500 - Nn()), 10 < f))
            ) {
              if (qh(c, 0) !== 0) break;
              if (((w = c.suspendedLanes), (w & S) !== S)) {
                hi(), (c.pingedLanes |= c.suspendedLanes & w);
                break;
              }
              c.timeoutHandle = Le(da.bind(null, c, Si), f);
              break;
            }
            da(c, Si);
            break;
          case 4:
            if ((co(c, S), (S & 4194240) === S)) break;
            for (f = c.eventTimes, w = -1; 0 < S; ) {
              var O = 31 - br(S);
              (C = 1 << O), (O = f[O]), O > w && (w = O), (S &= ~C);
            }
            if (
              ((S = w),
              (S = Nn() - S),
              (S =
                (120 > S
                  ? 120
                  : 480 > S
                  ? 480
                  : 1080 > S
                  ? 1080
                  : 1920 > S
                  ? 1920
                  : 3e3 > S
                  ? 3e3
                  : 4320 > S
                  ? 4320
                  : 1960 * QD(S / 1960)) - S),
              10 < S)
            ) {
              c.timeoutHandle = Le(da.bind(null, c, Si), S);
              break;
            }
            da(c, Si);
            break;
          case 5:
            da(c, Si);
            break;
          default:
            throw Error(o(329));
        }
      }
    }
    return Mi(c, Nn()), c.callbackNode === v ? JM.bind(null, c) : null;
  }
  function vv(c, f) {
    var v = Pu;
    return (
      c.current.memoizedState.isDehydrated && (ha(c, f).flags |= 256),
      (c = Od(c, f)),
      c !== 2 && ((f = Si), (Si = v), f !== null && yv(f)),
      c
    );
  }
  function yv(c) {
    Si === null ? (Si = c) : Si.push.apply(Si, c);
  }
  function qD(c) {
    for (var f = c; ; ) {
      if (f.flags & 16384) {
        var v = f.updateQueue;
        if (v !== null && ((v = v.stores), v !== null))
          for (var S = 0; S < v.length; S++) {
            var w = v[S],
              C = w.getSnapshot;
            w = w.value;
            try {
              if (!ts(C(), w)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((v = f.child), f.subtreeFlags & 16384 && v !== null))
        (v.return = f), (f = v);
      else {
        if (f === c) break;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === c) return !0;
          f = f.return;
        }
        (f.sibling.return = f.return), (f = f.sibling);
      }
    }
    return !0;
  }
  function co(c, f) {
    for (
      f &= ~hv,
        f &= ~Bd,
        c.suspendedLanes |= f,
        c.pingedLanes &= ~f,
        c = c.expirationTimes;
      0 < f;

    ) {
      var v = 31 - br(f),
        S = 1 << v;
      (c[v] = -1), (f &= ~S);
    }
  }
  function KM(c) {
    if (Mt & 6) throw Error(o(327));
    pa();
    var f = qh(c, 0);
    if (!(f & 1)) return Mi(c, Nn()), null;
    var v = Od(c, f);
    if (c.tag !== 0 && v === 2) {
      var S = A0(c);
      S !== 0 && ((f = S), (v = vv(c, S)));
    }
    if (v === 1) throw ((v = Ru), ha(c, 0), co(c, f), Mi(c, Nn()), v);
    if (v === 6) throw Error(o(345));
    return (
      (c.finishedWork = c.current.alternate),
      (c.finishedLanes = f),
      da(c, Si),
      Mi(c, Nn()),
      null
    );
  }
  function YM(c) {
    ao !== null && ao.tag === 0 && !(Mt & 6) && pa();
    var f = Mt;
    Mt |= 1;
    var v = yn.transition,
      S = Lt;
    try {
      if (((yn.transition = null), (Lt = 1), c)) return c();
    } finally {
      (Lt = S), (yn.transition = v), (Mt = f), !(Mt & 6) && ns();
    }
  }
  function xv() {
    (zi = Rl.current), Nt(Rl);
  }
  function ha(c, f) {
    (c.finishedWork = null), (c.finishedLanes = 0);
    var v = c.timeoutHandle;
    if ((v !== ct && ((c.timeoutHandle = ct), Ve(v)), En !== null))
      for (v = En.return; v !== null; ) {
        var S = v;
        switch ((N0(S), S.tag)) {
          case 1:
            (S = S.type.childContextTypes), S != null && io();
            break;
          case 3:
            Cl(), Nt(Sn), Nt(Rn), V0();
            break;
          case 5:
            z0(S);
            break;
          case 4:
            Cl();
            break;
          case 13:
            Nt(tn);
            break;
          case 19:
            Nt(tn);
            break;
          case 10:
            P0(S.type._context);
            break;
          case 22:
          case 23:
            xv();
        }
        v = v.return;
      }
    if (
      ((Mn = c),
      (En = c = uo(c.current, null)),
      (Xn = zi = f),
      (Pn = 0),
      (Ru = null),
      (hv = Bd = Pl = 0),
      (Si = Pu = null),
      is !== null)
    ) {
      for (f = 0; f < is.length; f++)
        if (((v = is[f]), (S = v.interleaved), S !== null)) {
          v.interleaved = null;
          var w = S.next,
            C = v.pending;
          if (C !== null) {
            var O = C.next;
            (C.next = w), (S.next = O);
          }
          v.pending = S;
        }
      is = null;
    }
    return c;
  }
  function QM(c, f) {
    do {
      var v = En;
      try {
        if ((R0(), (ud.current = gd), fd)) {
          for (var S = dn.memoizedState; S !== null; ) {
            var w = S.queue;
            w !== null && (w.pending = null), (S = S.next);
          }
          fd = !1;
        }
        if (
          ((bl = 0),
          (Un = $n = dn = null),
          (_u = !1),
          (Au = 0),
          (fv.current = null),
          v === null || v.return === null)
        ) {
          (Pn = 1), (Ru = f), (En = null);
          break;
        }
        e: {
          var C = c,
            O = v.return,
            Z = v,
            ue = f;
          if (
            ((f = Xn),
            (Z.flags |= 32768),
            ue !== null &&
              typeof ue == "object" &&
              typeof ue.then == "function")
          ) {
            var Re = ue,
              Je = Z,
              ht = Je.tag;
            if (!(Je.mode & 1) && (ht === 0 || ht === 11 || ht === 15)) {
              var et = Je.alternate;
              et
                ? ((Je.updateQueue = et.updateQueue),
                  (Je.memoizedState = et.memoizedState),
                  (Je.lanes = et.lanes))
                : ((Je.updateQueue = null), (Je.memoizedState = null));
            }
            var Gt = vM(O);
            if (Gt !== null) {
              (Gt.flags &= -257),
                yM(Gt, O, Z, C, f),
                Gt.mode & 1 && gM(C, Re, f),
                (f = Gt),
                (ue = Re);
              var qe = f.updateQueue;
              if (qe === null) {
                var ni = new Set();
                ni.add(ue), (f.updateQueue = ni);
              } else qe.add(ue);
              break e;
            } else {
              if (!(f & 1)) {
                gM(C, Re, f), _v();
                break e;
              }
              ue = Error(o(426));
            }
          } else if (qt && Z.mode & 1) {
            var fr = vM(O);
            if (fr !== null) {
              !(fr.flags & 65536) && (fr.flags |= 256),
                yM(fr, O, Z, C, f),
                k0(ue);
              break e;
            }
          }
          (C = ue),
            Pn !== 4 && (Pn = 2),
            Pu === null ? (Pu = [C]) : Pu.push(C),
            (ue = Q0(ue, Z)),
            (Z = O);
          do {
            switch (Z.tag) {
              case 3:
                (Z.flags |= 65536), (f &= -f), (Z.lanes |= f);
                var re = pM(Z, ue, f);
                NS(Z, re);
                break e;
              case 1:
                C = ue;
                var te = Z.type,
                  le = Z.stateNode;
                if (
                  !(Z.flags & 128) &&
                  (typeof te.getDerivedStateFromError == "function" ||
                    (le !== null &&
                      typeof le.componentDidCatch == "function" &&
                      (oo === null || !oo.has(le))))
                ) {
                  (Z.flags |= 65536), (f &= -f), (Z.lanes |= f);
                  var ze = mM(Z, C, f);
                  NS(Z, ze);
                  break e;
                }
            }
            Z = Z.return;
          } while (Z !== null);
        }
        $M(v);
      } catch (Qe) {
        (f = Qe), En === v && v !== null && (En = v = v.return);
        continue;
      }
      break;
    } while (1);
  }
  function qM() {
    var c = Pd.current;
    return (Pd.current = gd), c === null ? gd : c;
  }
  function _v() {
    (Pn === 0 || Pn === 3 || Pn === 2) && (Pn = 4),
      Mn === null || (!(Pl & 268435455) && !(Bd & 268435455)) || co(Mn, Xn);
  }
  function Od(c, f) {
    var v = Mt;
    Mt |= 2;
    var S = qM();
    (Mn === c && Xn === f) || ha(c, f);
    do
      try {
        ZD();
        break;
      } catch (w) {
        QM(c, w);
      }
    while (1);
    if ((R0(), (Mt = v), (Pd.current = S), En !== null)) throw Error(o(261));
    return (Mn = null), (Xn = 0), Pn;
  }
  function ZD() {
    for (; En !== null; ) ZM(En);
  }
  function $D() {
    for (; En !== null && !wD(); ) ZM(En);
  }
  function ZM(c) {
    var f = nE(c.alternate, c, zi);
    (c.memoizedProps = c.pendingProps),
      f === null ? $M(c) : (En = f),
      (fv.current = null);
  }
  function $M(c) {
    var f = c;
    do {
      var v = f.alternate;
      if (((c = f.return), f.flags & 32768)) {
        if (((v = jD(v, f)), v !== null)) {
          (v.flags &= 32767), (En = v);
          return;
        }
        if (c !== null)
          (c.flags |= 32768), (c.subtreeFlags = 0), (c.deletions = null);
        else {
          (Pn = 6), (En = null);
          return;
        }
      } else if (((v = GD(v, f, zi)), v !== null)) {
        En = v;
        return;
      }
      if (((f = f.sibling), f !== null)) {
        En = f;
        return;
      }
      En = f = c;
    } while (f !== null);
    Pn === 0 && (Pn = 5);
  }
  function da(c, f) {
    var v = Lt,
      S = yn.transition;
    try {
      (yn.transition = null), (Lt = 1), e3(c, f, v);
    } finally {
      (yn.transition = S), (Lt = v);
    }
    return null;
  }
  function e3(c, f, v) {
    do pa();
    while (ao !== null);
    if (Mt & 6) throw Error(o(327));
    var S = c.finishedWork,
      w = c.finishedLanes;
    if (S === null) return null;
    if (((c.finishedWork = null), (c.finishedLanes = 0), S === c.current))
      throw Error(o(177));
    (c.callbackNode = null), (c.callbackPriority = 0);
    var C = S.lanes | S.childLanes;
    if (
      (ED(c, C),
      c === Mn && ((En = Mn = null), (Xn = 0)),
      (!(S.subtreeFlags & 2064) && !(S.flags & 2064)) ||
        Id ||
        ((Id = !0),
        iE(T0, function () {
          return pa(), null;
        })),
      (C = (S.flags & 15990) !== 0),
      S.subtreeFlags & 15990 || C)
    ) {
      (C = yn.transition), (yn.transition = null);
      var O = Lt;
      Lt = 1;
      var Z = Mt;
      (Mt |= 4),
        (fv.current = null),
        JD(c, S),
        KD(c, S),
        k(c.containerInfo),
        (c.current = S),
        YD(S),
        TD(),
        (Mt = Z),
        (Lt = O),
        (yn.transition = C);
    } else c.current = S;
    if (
      (Id && ((Id = !1), (ao = c), (Dd = w)),
      (C = c.pendingLanes),
      C === 0 && (oo = null),
      RD(S.stateNode),
      Mi(c, Nn()),
      f !== null)
    )
      for (v = c.onRecoverableError, S = 0; S < f.length; S++) v(f[S]);
    if (Ld) throw ((Ld = !1), (c = mv), (mv = null), c);
    return (
      Dd & 1 && c.tag !== 0 && pa(),
      (C = c.pendingLanes),
      C & 1 ? (c === gv ? Bu++ : ((Bu = 0), (gv = c))) : (Bu = 0),
      ns(),
      null
    );
  }
  function pa() {
    if (ao !== null) {
      var c = BS(Dd),
        f = yn.transition,
        v = Lt;
      try {
        if (((yn.transition = null), (Lt = 16 > c ? 16 : c), ao === null))
          var S = !1;
        else {
          if (((c = ao), (ao = null), (Dd = 0), Mt & 6)) throw Error(o(331));
          var w = Mt;
          for (Mt |= 4, ke = c.current; ke !== null; ) {
            var C = ke,
              O = C.child;
            if (ke.flags & 16) {
              var Z = C.deletions;
              if (Z !== null) {
                for (var ue = 0; ue < Z.length; ue++) {
                  var Re = Z[ue];
                  for (ke = Re; ke !== null; ) {
                    var Je = ke;
                    switch (Je.tag) {
                      case 0:
                      case 11:
                      case 15:
                        fa(8, Je, C);
                    }
                    var ht = Je.child;
                    if (ht !== null) (ht.return = Je), (ke = ht);
                    else
                      for (; ke !== null; ) {
                        Je = ke;
                        var et = Je.sibling,
                          Gt = Je.return;
                        if ((UM(Je), Je === Re)) {
                          ke = null;
                          break;
                        }
                        if (et !== null) {
                          (et.return = Gt), (ke = et);
                          break;
                        }
                        ke = Gt;
                      }
                  }
                }
                var qe = C.alternate;
                if (qe !== null) {
                  var ni = qe.child;
                  if (ni !== null) {
                    qe.child = null;
                    do {
                      var fr = ni.sibling;
                      (ni.sibling = null), (ni = fr);
                    } while (ni !== null);
                  }
                }
                ke = C;
              }
            }
            if (C.subtreeFlags & 2064 && O !== null) (O.return = C), (ke = O);
            else
              e: for (; ke !== null; ) {
                if (((C = ke), C.flags & 2048))
                  switch (C.tag) {
                    case 0:
                    case 11:
                    case 15:
                      fa(9, C, C.return);
                  }
                var re = C.sibling;
                if (re !== null) {
                  (re.return = C.return), (ke = re);
                  break e;
                }
                ke = C.return;
              }
          }
          var te = c.current;
          for (ke = te; ke !== null; ) {
            O = ke;
            var le = O.child;
            if (O.subtreeFlags & 2064 && le !== null)
              (le.return = O), (ke = le);
            else
              e: for (O = te; ke !== null; ) {
                if (((Z = ke), Z.flags & 2048))
                  try {
                    switch (Z.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Cu(9, Z);
                    }
                  } catch (Qe) {
                    Ei(Z, Z.return, Qe);
                  }
                if (Z === O) {
                  ke = null;
                  break e;
                }
                var ze = Z.sibling;
                if (ze !== null) {
                  (ze.return = Z.return), (ke = ze);
                  break e;
                }
                ke = Z.return;
              }
          }
          if (
            ((Mt = w),
            ns(),
            es && typeof es.onPostCommitFiberRoot == "function")
          )
            try {
              es.onPostCommitFiberRoot(Zh, c);
            } catch {}
          S = !0;
        }
        return S;
      } finally {
        (Lt = v), (yn.transition = f);
      }
    }
    return !1;
  }
  function eE(c, f, v) {
    (f = Q0(v, f)),
      (f = pM(c, f, 1)),
      so(c, f),
      (f = hi()),
      (c = Ud(c, 1)),
      c !== null && (pu(c, 1, f), Mi(c, f));
  }
  function Ei(c, f, v) {
    if (c.tag === 3) eE(c, c, v);
    else
      for (; f !== null; ) {
        if (f.tag === 3) {
          eE(f, c, v);
          break;
        } else if (f.tag === 1) {
          var S = f.stateNode;
          if (
            typeof f.type.getDerivedStateFromError == "function" ||
            (typeof S.componentDidCatch == "function" &&
              (oo === null || !oo.has(S)))
          ) {
            (c = Q0(v, c)),
              (c = mM(f, c, 1)),
              so(f, c),
              (c = hi()),
              (f = Ud(f, 1)),
              f !== null && (pu(f, 1, c), Mi(f, c));
            break;
          }
        }
        f = f.return;
      }
  }
  function t3(c, f, v) {
    var S = c.pingCache;
    S !== null && S.delete(f),
      (f = hi()),
      (c.pingedLanes |= c.suspendedLanes & v),
      Mn === c &&
        (Xn & v) === v &&
        (Pn === 4 || (Pn === 3 && (Xn & 130023424) === Xn && 500 > Nn() - dv)
          ? ha(c, 0)
          : (hv |= v)),
      Mi(c, f);
  }
  function tE(c, f) {
    f === 0 &&
      (c.mode & 1
        ? ((f = Qh), (Qh <<= 1), !(Qh & 130023424) && (Qh = 4194304))
        : (f = 1));
    var v = hi();
    (c = Ud(c, f)), c !== null && (pu(c, f, v), Mi(c, v));
  }
  function n3(c) {
    var f = c.memoizedState,
      v = 0;
    f !== null && (v = f.retryLane), tE(c, v);
  }
  function i3(c, f) {
    var v = 0;
    switch (c.tag) {
      case 13:
        var S = c.stateNode,
          w = c.memoizedState;
        w !== null && (v = w.retryLane);
        break;
      case 19:
        S = c.stateNode;
        break;
      default:
        throw Error(o(314));
    }
    S !== null && S.delete(f), tE(c, v);
  }
  var nE;
  nE = function (c, f, v) {
    if (c !== null)
      if (c.memoizedProps !== f.pendingProps || Sn.current) Hi = !0;
      else {
        if (!(c.lanes & v) && !(f.flags & 128)) return (Hi = !1), WD(c, f, v);
        Hi = !!(c.flags & 131072);
      }
    else (Hi = !1), qt && f.flags & 1048576 && GS(f, ad, f.index);
    switch (((f.lanes = 0), f.tag)) {
      case 2:
        var S = f.type;
        c !== null &&
          ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
          (c = f.pendingProps);
        var w = fn(f, Rn.current);
        Al(f, v), (w = j0(null, f, S, c, w, v));
        var C = X0();
        return (
          (f.flags |= 1),
          typeof w == "object" &&
          w !== null &&
          typeof w.render == "function" &&
          w.$$typeof === void 0
            ? ((f.tag = 1),
              (f.memoizedState = null),
              (f.updateQueue = null),
              hn(S) ? ((C = !0), xl(f)) : (C = !1),
              (f.memoizedState =
                w.state !== null && w.state !== void 0 ? w.state : null),
              L0(f),
              (w.updater = sd),
              (f.stateNode = w),
              (w._reactInternals = f),
              D0(f, S, c, v),
              (f = $0(null, f, S, !0, C, v)))
            : ((f.tag = 0), qt && C && F0(f), fi(null, f, w, v), (f = f.child)),
          f
        );
      case 16:
        S = f.elementType;
        e: {
          switch (
            (c !== null &&
              ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
            (c = f.pendingProps),
            (w = S._init),
            (S = w(S._payload)),
            (f.type = S),
            (w = f.tag = s3(S)),
            (c = Rr(S, c)),
            w)
          ) {
            case 0:
              f = Z0(null, f, S, c, v);
              break e;
            case 1:
              f = TM(null, f, S, c, v);
              break e;
            case 11:
              f = AM(null, f, S, c, v);
              break e;
            case 14:
              f = SM(null, f, S, Rr(S.type, c), v);
              break e;
          }
          throw Error(o(306, S, ""));
        }
        return f;
      case 0:
        return (
          (S = f.type),
          (w = f.pendingProps),
          (w = f.elementType === S ? w : Rr(S, w)),
          Z0(c, f, S, w, v)
        );
      case 1:
        return (
          (S = f.type),
          (w = f.pendingProps),
          (w = f.elementType === S ? w : Rr(S, w)),
          TM(c, f, S, w, v)
        );
      case 3:
        e: {
          if ((CM(f), c === null)) throw Error(o(387));
          (S = f.pendingProps),
            (C = f.memoizedState),
            (w = C.element),
            FS(c, f),
            rd(f, S, null, v);
          var O = f.memoizedState;
          if (((S = O.element), ye && C.isDehydrated))
            if (
              ((C = {
                element: S,
                isDehydrated: !1,
                cache: O.cache,
                transitions: O.transitions,
              }),
              (f.updateQueue.baseState = C),
              (f.memoizedState = C),
              f.flags & 256)
            ) {
              (w = Error(o(423))), (f = bM(c, f, S, v, w));
              break e;
            } else if (S !== w) {
              (w = Error(o(424))), (f = bM(c, f, S, v, w));
              break e;
            } else
              for (
                ye &&
                  ((ki = y0(f.stateNode.containerInfo)),
                  (Oi = f),
                  (qt = !0),
                  (Pr = null),
                  (mu = !1)),
                  v = KS(f, null, S, v),
                  f.child = v;
                v;

              )
                (v.flags = (v.flags & -3) | 4096), (v = v.sibling);
          else {
            if ((El(), S === w)) {
              f = Rs(c, f, v);
              break e;
            }
            fi(c, f, S, v);
          }
          f = f.child;
        }
        return f;
      case 5:
        return (
          YS(f),
          c === null && O0(f),
          (S = f.type),
          (w = f.pendingProps),
          (C = c !== null ? c.memoizedProps : null),
          (O = w.children),
          xe(S, w) ? (O = null) : C !== null && xe(S, C) && (f.flags |= 32),
          wM(c, f),
          fi(c, f, O, v),
          f.child
        );
      case 6:
        return c === null && O0(f), null;
      case 13:
        return RM(c, f, v);
      case 4:
        return (
          H0(f, f.stateNode.containerInfo),
          (S = f.pendingProps),
          c === null ? (f.child = wl(f, null, S, v)) : fi(c, f, S, v),
          f.child
        );
      case 11:
        return (
          (S = f.type),
          (w = f.pendingProps),
          (w = f.elementType === S ? w : Rr(S, w)),
          AM(c, f, S, w, v)
        );
      case 7:
        return fi(c, f, f.pendingProps, v), f.child;
      case 8:
        return fi(c, f, f.pendingProps.children, v), f.child;
      case 12:
        return fi(c, f, f.pendingProps.children, v), f.child;
      case 10:
        e: {
          if (
            ((S = f.type._context),
            (w = f.pendingProps),
            (C = f.memoizedProps),
            (O = w.value),
            DS(f, S, O),
            C !== null)
          )
            if (ts(C.value, O)) {
              if (C.children === w.children && !Sn.current) {
                f = Rs(c, f, v);
                break e;
              }
            } else
              for (C = f.child, C !== null && (C.return = f); C !== null; ) {
                var Z = C.dependencies;
                if (Z !== null) {
                  O = C.child;
                  for (var ue = Z.firstContext; ue !== null; ) {
                    if (ue.context === S) {
                      if (C.tag === 1) {
                        (ue = ws(-1, v & -v)), (ue.tag = 2);
                        var Re = C.updateQueue;
                        if (Re !== null) {
                          Re = Re.shared;
                          var Je = Re.pending;
                          Je === null
                            ? (ue.next = ue)
                            : ((ue.next = Je.next), (Je.next = ue)),
                            (Re.pending = ue);
                        }
                      }
                      (C.lanes |= v),
                        (ue = C.alternate),
                        ue !== null && (ue.lanes |= v),
                        B0(C.return, v, f),
                        (Z.lanes |= v);
                      break;
                    }
                    ue = ue.next;
                  }
                } else if (C.tag === 10) O = C.type === f.type ? null : C.child;
                else if (C.tag === 18) {
                  if (((O = C.return), O === null)) throw Error(o(341));
                  (O.lanes |= v),
                    (Z = O.alternate),
                    Z !== null && (Z.lanes |= v),
                    B0(O, v, f),
                    (O = C.sibling);
                } else O = C.child;
                if (O !== null) O.return = C;
                else
                  for (O = C; O !== null; ) {
                    if (O === f) {
                      O = null;
                      break;
                    }
                    if (((C = O.sibling), C !== null)) {
                      (C.return = O.return), (O = C);
                      break;
                    }
                    O = O.return;
                  }
                C = O;
              }
          fi(c, f, w.children, v), (f = f.child);
        }
        return f;
      case 9:
        return (
          (w = f.type),
          (S = f.pendingProps.children),
          Al(f, v),
          (w = rr(w)),
          (S = S(w)),
          (f.flags |= 1),
          fi(c, f, S, v),
          f.child
        );
      case 14:
        return (
          (S = f.type),
          (w = Rr(S, f.pendingProps)),
          (w = Rr(S.type, w)),
          SM(c, f, S, w, v)
        );
      case 15:
        return MM(c, f, f.type, f.pendingProps, v);
      case 17:
        return (
          (S = f.type),
          (w = f.pendingProps),
          (w = f.elementType === S ? w : Rr(S, w)),
          c !== null &&
            ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
          (f.tag = 1),
          hn(S) ? ((c = !0), xl(f)) : (c = !1),
          Al(f, v),
          HS(f, S, w),
          D0(f, S, w, v),
          $0(null, f, S, !0, c, v)
        );
      case 19:
        return IM(c, f, v);
      case 22:
        return EM(c, f, v);
    }
    throw Error(o(156, f.tag));
  };
  function iE(c, f) {
    return E0(c, f);
  }
  function r3(c, f, v, S) {
    (this.tag = c),
      (this.key = v),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = f),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = S),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function ur(c, f, v, S) {
    return new r3(c, f, v, S);
  }
  function Av(c) {
    return (c = c.prototype), !(!c || !c.isReactComponent);
  }
  function s3(c) {
    if (typeof c == "function") return Av(c) ? 1 : 0;
    if (c != null) {
      if (((c = c.$$typeof), c === M)) return 11;
      if (c === x) return 14;
    }
    return 2;
  }
  function uo(c, f) {
    var v = c.alternate;
    return (
      v === null
        ? ((v = ur(c.tag, f, c.key, c.mode)),
          (v.elementType = c.elementType),
          (v.type = c.type),
          (v.stateNode = c.stateNode),
          (v.alternate = c),
          (c.alternate = v))
        : ((v.pendingProps = f),
          (v.type = c.type),
          (v.flags = 0),
          (v.subtreeFlags = 0),
          (v.deletions = null)),
      (v.flags = c.flags & 14680064),
      (v.childLanes = c.childLanes),
      (v.lanes = c.lanes),
      (v.child = c.child),
      (v.memoizedProps = c.memoizedProps),
      (v.memoizedState = c.memoizedState),
      (v.updateQueue = c.updateQueue),
      (f = c.dependencies),
      (v.dependencies =
        f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }),
      (v.sibling = c.sibling),
      (v.index = c.index),
      (v.ref = c.ref),
      v
    );
  }
  function kd(c, f, v, S, w, C) {
    var O = 2;
    if (((S = c), typeof c == "function")) Av(c) && (O = 1);
    else if (typeof c == "string") O = 5;
    else
      e: switch (c) {
        case h:
          return ma(v.children, w, C, f);
        case d:
          (O = 8), (w |= 8);
          break;
        case p:
          return (
            (c = ur(12, v, f, w | 2)), (c.elementType = p), (c.lanes = C), c
          );
        case A:
          return (c = ur(13, v, f, w)), (c.elementType = A), (c.lanes = C), c;
        case g:
          return (c = ur(19, v, f, w)), (c.elementType = g), (c.lanes = C), c;
        case E:
          return Hd(v, w, C, f);
        default:
          if (typeof c == "object" && c !== null)
            switch (c.$$typeof) {
              case m:
                O = 10;
                break e;
              case y:
                O = 9;
                break e;
              case M:
                O = 11;
                break e;
              case x:
                O = 14;
                break e;
              case _:
                (O = 16), (S = null);
                break e;
            }
          throw Error(o(130, c == null ? c : typeof c, ""));
      }
    return (
      (f = ur(O, v, f, w)), (f.elementType = c), (f.type = S), (f.lanes = C), f
    );
  }
  function ma(c, f, v, S) {
    return (c = ur(7, c, S, f)), (c.lanes = v), c;
  }
  function Hd(c, f, v, S) {
    return (
      (c = ur(22, c, S, f)),
      (c.elementType = E),
      (c.lanes = v),
      (c.stateNode = {}),
      c
    );
  }
  function Sv(c, f, v) {
    return (c = ur(6, c, null, f)), (c.lanes = v), c;
  }
  function Mv(c, f, v) {
    return (
      (f = ur(4, c.children !== null ? c.children : [], c.key, f)),
      (f.lanes = v),
      (f.stateNode = {
        containerInfo: c.containerInfo,
        pendingChildren: null,
        implementation: c.implementation,
      }),
      f
    );
  }
  function o3(c, f, v, S, w) {
    (this.tag = f),
      (this.containerInfo = c),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = ct),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = S0(0)),
      (this.expirationTimes = S0(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = S0(0)),
      (this.identifierPrefix = S),
      (this.onRecoverableError = w),
      ye && (this.mutableSourceEagerHydrationData = null);
  }
  function rE(c, f, v, S, w, C, O, Z, ue) {
    return (
      (c = new o3(c, f, v, Z, ue)),
      f === 1 ? ((f = 1), C === !0 && (f |= 8)) : (f = 0),
      (C = ur(3, null, null, f)),
      (c.current = C),
      (C.stateNode = c),
      (C.memoizedState = {
        element: S,
        isDehydrated: v,
        cache: null,
        transitions: null,
      }),
      L0(C),
      c
    );
  }
  function sE(c) {
    if (!c) return qn;
    c = c._reactInternals;
    e: {
      if (b(c) !== c || c.tag !== 1) throw Error(o(170));
      var f = c;
      do {
        switch (f.tag) {
          case 3:
            f = f.stateNode.context;
            break e;
          case 1:
            if (hn(f.type)) {
              f = f.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        f = f.return;
      } while (f !== null);
      throw Error(o(171));
    }
    if (c.tag === 1) {
      var v = c.type;
      if (hn(v)) return yl(c, v, f);
    }
    return f;
  }
  function oE(c) {
    var f = c._reactInternals;
    if (f === void 0)
      throw typeof c.render == "function"
        ? Error(o(188))
        : ((c = Object.keys(c).join(",")), Error(o(268, c)));
    return (c = $(f)), c === null ? null : c.stateNode;
  }
  function aE(c, f) {
    if (((c = c.memoizedState), c !== null && c.dehydrated !== null)) {
      var v = c.retryLane;
      c.retryLane = v !== 0 && v < f ? v : f;
    }
  }
  function Ev(c, f) {
    aE(c, f), (c = c.alternate) && aE(c, f);
  }
  function a3(c) {
    return (c = $(c)), c === null ? null : c.stateNode;
  }
  function l3() {
    return null;
  }
  return (
    (t.attemptContinuousHydration = function (c) {
      if (c.tag === 13) {
        var f = hi();
        cr(c, 134217728, f), Ev(c, 134217728);
      }
    }),
    (t.attemptHydrationAtCurrentPriority = function (c) {
      if (c.tag === 13) {
        var f = hi(),
          v = lo(c);
        cr(c, v, f), Ev(c, v);
      }
    }),
    (t.attemptSynchronousHydration = function (c) {
      switch (c.tag) {
        case 3:
          var f = c.stateNode;
          if (f.current.memoizedState.isDehydrated) {
            var v = du(f.pendingLanes);
            v !== 0 && (M0(f, v | 1), Mi(f, Nn()), !(Mt & 6) && (Bl(), ns()));
          }
          break;
        case 13:
          var S = hi();
          YM(function () {
            return cr(c, 1, S);
          }),
            Ev(c, 1);
      }
    }),
    (t.batchedUpdates = function (c, f) {
      var v = Mt;
      Mt |= 1;
      try {
        return c(f);
      } finally {
        (Mt = v), Mt === 0 && (Bl(), $h && ns());
      }
    }),
    (t.createComponentSelector = function (c) {
      return { $$typeof: wd, value: c };
    }),
    (t.createContainer = function (c, f, v, S, w, C, O) {
      return rE(c, f, !1, null, v, S, w, C, O);
    }),
    (t.createHasPseudoClassSelector = function (c) {
      return { $$typeof: Td, value: c };
    }),
    (t.createHydrationContainer = function (c, f, v, S, w, C, O, Z, ue) {
      return (
        (c = rE(v, S, !0, c, w, C, O, Z, ue)),
        (c.context = sE(null)),
        (v = c.current),
        (S = hi()),
        (w = lo(v)),
        (C = ws(S, w)),
        (C.callback = f ?? null),
        so(v, C),
        (c.current.lanes = w),
        pu(c, w, S),
        Mi(c, S),
        c
      );
    }),
    (t.createPortal = function (c, f, v) {
      var S =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: u,
        key: S == null ? null : "" + S,
        children: c,
        containerInfo: f,
        implementation: v,
      };
    }),
    (t.createRoleSelector = function (c) {
      return { $$typeof: Cd, value: c };
    }),
    (t.createTestNameSelector = function (c) {
      return { $$typeof: bd, value: c };
    }),
    (t.createTextSelector = function (c) {
      return { $$typeof: Rd, value: c };
    }),
    (t.deferredUpdates = function (c) {
      var f = Lt,
        v = yn.transition;
      try {
        return (yn.transition = null), (Lt = 16), c();
      } finally {
        (Lt = f), (yn.transition = v);
      }
    }),
    (t.discreteUpdates = function (c, f, v, S, w) {
      var C = Lt,
        O = yn.transition;
      try {
        return (yn.transition = null), (Lt = 1), c(f, v, S, w);
      } finally {
        (Lt = C), (yn.transition = O), Mt === 0 && Bl();
      }
    }),
    (t.findAllNodes = uv),
    (t.findBoundingRects = function (c, f) {
      if (!Ze) throw Error(o(363));
      (f = uv(c, f)), (c = []);
      for (var v = 0; v < f.length; v++) c.push(kt(f[v]));
      for (f = c.length - 1; 0 < f; f--) {
        v = c[f];
        for (
          var S = v.x, w = S + v.width, C = v.y, O = C + v.height, Z = f - 1;
          0 <= Z;
          Z--
        )
          if (f !== Z) {
            var ue = c[Z],
              Re = ue.x,
              Je = Re + ue.width,
              ht = ue.y,
              et = ht + ue.height;
            if (S >= Re && C >= ht && w <= Je && O <= et) {
              c.splice(f, 1);
              break;
            } else if (S !== Re || v.width !== ue.width || et < C || ht > O) {
              if (!(C !== ht || v.height !== ue.height || Je < S || Re > w)) {
                Re > S && ((ue.width += Re - S), (ue.x = S)),
                  Je < w && (ue.width = w - Re),
                  c.splice(f, 1);
                break;
              }
            } else {
              ht > C && ((ue.height += ht - C), (ue.y = C)),
                et < O && (ue.height = O - ht),
                c.splice(f, 1);
              break;
            }
          }
      }
      return c;
    }),
    (t.findHostInstance = oE),
    (t.findHostInstanceWithNoPortals = function (c) {
      return (
        (c = z(c)),
        (c = c !== null ? Y(c) : null),
        c === null ? null : c.stateNode
      );
    }),
    (t.findHostInstanceWithWarning = function (c) {
      return oE(c);
    }),
    (t.flushControlled = function (c) {
      var f = Mt;
      Mt |= 1;
      var v = yn.transition,
        S = Lt;
      try {
        (yn.transition = null), (Lt = 1), c();
      } finally {
        (Lt = S), (yn.transition = v), (Mt = f), Mt === 0 && (Bl(), ns());
      }
    }),
    (t.flushPassiveEffects = pa),
    (t.flushSync = YM),
    (t.focusWithin = function (c, f) {
      if (!Ze) throw Error(o(363));
      for (c = av(c), f = XM(c, f), f = Array.from(f), c = 0; c < f.length; ) {
        var v = f[c++];
        if (!D(v)) {
          if (v.tag === 5 && we(v.stateNode)) return !0;
          for (v = v.child; v !== null; ) f.push(v), (v = v.sibling);
        }
      }
      return !1;
    }),
    (t.getCurrentUpdatePriority = function () {
      return Lt;
    }),
    (t.getFindAllNodesFailureDescription = function (c, f) {
      if (!Ze) throw Error(o(363));
      var v = 0,
        S = [];
      c = [av(c), 0];
      for (var w = 0; w < c.length; ) {
        var C = c[w++],
          O = c[w++],
          Z = f[O];
        if (
          (C.tag !== 5 || !D(C)) &&
          (lv(C, Z) && (S.push(cv(Z)), O++, O > v && (v = O)), O < f.length)
        )
          for (C = C.child; C !== null; ) c.push(C, O), (C = C.sibling);
      }
      if (v < f.length) {
        for (c = []; v < f.length; v++) c.push(cv(f[v]));
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (S.join(" > ") +
            `

No matching component was found for:
  `) +
          c.join(" > ")
        );
      }
      return null;
    }),
    (t.getPublicRootInstance = function (c) {
      if (((c = c.current), !c.child)) return null;
      switch (c.child.tag) {
        case 5:
          return ie(c.child.stateNode);
        default:
          return c.child.stateNode;
      }
    }),
    (t.injectIntoDevTools = function (c) {
      if (
        ((c = {
          bundleType: c.bundleType,
          version: c.version,
          rendererPackageName: c.rendererPackageName,
          rendererConfig: c.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: a.ReactCurrentDispatcher,
          findHostInstanceByFiber: a3,
          findFiberByHostInstance: c.findFiberByHostInstance || l3,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        c = !1;
      else {
        var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (f.isDisabled || !f.supportsFiber) c = !0;
        else {
          try {
            (Zh = f.inject(c)), (es = f);
          } catch {}
          c = !!f.checkDCE;
        }
      }
      return c;
    }),
    (t.isAlreadyRendering = function () {
      return !1;
    }),
    (t.observeVisibleRects = function (c, f, v, S) {
      if (!Ze) throw Error(o(363));
      c = uv(c, f);
      var w = Se(c, v, S).disconnect;
      return {
        disconnect: function () {
          w();
        },
      };
    }),
    (t.registerMutableSourceForHydration = function (c, f) {
      var v = f._getVersion;
      (v = v(f._source)),
        c.mutableSourceEagerHydrationData == null
          ? (c.mutableSourceEagerHydrationData = [f, v])
          : c.mutableSourceEagerHydrationData.push(f, v);
    }),
    (t.runWithPriority = function (c, f) {
      var v = Lt;
      try {
        return (Lt = c), f();
      } finally {
        Lt = v;
      }
    }),
    (t.shouldError = function () {
      return null;
    }),
    (t.shouldSuspend = function () {
      return !1;
    }),
    (t.updateContainer = function (c, f, v, S) {
      var w = f.current,
        C = hi(),
        O = lo(w);
      return (
        (v = sE(v)),
        f.context === null ? (f.context = v) : (f.pendingContext = v),
        (f = ws(C, O)),
        (f.payload = { element: c }),
        (S = S === void 0 ? null : S),
        S !== null && (f.callback = S),
        so(w, f),
        (c = cr(w, O, C)),
        c !== null && id(c, w, O),
        O
      );
    }),
    t
  );
};
oL.exports = KV;
var YV = oL.exports;
const QV = hg(YV);
var aL = { exports: {} },
  lL = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(I, G) {
    var k = I.length;
    I.push(G);
    e: for (; 0 < k; ) {
      var U = (k - 1) >>> 1,
        j = I[U];
      if (0 < r(j, G)) (I[U] = G), (I[k] = j), (k = U);
      else break e;
    }
  }
  function t(I) {
    return I.length === 0 ? null : I[0];
  }
  function i(I) {
    if (I.length === 0) return null;
    var G = I[0],
      k = I.pop();
    if (k !== G) {
      I[0] = k;
      e: for (var U = 0, j = I.length, he = j >>> 1; U < he; ) {
        var ae = 2 * (U + 1) - 1,
          xe = I[ae],
          Ae = ae + 1,
          Le = I[Ae];
        if (0 > r(xe, k))
          Ae < j && 0 > r(Le, xe)
            ? ((I[U] = Le), (I[Ae] = k), (U = Ae))
            : ((I[U] = xe), (I[ae] = k), (U = ae));
        else if (Ae < j && 0 > r(Le, k)) (I[U] = Le), (I[Ae] = k), (U = Ae);
        else break e;
      }
    }
    return G;
  }
  function r(I, G) {
    var k = I.sortIndex - G.sortIndex;
    return k !== 0 ? k : I.id - G.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    u = [],
    h = 1,
    d = null,
    p = 3,
    m = !1,
    y = !1,
    M = !1,
    A = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    x = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function _(I) {
    for (var G = t(u); G !== null; ) {
      if (G.callback === null) i(u);
      else if (G.startTime <= I)
        i(u), (G.sortIndex = G.expirationTime), e(l, G);
      else break;
      G = t(u);
    }
  }
  function E(I) {
    if (((M = !1), _(I), !y))
      if (t(l) !== null) (y = !0), ie(T);
      else {
        var G = t(u);
        G !== null && ee(E, G.startTime - I);
      }
  }
  function T(I, G) {
    (y = !1), M && ((M = !1), g(B), (B = -1)), (m = !0);
    var k = p;
    try {
      for (
        _(G), d = t(l);
        d !== null && (!(d.expirationTime > G) || (I && !z()));

      ) {
        var U = d.callback;
        if (typeof U == "function") {
          (d.callback = null), (p = d.priorityLevel);
          var j = U(d.expirationTime <= G);
          (G = n.unstable_now()),
            typeof j == "function" ? (d.callback = j) : d === t(l) && i(l),
            _(G);
        } else i(l);
        d = t(l);
      }
      if (d !== null) var he = !0;
      else {
        var ae = t(u);
        ae !== null && ee(E, ae.startTime - G), (he = !1);
      }
      return he;
    } finally {
      (d = null), (p = k), (m = !1);
    }
  }
  var R = !1,
    P = null,
    B = -1,
    b = 5,
    L = -1;
  function z() {
    return !(n.unstable_now() - L < b);
  }
  function $() {
    if (P !== null) {
      var I = n.unstable_now();
      L = I;
      var G = !0;
      try {
        G = P(!0, I);
      } finally {
        G ? X() : ((R = !1), (P = null));
      }
    } else R = !1;
  }
  var X;
  if (typeof x == "function")
    X = function () {
      x($);
    };
  else if (typeof MessageChannel < "u") {
    var Y = new MessageChannel(),
      K = Y.port2;
    (Y.port1.onmessage = $),
      (X = function () {
        K.postMessage(null);
      });
  } else
    X = function () {
      A($, 0);
    };
  function ie(I) {
    (P = I), R || ((R = !0), X());
  }
  function ee(I, G) {
    B = A(function () {
      I(n.unstable_now());
    }, G);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (I) {
      I.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      y || m || ((y = !0), ie(T));
    }),
    (n.unstable_forceFrameRate = function (I) {
      0 > I || 125 < I
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (b = 0 < I ? Math.floor(1e3 / I) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (I) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var G = 3;
          break;
        default:
          G = p;
      }
      var k = p;
      p = G;
      try {
        return I();
      } finally {
        p = k;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (I, G) {
      switch (I) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          I = 3;
      }
      var k = p;
      p = I;
      try {
        return G();
      } finally {
        p = k;
      }
    }),
    (n.unstable_scheduleCallback = function (I, G, k) {
      var U = n.unstable_now();
      switch (
        (typeof k == "object" && k !== null
          ? ((k = k.delay), (k = typeof k == "number" && 0 < k ? U + k : U))
          : (k = U),
        I)
      ) {
        case 1:
          var j = -1;
          break;
        case 2:
          j = 250;
          break;
        case 5:
          j = 1073741823;
          break;
        case 4:
          j = 1e4;
          break;
        default:
          j = 5e3;
      }
      return (
        (j = k + j),
        (I = {
          id: h++,
          callback: G,
          priorityLevel: I,
          startTime: k,
          expirationTime: j,
          sortIndex: -1,
        }),
        k > U
          ? ((I.sortIndex = k),
            e(u, I),
            t(l) === null &&
              I === t(u) &&
              (M ? (g(B), (B = -1)) : (M = !0), ee(E, k - U)))
          : ((I.sortIndex = j), e(l, I), y || m || ((y = !0), ie(T))),
        I
      );
    }),
    (n.unstable_shouldYield = z),
    (n.unstable_wrapCallback = function (I) {
      var G = p;
      return function () {
        var k = p;
        p = G;
        try {
          return I.apply(this, arguments);
        } finally {
          p = k;
        }
      };
    });
})(lL);
aL.exports = lL;
var $T = aL.exports;
const qV = (n) => typeof n == "object" && typeof n.then == "function",
  ja = [];
function cL(n, e, t = (i, r) => i === r) {
  if (n === e) return !0;
  if (!n || !e) return !1;
  const i = n.length;
  if (e.length !== i) return !1;
  for (let r = 0; r < i; r++) if (!t(n[r], e[r])) return !1;
  return !0;
}
function uL(n, e = null, t = !1, i = {}) {
  e === null && (e = [n]);
  for (const s of ja)
    if (cL(e, s.keys, s.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
      if (Object.prototype.hasOwnProperty.call(s, "response"))
        return (
          i.lifespan &&
            i.lifespan > 0 &&
            (s.timeout && clearTimeout(s.timeout),
            (s.timeout = setTimeout(s.remove, i.lifespan))),
          s.response
        );
      if (!t) throw s.promise;
    }
  const r = {
    keys: e,
    equal: i.equal,
    remove: () => {
      const s = ja.indexOf(r);
      s !== -1 && ja.splice(s, 1);
    },
    promise: (qV(n) ? n : n(...e))
      .then((s) => {
        (r.response = s),
          i.lifespan &&
            i.lifespan > 0 &&
            (r.timeout = setTimeout(r.remove, i.lifespan));
      })
      .catch((s) => (r.error = s)),
  };
  if ((ja.push(r), !t)) throw r.promise;
}
const ZV = (n, e, t) => uL(n, e, !1, t),
  $V = (n, e, t) => void uL(n, e, !0, t),
  e5 = (n) => {
    if (n === void 0 || n.length === 0) ja.splice(0, ja.length);
    else {
      const e = ja.find((t) => cL(n, t.keys, t.equal));
      e && e.remove();
    }
  },
  rS = {},
  t5 = (n) => void Object.assign(rS, n);
function n5(n, e) {
  function t(h, { args: d = [], attach: p, ...m }, y) {
    let M = `${h[0].toUpperCase()}${h.slice(1)}`,
      A;
    if (h === "primitive") {
      if (m.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const g = m.object;
      A = ic(g, { type: h, root: y, attach: p, primitive: !0 });
    } else {
      const g = rS[M];
      if (!g)
        throw new Error(
          `R3F: ${M} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(d))
        throw new Error("R3F: The args prop must be an array!");
      A = ic(new g(...d), {
        type: h,
        root: y,
        attach: p,
        memoizedProps: { args: d },
      });
    }
    return (
      A.__r3f.attach === void 0 &&
        (A instanceof gt
          ? (A.__r3f.attach = "geometry")
          : A instanceof bn && (A.__r3f.attach = "material")),
      M !== "inject" && Fy(A, m),
      A
    );
  }
  function i(h, d) {
    let p = !1;
    if (d) {
      var m, y;
      (m = d.__r3f) != null && m.attach
        ? Dy(h, d, d.__r3f.attach)
        : d.isObject3D && h.isObject3D && (h.add(d), (p = !0)),
        p || (y = h.__r3f) == null || y.objects.push(d),
        d.__r3f || ic(d, {}),
        (d.__r3f.parent = h),
        V_(d),
        rc(d);
    }
  }
  function r(h, d, p) {
    let m = !1;
    if (d) {
      var y, M;
      if ((y = d.__r3f) != null && y.attach) Dy(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        (d.parent = h), d.dispatchEvent({ type: "added" });
        const A = h.children.filter((x) => x !== d),
          g = A.indexOf(p);
        (h.children = [...A.slice(0, g), d, ...A.slice(g)]), (m = !0);
      }
      m || (M = h.__r3f) == null || M.objects.push(d),
        d.__r3f || ic(d, {}),
        (d.__r3f.parent = h),
        V_(d),
        rc(d);
    }
  }
  function s(h, d, p = !1) {
    h && [...h].forEach((m) => o(d, m, p));
  }
  function o(h, d, p) {
    if (d) {
      var m, y, M;
      if (
        (d.__r3f && (d.__r3f.parent = null),
        (m = h.__r3f) != null &&
          m.objects &&
          (h.__r3f.objects = h.__r3f.objects.filter((E) => E !== d)),
        (y = d.__r3f) != null && y.attach)
      )
        rC(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        var A;
        h.remove(d), (A = d.__r3f) != null && A.root && u5(d.__r3f.root, d);
      }
      const x = (M = d.__r3f) == null ? void 0 : M.primitive,
        _ = p === void 0 ? d.dispose !== null && !x : p;
      if (!x) {
        var g;
        s((g = d.__r3f) == null ? void 0 : g.objects, d, _),
          s(d.children, d, _);
      }
      delete d.__r3f,
        _ &&
          d.dispose &&
          d.type !== "Scene" &&
          $T.unstable_scheduleCallback($T.unstable_IdlePriority, () => {
            try {
              d.dispose();
            } catch {}
          }),
        rc(h);
    }
  }
  function a(h, d, p, m) {
    var y;
    const M = (y = h.__r3f) == null ? void 0 : y.parent;
    if (!M) return;
    const A = t(d, p, h.__r3f.root);
    if (h.children) {
      for (const g of h.children) g.__r3f && i(A, g);
      h.children = h.children.filter((g) => !g.__r3f);
    }
    h.__r3f.objects.forEach((g) => i(A, g)),
      (h.__r3f.objects = []),
      h.__r3f.autoRemovedBeforeAppend || o(M, h),
      A.parent && (A.__r3f.autoRemovedBeforeAppend = !0),
      i(M, A),
      A.raycast &&
        A.__r3f.eventCount &&
        A.__r3f.root.getState().internal.interaction.push(A),
      [m, m.alternate].forEach((g) => {
        g !== null &&
          ((g.stateNode = A),
          g.ref &&
            (typeof g.ref == "function" ? g.ref(A) : (g.ref.current = A)));
      });
  }
  const l = () =>
    console.warn(
      "Text is not allowed in the R3F tree! This could be stray whitespace or characters."
    );
  return {
    reconciler: QV({
      createInstance: t,
      removeChild: o,
      appendChild: i,
      appendInitialChild: i,
      insertBefore: r,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (h, d) => {
        if (!d) return;
        const p = h.getState().scene;
        p.__r3f && ((p.__r3f.root = h), i(p, d));
      },
      removeChildFromContainer: (h, d) => {
        d && o(h.getState().scene, d);
      },
      insertInContainerBefore: (h, d, p) => {
        if (!d || !p) return;
        const m = h.getState().scene;
        m.__r3f && r(m, d, p);
      },
      getRootHostContext: () => null,
      getChildHostContext: (h) => h,
      finalizeInitialChildren(h) {
        var d;
        return !!((d = h == null ? void 0 : h.__r3f) != null ? d : {}).handlers;
      },
      prepareUpdate(h, d, p, m) {
        var y;
        if (
          ((y = h == null ? void 0 : h.__r3f) != null ? y : {}).primitive &&
          m.object &&
          m.object !== h
        )
          return [!0];
        {
          const { args: A = [], children: g, ...x } = m,
            { args: _ = [], children: E, ...T } = p;
          if (!Array.isArray(A))
            throw new Error("R3F: the args prop must be an array!");
          if (A.some((P, B) => P !== _[B])) return [!0];
          const R = vL(h, x, T, !0);
          return R.changes.length ? [!1, R] : null;
        }
      },
      commitUpdate(h, [d, p], m, y, M, A) {
        d ? a(h, m, M, A) : Fy(h, p);
      },
      commitMount(h, d, p, m) {
        var y;
        const M = (y = h.__r3f) != null ? y : {};
        h.raycast &&
          M.handlers &&
          M.eventCount &&
          h.__r3f.root.getState().internal.interaction.push(h);
      },
      getPublicInstance: (h) => h,
      prepareForCommit: () => null,
      preparePortalMount: (h) => ic(h.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(h) {
        var d;
        const { attach: p, parent: m } = (d = h.__r3f) != null ? d : {};
        p && m && rC(m, h, p), h.isObject3D && (h.visible = !1), rc(h);
      },
      unhideInstance(h, d) {
        var p;
        const { attach: m, parent: y } = (p = h.__r3f) != null ? p : {};
        m && y && Dy(y, h, m),
          ((h.isObject3D && d.visible == null) || d.visible) &&
            (h.visible = !0),
          rc(h);
      },
      createTextInstance: l,
      hideTextInstance: l,
      unhideTextInstance: l,
      getCurrentEventPriority: () => (e ? e() : Ac.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && Yt.fun(performance.now)
          ? performance.now
          : Yt.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: Yt.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Yt.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: Fy,
  };
}
var eC, tC;
const Iy = (n) => "colorSpace" in n || "outputColorSpace" in n,
  fL = () => {
    var n;
    return (n = rS.ColorManagement) != null ? n : null;
  },
  hL = (n) => n && n.isOrthographicCamera,
  i5 = (n) => n && n.hasOwnProperty("current"),
  Fh =
    typeof window < "u" &&
    (((eC = window.document) != null && eC.createElement) ||
      ((tC = window.navigator) == null ? void 0 : tC.product) === "ReactNative")
      ? W.useLayoutEffect
      : W.useEffect;
function dL(n) {
  const e = W.useRef(n);
  return Fh(() => void (e.current = n), [n]), e;
}
function r5({ set: n }) {
  return Fh(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class pL extends W.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
pL.getDerivedStateFromError = () => ({ error: !0 });
const mL = "__default",
  nC = new Map(),
  s5 = (n) => n && !!n.memoized && !!n.changes;
function gL(n) {
  var e;
  const t =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const Qu = (n) => {
    var e;
    return (e = n.__r3f) == null ? void 0 : e.root.getState();
  },
  Yt = {
    obj: (n) => n === Object(n) && !Yt.arr(n) && typeof n != "function",
    fun: (n) => typeof n == "function",
    str: (n) => typeof n == "string",
    num: (n) => typeof n == "number",
    boo: (n) => typeof n == "boolean",
    und: (n) => n === void 0,
    arr: (n) => Array.isArray(n),
    equ(
      n,
      e,
      { arrays: t = "shallow", objects: i = "reference", strict: r = !0 } = {}
    ) {
      if (typeof n != typeof e || !!n != !!e) return !1;
      if (Yt.str(n) || Yt.num(n)) return n === e;
      const s = Yt.obj(n);
      if (s && i === "reference") return n === e;
      const o = Yt.arr(n);
      if (o && t === "reference") return n === e;
      if ((o || s) && n === e) return !0;
      let a;
      for (a in n) if (!(a in e)) return !1;
      if (s && t === "shallow" && i === "shallow") {
        for (a in r ? e : n)
          if (!Yt.equ(n[a], e[a], { strict: r, objects: "reference" }))
            return !1;
      } else for (a in r ? e : n) if (n[a] !== e[a]) return !1;
      if (Yt.und(a)) {
        if (
          (o && n.length === 0 && e.length === 0) ||
          (s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
        )
          return !0;
        if (n !== e) return !1;
      }
      return !0;
    },
  };
function o5(n) {
  const e = { nodes: {}, materials: {} };
  return (
    n &&
      n.traverse((t) => {
        t.name && (e.nodes[t.name] = t),
          t.material &&
            !e.materials[t.material.name] &&
            (e.materials[t.material.name] = t.material);
      }),
    e
  );
}
function a5(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n) e.dispose == null || e.dispose(), delete n[e];
}
function ic(n, e) {
  const t = n;
  return (
    (t.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    n
  );
}
function G_(n, e) {
  let t = n;
  if (e.includes("-")) {
    const i = e.split("-"),
      r = i.pop();
    return (t = i.reduce((s, o) => s[o], n)), { target: t, key: r };
  } else return { target: t, key: e };
}
const iC = /-\d+$/;
function Dy(n, e, t) {
  if (Yt.str(t)) {
    if (iC.test(t)) {
      const s = t.replace(iC, ""),
        { target: o, key: a } = G_(n, s);
      Array.isArray(o[a]) || (o[a] = []);
    }
    const { target: i, key: r } = G_(n, t);
    (e.__r3f.previousAttach = i[r]), (i[r] = e);
  } else e.__r3f.previousAttach = t(n, e);
}
function rC(n, e, t) {
  var i, r;
  if (Yt.str(t)) {
    const { target: s, key: o } = G_(n, t),
      a = e.__r3f.previousAttach;
    a === void 0 ? delete s[o] : (s[o] = a);
  } else
    (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e);
  (r = e.__r3f) == null || delete r.previousAttach;
}
function vL(
  n,
  { children: e, key: t, ref: i, ...r },
  { children: s, key: o, ref: a, ...l } = {},
  u = !1
) {
  var h;
  const d = (h = n == null ? void 0 : n.__r3f) != null ? h : {},
    p = Object.entries(r),
    m = [];
  if (u) {
    const M = Object.keys(l);
    for (let A = 0; A < M.length; A++)
      r.hasOwnProperty(M[A]) || p.unshift([M[A], mL + "remove"]);
  }
  p.forEach(([M, A]) => {
    var g;
    if (
      ((g = n.__r3f) != null && g.primitive && M === "object") ||
      Yt.equ(A, l[M])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(M))
      return m.push([M, A, !0, []]);
    let x = [];
    M.includes("-") && (x = M.split("-")), m.push([M, A, !1, x]);
    for (const _ in r) {
      const E = r[_];
      _.startsWith(`${M}-`) && m.push([_, E, !1, _.split("-")]);
    }
  });
  const y = { ...r };
  return (
    d.memoizedProps && d.memoizedProps.args && (y.args = d.memoizedProps.args),
    d.memoizedProps &&
      d.memoizedProps.attach &&
      (y.attach = d.memoizedProps.attach),
    { memoized: y, changes: m }
  );
}
function Fy(n, e) {
  var t, i, r;
  const s = (t = n.__r3f) != null ? t : {},
    o = s.root,
    a =
      (i = o == null || o.getState == null ? void 0 : o.getState()) != null
        ? i
        : {},
    { memoized: l, changes: u } = s5(e) ? e : vL(n, e),
    h = s.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = l);
  for (let p = 0; p < u.length; p++) {
    let [m, y, M, A] = u[p];
    if (Iy(n)) {
      const E = "srgb",
        T = "srgb-linear";
      m === "encoding"
        ? ((m = "colorSpace"), (y = y === 3001 ? E : T))
        : m === "outputEncoding" &&
          ((m = "outputColorSpace"), (y = y === 3001 ? E : T));
    }
    let g = n,
      x = g[m];
    if (A.length && ((x = A.reduce((_, E) => _[E], n)), !(x && x.set))) {
      const [_, ...E] = A.reverse();
      (g = E.reverse().reduce((T, R) => T[R], n)), (m = _);
    }
    if (y === mL + "remove")
      if (g.constructor) {
        let _ = nC.get(g.constructor);
        _ || ((_ = new g.constructor()), nC.set(g.constructor, _)), (y = _[m]);
      } else y = 0;
    if (M)
      y ? (s.handlers[m] = y) : delete s.handlers[m],
        (s.eventCount = Object.keys(s.handlers).length);
    else if (x && x.set && (x.copy || x instanceof Za)) {
      if (Array.isArray(y)) x.fromArray ? x.fromArray(y) : x.set(...y);
      else if (x.copy && y && y.constructor && x.constructor === y.constructor)
        x.copy(y);
      else if (y !== void 0) {
        const _ = x instanceof Ue;
        !_ && x.setScalar
          ? x.setScalar(y)
          : x instanceof Za && y instanceof Za
          ? (x.mask = y.mask)
          : x.set(y),
          !fL() && !a.linear && _ && x.convertSRGBToLinear();
      }
    } else if (
      ((g[m] = y), g[m] instanceof en && g[m].format === bi && g[m].type === ms)
    ) {
      const _ = g[m];
      Iy(_) && Iy(a.gl)
        ? (_.colorSpace = a.gl.outputColorSpace)
        : (_.encoding = a.gl.outputEncoding);
    }
    rc(n);
  }
  if (s.parent && a.internal && n.raycast && h !== s.eventCount) {
    const p = a.internal.interaction.indexOf(n);
    p > -1 && a.internal.interaction.splice(p, 1),
      s.eventCount && a.internal.interaction.push(n);
  }
  return (
    !(u.length === 1 && u[0][0] === "onUpdate") &&
      u.length &&
      (r = n.__r3f) != null &&
      r.parent &&
      V_(n),
    n
  );
}
function rc(n) {
  var e, t;
  const i =
    (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState();
  i && i.internal.frames === 0 && i.invalidate();
}
function V_(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function l5(n, e) {
  n.manual ||
    (hL(n)
      ? ((n.left = e.width / -2),
        (n.right = e.width / 2),
        (n.top = e.height / 2),
        (n.bottom = e.height / -2))
      : (n.aspect = e.width / e.height),
    n.updateProjectionMatrix(),
    n.updateMatrixWorld());
}
function jp(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function c5() {
  var n;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return Ac.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return Ac.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return Ac.ContinuousEventPriority;
    default:
      return Ac.DefaultEventPriority;
  }
}
function yL(n, e, t, i) {
  const r = t.get(e);
  r &&
    (t.delete(e),
    t.size === 0 && (n.delete(i), r.target.releasePointerCapture(i)));
}
function u5(n, e) {
  const { internal: t } = n.getState();
  (t.interaction = t.interaction.filter((i) => i !== e)),
    (t.initialHits = t.initialHits.filter((i) => i !== e)),
    t.hovered.forEach((i, r) => {
      (i.eventObject === e || i.object === e) && t.hovered.delete(r);
    }),
    t.capturedMap.forEach((i, r) => {
      yL(t.capturedMap, e, i, r);
    });
}
function f5(n) {
  function e(l) {
    const { internal: u } = n.getState(),
      h = l.offsetX - u.initialClick[0],
      d = l.offsetY - u.initialClick[1];
    return Math.round(Math.sqrt(h * h + d * d));
  }
  function t(l) {
    return l.filter((u) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((h) => {
        var d;
        return (d = u.__r3f) == null ? void 0 : d.handlers["onPointer" + h];
      })
    );
  }
  function i(l, u) {
    const h = n.getState(),
      d = new Set(),
      p = [],
      m = u ? u(h.internal.interaction) : h.internal.interaction;
    for (let g = 0; g < m.length; g++) {
      const x = Qu(m[g]);
      x && (x.raycaster.camera = void 0);
    }
    h.previousRoot || h.events.compute == null || h.events.compute(l, h);
    function y(g) {
      const x = Qu(g);
      if (!x || !x.events.enabled || x.raycaster.camera === null) return [];
      if (x.raycaster.camera === void 0) {
        var _;
        x.events.compute == null ||
          x.events.compute(
            l,
            x,
            (_ = x.previousRoot) == null ? void 0 : _.getState()
          ),
          x.raycaster.camera === void 0 && (x.raycaster.camera = null);
      }
      return x.raycaster.camera ? x.raycaster.intersectObject(g, !0) : [];
    }
    let M = m
      .flatMap(y)
      .sort((g, x) => {
        const _ = Qu(g.object),
          E = Qu(x.object);
        return !_ || !E
          ? g.distance - x.distance
          : E.events.priority - _.events.priority || g.distance - x.distance;
      })
      .filter((g) => {
        const x = jp(g);
        return d.has(x) ? !1 : (d.add(x), !0);
      });
    h.events.filter && (M = h.events.filter(M, h));
    for (const g of M) {
      let x = g.object;
      for (; x; ) {
        var A;
        (A = x.__r3f) != null &&
          A.eventCount &&
          p.push({ ...g, eventObject: x }),
          (x = x.parent);
      }
    }
    if ("pointerId" in l && h.internal.capturedMap.has(l.pointerId))
      for (let g of h.internal.capturedMap.get(l.pointerId).values())
        d.has(jp(g.intersection)) || p.push(g.intersection);
    return p;
  }
  function r(l, u, h, d) {
    const p = n.getState();
    if (l.length) {
      const m = { stopped: !1 };
      for (const y of l) {
        const M = Qu(y.object) || p,
          { raycaster: A, pointer: g, camera: x, internal: _ } = M,
          E = new F(g.x, g.y, 0).unproject(x),
          T = (L) => {
            var z, $;
            return (z =
              ($ = _.capturedMap.get(L)) == null
                ? void 0
                : $.has(y.eventObject)) != null
              ? z
              : !1;
          },
          R = (L) => {
            const z = { intersection: y, target: u.target };
            _.capturedMap.has(L)
              ? _.capturedMap.get(L).set(y.eventObject, z)
              : _.capturedMap.set(L, new Map([[y.eventObject, z]])),
              u.target.setPointerCapture(L);
          },
          P = (L) => {
            const z = _.capturedMap.get(L);
            z && yL(_.capturedMap, y.eventObject, z, L);
          };
        let B = {};
        for (let L in u) {
          let z = u[L];
          typeof z != "function" && (B[L] = z);
        }
        let b = {
          ...y,
          ...B,
          pointer: g,
          intersections: l,
          stopped: m.stopped,
          delta: h,
          unprojectedPoint: E,
          ray: A.ray,
          camera: x,
          stopPropagation() {
            const L = "pointerId" in u && _.capturedMap.get(u.pointerId);
            if (
              (!L || L.has(y.eventObject)) &&
              ((b.stopped = m.stopped = !0),
              _.hovered.size &&
                Array.from(_.hovered.values()).find(
                  (z) => z.eventObject === y.eventObject
                ))
            ) {
              const z = l.slice(0, l.indexOf(y));
              s([...z, y]);
            }
          },
          target: {
            hasPointerCapture: T,
            setPointerCapture: R,
            releasePointerCapture: P,
          },
          currentTarget: {
            hasPointerCapture: T,
            setPointerCapture: R,
            releasePointerCapture: P,
          },
          nativeEvent: u,
        };
        if ((d(b), m.stopped === !0)) break;
      }
    }
    return l;
  }
  function s(l) {
    const { internal: u } = n.getState();
    for (const h of u.hovered.values())
      if (
        !l.length ||
        !l.find(
          (d) =>
            d.object === h.object &&
            d.index === h.index &&
            d.instanceId === h.instanceId
        )
      ) {
        const p = h.eventObject.__r3f,
          m = p == null ? void 0 : p.handlers;
        if ((u.hovered.delete(jp(h)), p != null && p.eventCount)) {
          const y = { ...h, intersections: l };
          m.onPointerOut == null || m.onPointerOut(y),
            m.onPointerLeave == null || m.onPointerLeave(y);
        }
      }
  }
  function o(l, u) {
    for (let h = 0; h < u.length; h++) {
      const d = u[h].__r3f;
      d == null ||
        d.handlers.onPointerMissed == null ||
        d.handlers.onPointerMissed(l);
    }
  }
  function a(l) {
    switch (l) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (u) => {
          const { internal: h } = n.getState();
          "pointerId" in u &&
            h.capturedMap.has(u.pointerId) &&
            requestAnimationFrame(() => {
              h.capturedMap.has(u.pointerId) &&
                (h.capturedMap.delete(u.pointerId), s([]));
            });
        };
    }
    return function (h) {
      const { onPointerMissed: d, internal: p } = n.getState();
      p.lastEvent.current = h;
      const m = l === "onPointerMove",
        y = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick",
        A = i(h, m ? t : void 0),
        g = y ? e(h) : 0;
      l === "onPointerDown" &&
        ((p.initialClick = [h.offsetX, h.offsetY]),
        (p.initialHits = A.map((_) => _.eventObject))),
        y && !A.length && g <= 2 && (o(h, p.interaction), d && d(h)),
        m && s(A);
      function x(_) {
        const E = _.eventObject,
          T = E.__r3f,
          R = T == null ? void 0 : T.handlers;
        if (T != null && T.eventCount)
          if (m) {
            if (
              R.onPointerOver ||
              R.onPointerEnter ||
              R.onPointerOut ||
              R.onPointerLeave
            ) {
              const P = jp(_),
                B = p.hovered.get(P);
              B
                ? B.stopped && _.stopPropagation()
                : (p.hovered.set(P, _),
                  R.onPointerOver == null || R.onPointerOver(_),
                  R.onPointerEnter == null || R.onPointerEnter(_));
            }
            R.onPointerMove == null || R.onPointerMove(_);
          } else {
            const P = R[l];
            P
              ? (!y || p.initialHits.includes(E)) &&
                (o(
                  h,
                  p.interaction.filter((B) => !p.initialHits.includes(B))
                ),
                P(_))
              : y &&
                p.initialHits.includes(E) &&
                o(
                  h,
                  p.interaction.filter((B) => !p.initialHits.includes(B))
                );
          }
      }
      r(A, h, g, x);
    };
  }
  return { handlePointer: a };
}
const xL = (n) => !!(n != null && n.render),
  _L = W.createContext(null),
  h5 = (n, e) => {
    const t = sL((a, l) => {
        const u = new F(),
          h = new F(),
          d = new F();
        function p(g = l().camera, x = h, _ = l().size) {
          const { width: E, height: T, top: R, left: P } = _,
            B = E / T;
          x instanceof F ? d.copy(x) : d.set(...x);
          const b = g.getWorldPosition(u).distanceTo(d);
          if (hL(g))
            return {
              width: E / g.zoom,
              height: T / g.zoom,
              top: R,
              left: P,
              factor: 1,
              distance: b,
              aspect: B,
            };
          {
            const L = (g.fov * Math.PI) / 180,
              z = 2 * Math.tan(L / 2) * b,
              $ = z * (E / T);
            return {
              width: $,
              height: z,
              top: R,
              left: P,
              factor: E / $,
              distance: b,
              aspect: B,
            };
          }
        }
        let m;
        const y = (g) =>
            a((x) => ({ performance: { ...x.performance, current: g } })),
          M = new ve();
        return {
          set: a,
          get: l,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (g = 1) => n(l(), g),
          advance: (g, x) => e(g, x, l()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new eS(),
          pointer: M,
          mouse: M,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const g = l();
              m && clearTimeout(m),
                g.performance.current !== g.performance.min &&
                  y(g.performance.min),
                (m = setTimeout(
                  () => y(l().performance.max),
                  g.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: p,
          },
          setEvents: (g) => a((x) => ({ ...x, events: { ...x.events, ...g } })),
          setSize: (g, x, _, E, T) => {
            const R = l().camera,
              P = {
                width: g,
                height: x,
                top: E || 0,
                left: T || 0,
                updateStyle: _,
              };
            a((B) => ({ size: P, viewport: { ...B.viewport, ...p(R, h, P) } }));
          },
          setDpr: (g) =>
            a((x) => {
              const _ = gL(g);
              return {
                viewport: {
                  ...x.viewport,
                  dpr: _,
                  initialDpr: x.viewport.initialDpr || _,
                },
              };
            }),
          setFrameloop: (g = "always") => {
            const x = l().clock;
            x.stop(),
              (x.elapsedTime = 0),
              g !== "never" && (x.start(), (x.elapsedTime = 0)),
              a(() => ({ frameloop: g }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: W.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (g, x, _) => {
              const E = l().internal;
              return (
                (E.priority = E.priority + (x > 0 ? 1 : 0)),
                E.subscribers.push({ ref: g, priority: x, store: _ }),
                (E.subscribers = E.subscribers.sort(
                  (T, R) => T.priority - R.priority
                )),
                () => {
                  const T = l().internal;
                  T != null &&
                    T.subscribers &&
                    ((T.priority = T.priority - (x > 0 ? 1 : 0)),
                    (T.subscribers = T.subscribers.filter((R) => R.ref !== g)));
                }
              );
            },
          },
        };
      }),
      i = t.getState();
    let r = i.size,
      s = i.viewport.dpr,
      o = i.camera;
    return (
      t.subscribe(() => {
        const { camera: a, size: l, viewport: u, gl: h, set: d } = t.getState();
        if (l !== r || u.dpr !== s) {
          var p;
          (r = l), (s = u.dpr), l5(a, l), h.setPixelRatio(u.dpr);
          const m =
            (p = l.updateStyle) != null
              ? p
              : typeof HTMLCanvasElement < "u" &&
                h.domElement instanceof HTMLCanvasElement;
          h.setSize(l.width, l.height, m);
        }
        a !== o &&
          ((o = a),
          d((m) => ({
            viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(a) },
          })));
      }),
      t.subscribe((a) => n(a)),
      t
    );
  };
let Xp,
  d5 = new Set(),
  p5 = new Set(),
  m5 = new Set();
function Ny(n, e) {
  if (n.size) for (const { callback: t } of n.values()) t(e);
}
function qu(n, e) {
  switch (n) {
    case "before":
      return Ny(d5, e);
    case "after":
      return Ny(p5, e);
    case "tail":
      return Ny(m5, e);
  }
}
let Uy, Oy;
function ky(n, e, t) {
  let i = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof n == "number" &&
      ((i = n - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = n)),
      Uy = e.internal.subscribers,
      Xp = 0;
    Xp < Uy.length;
    Xp++
  )
    (Oy = Uy[Xp]), Oy.ref.current(Oy.store.getState(), i, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function g5(n) {
  let e = !1,
    t,
    i,
    r;
  function s(l) {
    (i = requestAnimationFrame(s)), (e = !0), (t = 0), qu("before", l);
    for (const h of n.values()) {
      var u;
      (r = h.store.getState()),
        r.internal.active &&
          (r.frameloop === "always" || r.internal.frames > 0) &&
          !((u = r.gl.xr) != null && u.isPresenting) &&
          (t += ky(l, r));
    }
    if ((qu("after", l), t === 0))
      return qu("tail", l), (e = !1), cancelAnimationFrame(i);
  }
  function o(l, u = 1) {
    var h;
    if (!l) return n.forEach((d) => o(d.store.getState()), u);
    ((h = l.gl.xr) != null && h.isPresenting) ||
      !l.internal.active ||
      l.frameloop === "never" ||
      ((l.internal.frames = Math.min(60, l.internal.frames + u)),
      e || ((e = !0), requestAnimationFrame(s)));
  }
  function a(l, u = !0, h, d) {
    if ((u && qu("before", l), h)) ky(l, h, d);
    else for (const p of n.values()) ky(l, p.store.getState());
    u && qu("after", l);
  }
  return { loop: s, invalidate: o, advance: a };
}
function AL() {
  const n = W.useContext(_L);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function yr(n = (t) => t, e) {
  return AL()(n, e);
}
function fu(n, e = 0) {
  const t = AL(),
    i = t.getState().internal.subscribe,
    r = dL(n);
  return Fh(() => i(r, e, t), [e, i, t]), null;
}
function SL(n, e) {
  return function (t, ...i) {
    const r = new t();
    return (
      n && n(r),
      Promise.all(
        i.map(
          (s) =>
            new Promise((o, a) =>
              r.load(
                s,
                (l) => {
                  l.scene && Object.assign(l, o5(l.scene)), o(l);
                },
                e,
                (l) => a(new Error(`Could not load ${s}: ${l.message})`))
              )
            )
        )
      )
    );
  };
}
function Nh(n, e, t, i) {
  const r = Array.isArray(e) ? e : [e],
    s = ZV(SL(t, i), [n, ...r], { equal: Yt.equ });
  return Array.isArray(e) ? s : s[0];
}
Nh.preload = function (n, e, t) {
  const i = Array.isArray(e) ? e : [e];
  return $V(SL(t), [n, ...i]);
};
Nh.clear = function (n, e) {
  const t = Array.isArray(e) ? e : [e];
  return e5([n, ...t]);
};
const eu = new Map(),
  { invalidate: sC, advance: oC } = g5(eu),
  { reconciler: eg, applyProps: tc } = n5(eu, c5),
  nc = { objects: "shallow", strict: !1 },
  v5 = (n, e) => {
    const t = typeof n == "function" ? n(e) : n;
    return xL(t)
      ? t
      : new B1({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...n,
        });
  };
function y5(n, e) {
  if (e) return e;
  if (
    typeof HTMLCanvasElement < "u" &&
    n instanceof HTMLCanvasElement &&
    n.parentElement
  ) {
    const {
      width: t,
      height: i,
      top: r,
      left: s,
    } = n.parentElement.getBoundingClientRect();
    return { width: t, height: i, top: r, left: s };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return { width: n.width, height: n.height, top: 0, left: 0 };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function x5(n) {
  const e = eu.get(n),
    t = e == null ? void 0 : e.fiber,
    i = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const r = typeof reportError == "function" ? reportError : console.error,
    s = i || h5(sC, oC),
    o =
      t ||
      eg.createContainer(s, Ac.ConcurrentRoot, null, !1, null, "", r, null);
  e || eu.set(n, { fiber: o, store: s });
  let a,
    l = !1,
    u;
  return {
    configure(h = {}) {
      let {
          gl: d,
          size: p,
          scene: m,
          events: y,
          onCreated: M,
          shadows: A = !1,
          linear: g = !1,
          flat: x = !1,
          legacy: _ = !1,
          orthographic: E = !1,
          frameloop: T = "always",
          dpr: R = [1, 2],
          performance: P,
          raycaster: B,
          camera: b,
          onPointerMissed: L,
        } = h,
        z = s.getState(),
        $ = z.gl;
      z.gl || z.set({ gl: ($ = v5(d, n)) });
      let X = z.raycaster;
      X || z.set({ raycaster: (X = new nL()) });
      const { params: Y, ...K } = B || {};
      if (
        (Yt.equ(K, X, nc) || tc(X, { ...K }),
        Yt.equ(Y, X.params, nc) || tc(X, { params: { ...X.params, ...Y } }),
        !z.camera || (z.camera === u && !Yt.equ(u, b, nc)))
      ) {
        u = b;
        const U = b instanceof wh,
          j = U
            ? b
            : E
            ? new Wr(0, 0, 0, 0, 0.1, 1e3)
            : new $t(75, 0, 0.1, 1e3);
        U ||
          ((j.position.z = 5),
          b && tc(j, b),
          !z.camera && !(b != null && b.rotation) && j.lookAt(0, 0, 0)),
          z.set({ camera: j });
      }
      if (!z.scene) {
        let U;
        m instanceof $m ? (U = m) : ((U = new $m()), m && tc(U, m)),
          z.set({ scene: ic(U) });
      }
      if (!z.xr) {
        const U = (ae, xe) => {
            const Ae = s.getState();
            Ae.frameloop !== "never" && oC(ae, !0, Ae, xe);
          },
          j = () => {
            const ae = s.getState();
            (ae.gl.xr.enabled = ae.gl.xr.isPresenting),
              ae.gl.xr.setAnimationLoop(ae.gl.xr.isPresenting ? U : null),
              ae.gl.xr.isPresenting || sC(ae);
          },
          he = {
            connect() {
              const ae = s.getState().gl;
              ae.xr.addEventListener("sessionstart", j),
                ae.xr.addEventListener("sessionend", j);
            },
            disconnect() {
              const ae = s.getState().gl;
              ae.xr.removeEventListener("sessionstart", j),
                ae.xr.removeEventListener("sessionend", j);
            },
          };
        $.xr && he.connect(), z.set({ xr: he });
      }
      if ($.shadowMap) {
        const U = $.shadowMap.enabled,
          j = $.shadowMap.type;
        if ((($.shadowMap.enabled = !!A), Yt.boo(A))) $.shadowMap.type = Mf;
        else if (Yt.str(A)) {
          var ie;
          const he = { basic: l2, percentage: Lg, soft: Mf, variance: Nr };
          $.shadowMap.type = (ie = he[A]) != null ? ie : Mf;
        } else Yt.obj(A) && Object.assign($.shadowMap, A);
        (U !== $.shadowMap.enabled || j !== $.shadowMap.type) &&
          ($.shadowMap.needsUpdate = !0);
      }
      const ee = fL();
      ee &&
        ("enabled" in ee
          ? (ee.enabled = !_)
          : "legacyMode" in ee && (ee.legacyMode = _)),
        tc($, { outputEncoding: g ? 3e3 : 3001, toneMapping: x ? Vr : u1 }),
        z.legacy !== _ && z.set(() => ({ legacy: _ })),
        z.linear !== g && z.set(() => ({ linear: g })),
        z.flat !== x && z.set(() => ({ flat: x })),
        d && !Yt.fun(d) && !xL(d) && !Yt.equ(d, $, nc) && tc($, d),
        y && !z.events.handlers && z.set({ events: y(s) });
      const k = y5(n, p);
      return (
        Yt.equ(k, z.size, nc) ||
          z.setSize(k.width, k.height, k.updateStyle, k.top, k.left),
        R && z.viewport.dpr !== gL(R) && z.setDpr(R),
        z.frameloop !== T && z.setFrameloop(T),
        z.onPointerMissed || z.set({ onPointerMissed: L }),
        P &&
          !Yt.equ(P, z.performance, nc) &&
          z.set((U) => ({ performance: { ...U.performance, ...P } })),
        (a = M),
        (l = !0),
        this
      );
    },
    render(h) {
      return (
        l || this.configure(),
        eg.updateContainer(
          W.createElement(_5, {
            store: s,
            children: h,
            onCreated: a,
            rootElement: n,
          }),
          o,
          null,
          () => {}
        ),
        s
      );
    },
    unmount() {
      ML(n);
    },
  };
}
function _5({ store: n, children: e, onCreated: t, rootElement: i }) {
  return (
    Fh(() => {
      const r = n.getState();
      r.set((s) => ({ internal: { ...s.internal, active: !0 } })),
        t && t(r),
        n.getState().events.connected ||
          r.events.connect == null ||
          r.events.connect(i);
    }, []),
    W.createElement(_L.Provider, { value: n }, e)
  );
}
function ML(n, e) {
  const t = eu.get(n),
    i = t == null ? void 0 : t.fiber;
  if (i) {
    const r = t == null ? void 0 : t.store.getState();
    r && (r.internal.active = !1),
      eg.updateContainer(null, i, null, () => {
        r &&
          setTimeout(() => {
            try {
              var s, o, a, l;
              r.events.disconnect == null || r.events.disconnect(),
                (s = r.gl) == null ||
                  (o = s.renderLists) == null ||
                  o.dispose == null ||
                  o.dispose(),
                (a = r.gl) == null ||
                  a.forceContextLoss == null ||
                  a.forceContextLoss(),
                (l = r.gl) != null && l.xr && r.xr.disconnect(),
                a5(r),
                eu.delete(n),
                e && e(n);
            } catch {}
          }, 500);
      });
  }
}
eg.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: W.version,
});
function Kr() {
  return (
    (Kr = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    Kr.apply(this, arguments)
  );
}
function W_(n, e, t) {
  var i, r, s, o, a;
  e == null && (e = 100);
  function l() {
    var h = Date.now() - o;
    h < e && h >= 0
      ? (i = setTimeout(l, e - h))
      : ((i = null), t || ((a = n.apply(s, r)), (s = r = null)));
  }
  var u = function () {
    (s = this), (r = arguments), (o = Date.now());
    var h = t && !i;
    return (
      i || (i = setTimeout(l, e)), h && ((a = n.apply(s, r)), (s = r = null)), a
    );
  };
  return (
    (u.clear = function () {
      i && (clearTimeout(i), (i = null));
    }),
    (u.flush = function () {
      i && ((a = n.apply(s, r)), (s = r = null), clearTimeout(i), (i = null));
    }),
    u
  );
}
W_.debounce = W_;
var A5 = W_;
const aC = hg(A5);
function S5(n) {
  let {
    debounce: e,
    scroll: t,
    polyfill: i,
    offsetSize: r,
  } = n === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : n;
  const s = i || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!s)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [o, a] = W.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    l = W.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: o,
    }),
    u = e ? (typeof e == "number" ? e : e.scroll) : null,
    h = e ? (typeof e == "number" ? e : e.resize) : null,
    d = W.useRef(!1);
  W.useEffect(() => ((d.current = !0), () => void (d.current = !1)));
  const [p, m, y] = W.useMemo(() => {
    const x = () => {
      if (!l.current.element) return;
      const {
          left: _,
          top: E,
          width: T,
          height: R,
          bottom: P,
          right: B,
          x: b,
          y: L,
        } = l.current.element.getBoundingClientRect(),
        z = {
          left: _,
          top: E,
          width: T,
          height: R,
          bottom: P,
          right: B,
          x: b,
          y: L,
        };
      l.current.element instanceof HTMLElement &&
        r &&
        ((z.height = l.current.element.offsetHeight),
        (z.width = l.current.element.offsetWidth)),
        Object.freeze(z),
        d.current &&
          !T5(l.current.lastBounds, z) &&
          a((l.current.lastBounds = z));
    };
    return [x, h ? aC(x, h) : x, u ? aC(x, u) : x];
  }, [a, r, u, h]);
  function M() {
    l.current.scrollContainers &&
      (l.current.scrollContainers.forEach((x) =>
        x.removeEventListener("scroll", y, !0)
      ),
      (l.current.scrollContainers = null)),
      l.current.resizeObserver &&
        (l.current.resizeObserver.disconnect(),
        (l.current.resizeObserver = null));
  }
  function A() {
    l.current.element &&
      ((l.current.resizeObserver = new s(y)),
      l.current.resizeObserver.observe(l.current.element),
      t &&
        l.current.scrollContainers &&
        l.current.scrollContainers.forEach((x) =>
          x.addEventListener("scroll", y, { capture: !0, passive: !0 })
        ));
  }
  const g = (x) => {
    !x ||
      x === l.current.element ||
      (M(), (l.current.element = x), (l.current.scrollContainers = EL(x)), A());
  };
  return (
    E5(y, !!t),
    M5(m),
    W.useEffect(() => {
      M(), A();
    }, [t, y, m]),
    W.useEffect(() => M, []),
    [g, o, p]
  );
}
function M5(n) {
  W.useEffect(() => {
    const e = n;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [n]);
}
function E5(n, e) {
  W.useEffect(() => {
    if (e) {
      const t = n;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [n, e]);
}
function EL(n) {
  const e = [];
  if (!n || n === document.body) return e;
  const {
    overflow: t,
    overflowX: i,
    overflowY: r,
  } = window.getComputedStyle(n);
  return (
    [t, i, r].some((s) => s === "auto" || s === "scroll") && e.push(n),
    [...e, ...EL(n.parentElement)]
  );
}
const w5 = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  T5 = (n, e) => w5.every((t) => n[t] === e[t]);
var C5 = Object.defineProperty,
  b5 = Object.defineProperties,
  R5 = Object.getOwnPropertyDescriptors,
  lC = Object.getOwnPropertySymbols,
  P5 = Object.prototype.hasOwnProperty,
  B5 = Object.prototype.propertyIsEnumerable,
  cC = (n, e, t) =>
    e in n
      ? C5(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  uC = (n, e) => {
    for (var t in e || (e = {})) P5.call(e, t) && cC(n, t, e[t]);
    if (lC) for (var t of lC(e)) B5.call(e, t) && cC(n, t, e[t]);
    return n;
  },
  L5 = (n, e) => b5(n, R5(e));
function wL(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let i = e ? n.return : n.child;
  for (; i; ) {
    const r = wL(i, e, t);
    if (r) return r;
    i = e ? null : i.sibling;
  }
}
function TL(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
const sS = TL(W.createContext(null));
class CL extends W.Component {
  render() {
    return W.createElement(
      sS.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
const { ReactCurrentOwner: fC, ReactCurrentDispatcher: hC } =
  W.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function I5() {
  const n = W.useContext(sS);
  if (n === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = W.useId();
  return W.useMemo(() => {
    for (const i of [
      fC == null ? void 0 : fC.current,
      n,
      n == null ? void 0 : n.alternate,
    ]) {
      if (!i) continue;
      const r = wL(i, !1, (s) => {
        let o = s.memoizedState;
        for (; o; ) {
          if (o.memoizedState === e) return !0;
          o = o.next;
        }
      });
      if (r) return r;
    }
  }, [n, e]);
}
function D5() {
  var n, e;
  const t = I5(),
    [i] = W.useState(() => new Map());
  i.clear();
  let r = t;
  for (; r; ) {
    const s = (n = r.type) == null ? void 0 : n._context;
    s &&
      s !== sS &&
      !i.has(s) &&
      i.set(
        s,
        (e = hC == null ? void 0 : hC.current) == null
          ? void 0
          : e.readContext(TL(s))
      ),
      (r = r.return);
  }
  return i;
}
function F5() {
  const n = D5();
  return W.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (i) =>
          W.createElement(
            e,
            null,
            W.createElement(t.Provider, L5(uC({}, i), { value: n.get(t) }))
          ),
        (e) => W.createElement(CL, uC({}, e))
      ),
    [n]
  );
}
const Hy = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function N5(n) {
  const { handlePointer: e } = f5(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, i, r) {
      i.pointer.set(
        (t.offsetX / i.size.width) * 2 - 1,
        -(t.offsetY / i.size.height) * 2 + 1
      ),
        i.raycaster.setFromCamera(i.pointer, i.camera);
    },
    connected: void 0,
    handlers: Object.keys(Hy).reduce((t, i) => ({ ...t, [i]: e(i) }), {}),
    update: () => {
      var t;
      const { events: i, internal: r } = n.getState();
      (t = r.lastEvent) != null &&
        t.current &&
        i.handlers &&
        i.handlers.onPointerMove(r.lastEvent.current);
    },
    connect: (t) => {
      var i;
      const { set: r, events: s } = n.getState();
      s.disconnect == null || s.disconnect(),
        r((o) => ({ events: { ...o.events, connected: t } })),
        Object.entries((i = s.handlers) != null ? i : []).forEach(([o, a]) => {
          const [l, u] = Hy[o];
          t.addEventListener(l, a, { passive: u });
        });
    },
    disconnect: () => {
      const { set: t, events: i } = n.getState();
      if (i.connected) {
        var r;
        Object.entries((r = i.handlers) != null ? r : []).forEach(([s, o]) => {
          if (i && i.connected instanceof HTMLElement) {
            const [a] = Hy[s];
            i.connected.removeEventListener(a, o);
          }
        }),
          t((s) => ({ events: { ...s.events, connected: void 0 } }));
      }
    },
  };
}
const U5 = W.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: i,
      style: r,
      gl: s,
      events: o = N5,
      eventSource: a,
      eventPrefix: l,
      shadows: u,
      linear: h,
      flat: d,
      legacy: p,
      orthographic: m,
      frameloop: y,
      dpr: M,
      performance: A,
      raycaster: g,
      camera: x,
      onPointerMissed: _,
      onCreated: E,
      ...T
    },
    R
  ) {
    W.useMemo(() => t5(VV), []);
    const P = F5(),
      [B, b] = S5({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...i }),
      L = W.useRef(null),
      z = W.useRef(null);
    W.useImperativeHandle(R, () => L.current);
    const $ = dL(_),
      [X, Y] = W.useState(!1),
      [K, ie] = W.useState(!1);
    if (X) throw X;
    if (K) throw K;
    const ee = W.useRef(null);
    Fh(() => {
      const G = L.current;
      b.width > 0 &&
        b.height > 0 &&
        G &&
        (ee.current || (ee.current = x5(G)),
        ee.current.configure({
          gl: s,
          events: o,
          shadows: u,
          linear: h,
          flat: d,
          legacy: p,
          orthographic: m,
          frameloop: y,
          dpr: M,
          performance: A,
          raycaster: g,
          camera: x,
          size: b,
          onPointerMissed: (...k) =>
            $.current == null ? void 0 : $.current(...k),
          onCreated: (k) => {
            k.events.connect == null ||
              k.events.connect(a ? (i5(a) ? a.current : a) : z.current),
              l &&
                k.setEvents({
                  compute: (U, j) => {
                    const he = U[l + "X"],
                      ae = U[l + "Y"];
                    j.pointer.set(
                      (he / j.size.width) * 2 - 1,
                      -(ae / j.size.height) * 2 + 1
                    ),
                      j.raycaster.setFromCamera(j.pointer, j.camera);
                  },
                }),
              E == null || E(k);
          },
        }),
        ee.current.render(
          W.createElement(
            P,
            null,
            W.createElement(
              pL,
              { set: ie },
              W.createElement(
                W.Suspense,
                { fallback: W.createElement(r5, { set: Y }) },
                e
              )
            )
          )
        ));
    }),
      W.useEffect(() => {
        const G = L.current;
        if (G) return () => ML(G);
      }, []);
    const I = a ? "none" : "auto";
    return W.createElement(
      "div",
      Kr(
        {
          ref: z,
          style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: I,
            ...r,
          },
        },
        T
      ),
      W.createElement(
        "div",
        { ref: B, style: { width: "100%", height: "100%" } },
        W.createElement("canvas", { ref: L, style: { display: "block" } }, t)
      )
    );
  }),
  oS = W.forwardRef(function (e, t) {
    return W.createElement(
      CL,
      null,
      W.createElement(U5, Kr({}, e, { ref: t }))
    );
  }),
  Uh = new F(),
  aS = new F(),
  O5 = new F();
function k5(n, e, t) {
  const i = Uh.setFromMatrixPosition(n.matrixWorld);
  i.project(e);
  const r = t.width / 2,
    s = t.height / 2;
  return [i.x * r + r, -(i.y * s) + s];
}
function H5(n, e) {
  const t = Uh.setFromMatrixPosition(n.matrixWorld),
    i = aS.setFromMatrixPosition(e.matrixWorld),
    r = t.sub(i),
    s = e.getWorldDirection(O5);
  return r.angleTo(s) > Math.PI / 2;
}
function z5(n, e, t, i) {
  const r = Uh.setFromMatrixPosition(n.matrixWorld),
    s = r.clone();
  s.project(e), t.setFromCamera(s, e);
  const o = t.intersectObjects(i, !0);
  if (o.length) {
    const a = o[0].distance;
    return r.distanceTo(t.ray.origin) < a;
  }
  return !0;
}
function G5(n, e) {
  if (e instanceof Wr) return e.zoom;
  if (e instanceof $t) {
    const t = Uh.setFromMatrixPosition(n.matrixWorld),
      i = aS.setFromMatrixPosition(e.matrixWorld),
      r = (e.fov * Math.PI) / 180,
      s = t.distanceTo(i);
    return 1 / (2 * Math.tan(r / 2) * s);
  } else return 1;
}
function V5(n, e, t) {
  if (e instanceof $t || e instanceof Wr) {
    const i = Uh.setFromMatrixPosition(n.matrixWorld),
      r = aS.setFromMatrixPosition(e.matrixWorld),
      s = i.distanceTo(r),
      o = (t[1] - t[0]) / (e.far - e.near),
      a = t[1] - o * e.far;
    return Math.round(o * s + a);
  }
}
const j_ = (n) => (Math.abs(n) < 1e-10 ? 0 : n);
function bL(n, e, t = "") {
  let i = "matrix3d(";
  for (let r = 0; r !== 16; r++)
    i += j_(e[r] * n.elements[r]) + (r !== 15 ? "," : ")");
  return t + i;
}
const W5 = (
    (n) => (e) =>
      bL(e, n)
  )([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
  j5 = (
    (n) => (e, t) =>
      bL(e, n(t), "translate(-50%,-50%)")
  )((n) => [
    1 / n,
    1 / n,
    1 / n,
    1,
    -1 / n,
    -1 / n,
    -1 / n,
    -1,
    1 / n,
    1 / n,
    1 / n,
    1,
    1,
    1,
    1,
    1,
  ]);
function X5(n) {
  return n && typeof n == "object" && "current" in n;
}
const J5 = W.forwardRef(
  (
    {
      children: n,
      eps: e = 0.001,
      style: t,
      className: i,
      prepend: r,
      center: s,
      fullscreen: o,
      portal: a,
      distanceFactor: l,
      sprite: u = !1,
      transform: h = !1,
      occlude: d,
      onOcclude: p,
      castShadow: m,
      receiveShadow: y,
      material: M,
      geometry: A,
      zIndexRange: g = [16777271, 0],
      calculatePosition: x = k5,
      as: _ = "div",
      wrapperClass: E,
      pointerEvents: T = "auto",
      ...R
    },
    P
  ) => {
    const {
        gl: B,
        camera: b,
        scene: L,
        size: z,
        raycaster: $,
        events: X,
        viewport: Y,
      } = yr(),
      [K] = W.useState(() => document.createElement(_)),
      ie = W.useRef(),
      ee = W.useRef(null),
      I = W.useRef(0),
      G = W.useRef([0, 0]),
      k = W.useRef(null),
      U = W.useRef(null),
      j =
        (a == null ? void 0 : a.current) ||
        X.connected ||
        B.domElement.parentNode,
      he = W.useRef(null),
      ae = W.useRef(!1),
      xe = W.useMemo(
        () =>
          (d && d !== "blending") || (Array.isArray(d) && d.length && X5(d[0])),
        [d]
      );
    W.useLayoutEffect(() => {
      const tt = B.domElement;
      d && d === "blending"
        ? ((tt.style.zIndex = `${Math.floor(g[0] / 2)}`),
          (tt.style.position = "absolute"),
          (tt.style.pointerEvents = "none"))
        : ((tt.style.zIndex = null),
          (tt.style.position = null),
          (tt.style.pointerEvents = null));
    }, [d]),
      W.useLayoutEffect(() => {
        if (ee.current) {
          const tt = (ie.current = qP(K));
          if ((L.updateMatrixWorld(), h))
            K.style.cssText =
              "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
          else {
            const Me = x(ee.current, b, z);
            K.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${Me[0]}px,${Me[1]}px,0);transform-origin:0 0;`;
          }
          return (
            j && (r ? j.prepend(K) : j.appendChild(K)),
            () => {
              j && j.removeChild(K), tt.unmount();
            }
          );
        }
      }, [j, h]),
      W.useLayoutEffect(() => {
        E && (K.className = E);
      }, [E]);
    const Ae = W.useMemo(
        () =>
          h
            ? {
                position: "absolute",
                top: 0,
                left: 0,
                width: z.width,
                height: z.height,
                transformStyle: "preserve-3d",
                pointerEvents: "none",
              }
            : {
                position: "absolute",
                transform: s ? "translate3d(-50%,-50%,0)" : "none",
                ...(o && {
                  top: -z.height / 2,
                  left: -z.width / 2,
                  width: z.width,
                  height: z.height,
                }),
                ...t,
              },
        [t, s, o, z, h]
      ),
      Le = W.useMemo(() => ({ position: "absolute", pointerEvents: T }), [T]);
    W.useLayoutEffect(() => {
      if (((ae.current = !1), h)) {
        var tt;
        (tt = ie.current) == null ||
          tt.render(
            W.createElement(
              "div",
              { ref: k, style: Ae },
              W.createElement(
                "div",
                { ref: U, style: Le },
                W.createElement("div", {
                  ref: P,
                  className: i,
                  style: t,
                  children: n,
                })
              )
            )
          );
      } else {
        var Me;
        (Me = ie.current) == null ||
          Me.render(
            W.createElement("div", {
              ref: P,
              style: Ae,
              className: i,
              children: n,
            })
          );
      }
    });
    const Ve = W.useRef(!0);
    fu((tt) => {
      if (ee.current) {
        b.updateMatrixWorld(), ee.current.updateWorldMatrix(!0, !1);
        const Me = h ? G.current : x(ee.current, b, z);
        if (
          h ||
          Math.abs(I.current - b.zoom) > e ||
          Math.abs(G.current[0] - Me[0]) > e ||
          Math.abs(G.current[1] - Me[1]) > e
        ) {
          const V = H5(ee.current, b);
          let ye = !1;
          xe &&
            (d !== "blending"
              ? (ye = [L])
              : Array.isArray(d) && (ye = d.map((We) => We.current)));
          const me = Ve.current;
          if (ye) {
            const We = z5(ee.current, b, $, ye);
            Ve.current = We && !V;
          } else Ve.current = !V;
          me !== Ve.current &&
            (p
              ? p(!Ve.current)
              : (K.style.display = Ve.current ? "block" : "none"));
          const Ee = Math.floor(g[0] / 2),
            _e = d ? (xe ? [g[0], Ee] : [Ee - 1, 0]) : g;
          if (((K.style.zIndex = `${V5(ee.current, b, _e)}`), h)) {
            const [We, Oe] = [z.width / 2, z.height / 2],
              Ge = b.projectionMatrix.elements[5] * Oe,
              {
                isOrthographicCamera: Ze,
                top: vt,
                left: kt,
                bottom: H,
                right: D,
              } = b,
              ce = W5(b.matrixWorldInverse),
              we = Ze
                ? `scale(${Ge})translate(${j_(-(D + kt) / 2)}px,${j_(
                    (vt + H) / 2
                  )}px)`
                : `translateZ(${Ge}px)`;
            let Se = ee.current.matrixWorld;
            u &&
              ((Se = b.matrixWorldInverse
                .clone()
                .transpose()
                .copyPosition(Se)
                .scale(ee.current.scale)),
              (Se.elements[3] = Se.elements[7] = Se.elements[11] = 0),
              (Se.elements[15] = 1)),
              (K.style.width = z.width + "px"),
              (K.style.height = z.height + "px"),
              (K.style.perspective = Ze ? "" : `${Ge}px`),
              k.current &&
                U.current &&
                ((k.current.style.transform = `${we}${ce}translate(${We}px,${Oe}px)`),
                (U.current.style.transform = j5(Se, 1 / ((l || 10) / 400))));
          } else {
            const We = l === void 0 ? 1 : G5(ee.current, b) * l;
            K.style.transform = `translate3d(${Me[0]}px,${Me[1]}px,0) scale(${We})`;
          }
          (G.current = Me), (I.current = b.zoom);
        }
      }
      if (!xe && he.current && !ae.current)
        if (h) {
          if (k.current) {
            const Me = k.current.children[0];
            if (Me != null && Me.clientWidth && Me != null && Me.clientHeight) {
              const { isOrthographicCamera: V } = b;
              if (V || A)
                R.scale &&
                  (Array.isArray(R.scale)
                    ? R.scale instanceof F
                      ? he.current.scale.copy(R.scale.clone().divideScalar(1))
                      : he.current.scale.set(
                          1 / R.scale[0],
                          1 / R.scale[1],
                          1 / R.scale[2]
                        )
                    : he.current.scale.setScalar(1 / R.scale));
              else {
                const ye = (l || 10) / 400,
                  me = Me.clientWidth * ye,
                  Ee = Me.clientHeight * ye;
                he.current.scale.set(me, Ee, 1);
              }
              ae.current = !0;
            }
          }
        } else {
          const Me = K.children[0];
          if (Me != null && Me.clientWidth && Me != null && Me.clientHeight) {
            const V = 1 / Y.factor,
              ye = Me.clientWidth * V,
              me = Me.clientHeight * V;
            he.current.scale.set(ye, me, 1), (ae.current = !0);
          }
          he.current.lookAt(tt.camera.position);
        }
    });
    const ct = W.useMemo(
      () => ({
        vertexShader: h
          ? void 0
          : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `,
      }),
      [h]
    );
    return W.createElement(
      "group",
      Kr({}, R, { ref: ee }),
      d &&
        !xe &&
        W.createElement(
          "mesh",
          { castShadow: m, receiveShadow: y, ref: he },
          A || W.createElement("planeGeometry", null),
          M ||
            W.createElement("shaderMaterial", {
              side: Ar,
              vertexShader: ct.vertexShader,
              fragmentShader: ct.fragmentShader,
            })
        )
    );
  }
);
let Zu = 0;
const K5 = sL(
  (n) => (
    (_c.onStart = (e, t, i) => {
      n({
        active: !0,
        item: e,
        loaded: t,
        total: i,
        progress: ((t - Zu) / (i - Zu)) * 100,
      });
    }),
    (_c.onLoad = () => {
      n({ active: !1 });
    }),
    (_c.onError = (e) => n((t) => ({ errors: [...t.errors, e] }))),
    (_c.onProgress = (e, t, i) => {
      t === i && (Zu = i),
        n({
          active: !0,
          item: e,
          loaded: t,
          total: i,
          progress: ((t - Zu) / (i - Zu)) * 100 || 100,
        });
    }),
    { errors: [], active: !1, progress: 0, item: "", loaded: 0, total: 0 }
  )
);
function RL(n) {
  return function (e) {
    n.forEach(function (t) {
      typeof t == "function" ? t(e) : t != null && (t.current = e);
    });
  };
}
function dC(n, e) {
  if (e === X2)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      n
    );
  if (e === Qm || e === y1) {
    let t = n.getIndex();
    if (t === null) {
      const o = [],
        a = n.getAttribute("position");
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++) o.push(l);
        n.setIndex(o), (t = n.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          n
        );
    }
    const i = t.count - 2,
      r = [];
    if (t)
      if (e === Qm)
        for (let o = 1; o <= i; o++)
          r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1));
      else
        for (let o = 0; o < i; o++)
          o % 2 === 0
            ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2)))
            : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o)));
    r.length / 3 !== i &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const s = n.clone();
    return s.setIndex(r), s.clearGroups(), s;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      n
    );
}
var Y5 = Object.defineProperty,
  Q5 = (n, e, t) =>
    e in n
      ? Y5(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  pt = (n, e, t) => (Q5(n, typeof e != "symbol" ? e + "" : e, t), t);
const pC = (n, e) => ((n % e) + e) % e;
let q5 = class extends Ss {
  constructor(e, t) {
    super(),
      pt(this, "object"),
      pt(this, "domElement"),
      pt(this, "enabled", !0),
      pt(this, "target", new F()),
      pt(this, "minDistance", 0),
      pt(this, "maxDistance", 1 / 0),
      pt(this, "minZoom", 0),
      pt(this, "maxZoom", 1 / 0),
      pt(this, "minPolarAngle", 0),
      pt(this, "maxPolarAngle", Math.PI),
      pt(this, "minAzimuthAngle", -1 / 0),
      pt(this, "maxAzimuthAngle", 1 / 0),
      pt(this, "enableDamping", !1),
      pt(this, "dampingFactor", 0.05),
      pt(this, "enableZoom", !0),
      pt(this, "zoomSpeed", 1),
      pt(this, "enableRotate", !0),
      pt(this, "rotateSpeed", 1),
      pt(this, "enablePan", !0),
      pt(this, "panSpeed", 1),
      pt(this, "screenSpacePanning", !0),
      pt(this, "keyPanSpeed", 7),
      pt(this, "autoRotate", !1),
      pt(this, "autoRotateSpeed", 2),
      pt(this, "reverseOrbit", !1),
      pt(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      pt(this, "mouseButtons", {
        LEFT: Pa.ROTATE,
        MIDDLE: Pa.DOLLY,
        RIGHT: Pa.PAN,
      }),
      pt(this, "touches", { ONE: Ba.ROTATE, TWO: Ba.DOLLY_PAN }),
      pt(this, "target0"),
      pt(this, "position0"),
      pt(this, "zoom0"),
      pt(this, "_domElementKeyEvents", null),
      pt(this, "getPolarAngle"),
      pt(this, "getAzimuthalAngle"),
      pt(this, "setPolarAngle"),
      pt(this, "setAzimuthalAngle"),
      pt(this, "getDistance"),
      pt(this, "listenToKeyEvents"),
      pt(this, "saveState"),
      pt(this, "reset"),
      pt(this, "update"),
      pt(this, "connect"),
      pt(this, "dispose"),
      (this.object = e),
      (this.domElement = t),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => h.phi),
      (this.getAzimuthalAngle = () => h.theta),
      (this.setPolarAngle = (J) => {
        let fe = pC(J, 2 * Math.PI),
          Te = h.phi;
        Te < 0 && (Te += 2 * Math.PI), fe < 0 && (fe += 2 * Math.PI);
        let be = Math.abs(fe - Te);
        2 * Math.PI - be < be &&
          (fe < Te ? (fe += 2 * Math.PI) : (Te += 2 * Math.PI)),
          (d.phi = fe - Te),
          i.update();
      }),
      (this.setAzimuthalAngle = (J) => {
        let fe = pC(J, 2 * Math.PI),
          Te = h.theta;
        Te < 0 && (Te += 2 * Math.PI), fe < 0 && (fe += 2 * Math.PI);
        let be = Math.abs(fe - Te);
        2 * Math.PI - be < be &&
          (fe < Te ? (fe += 2 * Math.PI) : (Te += 2 * Math.PI)),
          (d.theta = fe - Te),
          i.update();
      }),
      (this.getDistance = () => i.object.position.distanceTo(i.target)),
      (this.listenToKeyEvents = (J) => {
        J.addEventListener("keydown", D), (this._domElementKeyEvents = J);
      }),
      (this.saveState = () => {
        i.target0.copy(i.target),
          i.position0.copy(i.object.position),
          (i.zoom0 = i.object.zoom);
      }),
      (this.reset = () => {
        i.target.copy(i.target0),
          i.object.position.copy(i.position0),
          (i.object.zoom = i.zoom0),
          i.object.updateProjectionMatrix(),
          i.dispatchEvent(r),
          i.update(),
          (l = a.NONE);
      }),
      (this.update = (() => {
        const J = new F(),
          fe = new Wn().setFromUnitVectors(e.up, new F(0, 1, 0)),
          Te = fe.clone().invert(),
          be = new F(),
          De = new Wn(),
          nt = 2 * Math.PI;
        return function () {
          const Q = i.object.position;
          J.copy(Q).sub(i.target),
            J.applyQuaternion(fe),
            h.setFromVector3(J),
            i.autoRotate && l === a.NONE && $(L()),
            i.enableDamping
              ? ((h.theta += d.theta * i.dampingFactor),
                (h.phi += d.phi * i.dampingFactor))
              : ((h.theta += d.theta), (h.phi += d.phi));
          let Pe = i.minAzimuthAngle,
            oe = i.maxAzimuthAngle;
          return (
            isFinite(Pe) &&
              isFinite(oe) &&
              (Pe < -Math.PI ? (Pe += nt) : Pe > Math.PI && (Pe -= nt),
              oe < -Math.PI ? (oe += nt) : oe > Math.PI && (oe -= nt),
              Pe <= oe
                ? (h.theta = Math.max(Pe, Math.min(oe, h.theta)))
                : (h.theta =
                    h.theta > (Pe + oe) / 2
                      ? Math.max(Pe, h.theta)
                      : Math.min(oe, h.theta))),
            (h.phi = Math.max(
              i.minPolarAngle,
              Math.min(i.maxPolarAngle, h.phi)
            )),
            h.makeSafe(),
            (h.radius *= p),
            (h.radius = Math.max(
              i.minDistance,
              Math.min(i.maxDistance, h.radius)
            )),
            i.enableDamping === !0
              ? i.target.addScaledVector(m, i.dampingFactor)
              : i.target.add(m),
            J.setFromSpherical(h),
            J.applyQuaternion(Te),
            Q.copy(i.target).add(J),
            i.object.lookAt(i.target),
            i.enableDamping === !0
              ? ((d.theta *= 1 - i.dampingFactor),
                (d.phi *= 1 - i.dampingFactor),
                m.multiplyScalar(1 - i.dampingFactor))
              : (d.set(0, 0, 0), m.set(0, 0, 0)),
            (p = 1),
            y ||
            be.distanceToSquared(i.object.position) > u ||
            8 * (1 - De.dot(i.object.quaternion)) > u
              ? (i.dispatchEvent(r),
                be.copy(i.object.position),
                De.copy(i.object.quaternion),
                (y = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (J) => {
        J === document &&
          console.error(
            'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
          ),
          (i.domElement = J),
          (i.domElement.style.touchAction = "none"),
          i.domElement.addEventListener("contextmenu", Se),
          i.domElement.addEventListener("pointerdown", We),
          i.domElement.addEventListener("pointercancel", Ze),
          i.domElement.addEventListener("wheel", H);
      }),
      (this.dispose = () => {
        var J, fe, Te, be, De, nt;
        (J = i.domElement) == null || J.removeEventListener("contextmenu", Se),
          (fe = i.domElement) == null ||
            fe.removeEventListener("pointerdown", We),
          (Te = i.domElement) == null ||
            Te.removeEventListener("pointercancel", Ze),
          (be = i.domElement) == null || be.removeEventListener("wheel", H),
          (De = i.domElement) == null ||
            De.ownerDocument.removeEventListener("pointermove", Oe),
          (nt = i.domElement) == null ||
            nt.ownerDocument.removeEventListener("pointerup", Ge),
          i._domElementKeyEvents !== null &&
            i._domElementKeyEvents.removeEventListener("keydown", D);
      });
    const i = this,
      r = { type: "change" },
      s = { type: "start" },
      o = { type: "end" },
      a = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let l = a.NONE;
    const u = 1e-6,
      h = new z_(),
      d = new z_();
    let p = 1;
    const m = new F();
    let y = !1;
    const M = new ve(),
      A = new ve(),
      g = new ve(),
      x = new ve(),
      _ = new ve(),
      E = new ve(),
      T = new ve(),
      R = new ve(),
      P = new ve(),
      B = [],
      b = {};
    function L() {
      return ((2 * Math.PI) / 60 / 60) * i.autoRotateSpeed;
    }
    function z() {
      return Math.pow(0.95, i.zoomSpeed);
    }
    function $(J) {
      i.reverseOrbit ? (d.theta += J) : (d.theta -= J);
    }
    function X(J) {
      i.reverseOrbit ? (d.phi += J) : (d.phi -= J);
    }
    const Y = (() => {
        const J = new F();
        return function (Te, be) {
          J.setFromMatrixColumn(be, 0), J.multiplyScalar(-Te), m.add(J);
        };
      })(),
      K = (() => {
        const J = new F();
        return function (Te, be) {
          i.screenSpacePanning === !0
            ? J.setFromMatrixColumn(be, 1)
            : (J.setFromMatrixColumn(be, 0), J.crossVectors(i.object.up, J)),
            J.multiplyScalar(Te),
            m.add(J);
        };
      })(),
      ie = (() => {
        const J = new F();
        return function (Te, be) {
          const De = i.domElement;
          if (De && i.object instanceof $t && i.object.isPerspectiveCamera) {
            const nt = i.object.position;
            J.copy(nt).sub(i.target);
            let Pt = J.length();
            (Pt *= Math.tan(((i.object.fov / 2) * Math.PI) / 180)),
              Y((2 * Te * Pt) / De.clientHeight, i.object.matrix),
              K((2 * be * Pt) / De.clientHeight, i.object.matrix);
          } else
            De && i.object instanceof Wr && i.object.isOrthographicCamera
              ? (Y(
                  (Te * (i.object.right - i.object.left)) /
                    i.object.zoom /
                    De.clientWidth,
                  i.object.matrix
                ),
                K(
                  (be * (i.object.top - i.object.bottom)) /
                    i.object.zoom /
                    De.clientHeight,
                  i.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (i.enablePan = !1));
        };
      })();
    function ee(J) {
      i.object instanceof $t && i.object.isPerspectiveCamera
        ? (p /= J)
        : i.object instanceof Wr && i.object.isOrthographicCamera
        ? ((i.object.zoom = Math.max(
            i.minZoom,
            Math.min(i.maxZoom, i.object.zoom * J)
          )),
          i.object.updateProjectionMatrix(),
          (y = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (i.enableZoom = !1));
    }
    function I(J) {
      i.object instanceof $t && i.object.isPerspectiveCamera
        ? (p *= J)
        : i.object instanceof Wr && i.object.isOrthographicCamera
        ? ((i.object.zoom = Math.max(
            i.minZoom,
            Math.min(i.maxZoom, i.object.zoom / J)
          )),
          i.object.updateProjectionMatrix(),
          (y = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (i.enableZoom = !1));
    }
    function G(J) {
      M.set(J.clientX, J.clientY);
    }
    function k(J) {
      T.set(J.clientX, J.clientY);
    }
    function U(J) {
      x.set(J.clientX, J.clientY);
    }
    function j(J) {
      A.set(J.clientX, J.clientY),
        g.subVectors(A, M).multiplyScalar(i.rotateSpeed);
      const fe = i.domElement;
      fe &&
        ($((2 * Math.PI * g.x) / fe.clientHeight),
        X((2 * Math.PI * g.y) / fe.clientHeight)),
        M.copy(A),
        i.update();
    }
    function he(J) {
      R.set(J.clientX, J.clientY),
        P.subVectors(R, T),
        P.y > 0 ? ee(z()) : P.y < 0 && I(z()),
        T.copy(R),
        i.update();
    }
    function ae(J) {
      _.set(J.clientX, J.clientY),
        E.subVectors(_, x).multiplyScalar(i.panSpeed),
        ie(E.x, E.y),
        x.copy(_),
        i.update();
    }
    function xe(J) {
      J.deltaY < 0 ? I(z()) : J.deltaY > 0 && ee(z()), i.update();
    }
    function Ae(J) {
      let fe = !1;
      switch (J.code) {
        case i.keys.UP:
          ie(0, i.keyPanSpeed), (fe = !0);
          break;
        case i.keys.BOTTOM:
          ie(0, -i.keyPanSpeed), (fe = !0);
          break;
        case i.keys.LEFT:
          ie(i.keyPanSpeed, 0), (fe = !0);
          break;
        case i.keys.RIGHT:
          ie(-i.keyPanSpeed, 0), (fe = !0);
          break;
      }
      fe && (J.preventDefault(), i.update());
    }
    function Le() {
      if (B.length == 1) M.set(B[0].pageX, B[0].pageY);
      else {
        const J = 0.5 * (B[0].pageX + B[1].pageX),
          fe = 0.5 * (B[0].pageY + B[1].pageY);
        M.set(J, fe);
      }
    }
    function Ve() {
      if (B.length == 1) x.set(B[0].pageX, B[0].pageY);
      else {
        const J = 0.5 * (B[0].pageX + B[1].pageX),
          fe = 0.5 * (B[0].pageY + B[1].pageY);
        x.set(J, fe);
      }
    }
    function ct() {
      const J = B[0].pageX - B[1].pageX,
        fe = B[0].pageY - B[1].pageY,
        Te = Math.sqrt(J * J + fe * fe);
      T.set(0, Te);
    }
    function tt() {
      i.enableZoom && ct(), i.enablePan && Ve();
    }
    function Me() {
      i.enableZoom && ct(), i.enableRotate && Le();
    }
    function V(J) {
      if (B.length == 1) A.set(J.pageX, J.pageY);
      else {
        const Te = de(J),
          be = 0.5 * (J.pageX + Te.x),
          De = 0.5 * (J.pageY + Te.y);
        A.set(be, De);
      }
      g.subVectors(A, M).multiplyScalar(i.rotateSpeed);
      const fe = i.domElement;
      fe &&
        ($((2 * Math.PI * g.x) / fe.clientHeight),
        X((2 * Math.PI * g.y) / fe.clientHeight)),
        M.copy(A);
    }
    function ye(J) {
      if (B.length == 1) _.set(J.pageX, J.pageY);
      else {
        const fe = de(J),
          Te = 0.5 * (J.pageX + fe.x),
          be = 0.5 * (J.pageY + fe.y);
        _.set(Te, be);
      }
      E.subVectors(_, x).multiplyScalar(i.panSpeed), ie(E.x, E.y), x.copy(_);
    }
    function me(J) {
      const fe = de(J),
        Te = J.pageX - fe.x,
        be = J.pageY - fe.y,
        De = Math.sqrt(Te * Te + be * be);
      R.set(0, De),
        P.set(0, Math.pow(R.y / T.y, i.zoomSpeed)),
        ee(P.y),
        T.copy(R);
    }
    function Ee(J) {
      i.enableZoom && me(J), i.enablePan && ye(J);
    }
    function _e(J) {
      i.enableZoom && me(J), i.enableRotate && V(J);
    }
    function We(J) {
      var fe, Te;
      i.enabled !== !1 &&
        (B.length === 0 &&
          ((fe = i.domElement) == null ||
            fe.ownerDocument.addEventListener("pointermove", Oe),
          (Te = i.domElement) == null ||
            Te.ownerDocument.addEventListener("pointerup", Ge)),
        Fe(J),
        J.pointerType === "touch" ? ce(J) : vt(J));
    }
    function Oe(J) {
      i.enabled !== !1 && (J.pointerType === "touch" ? we(J) : kt(J));
    }
    function Ge(J) {
      var fe, Te, be;
      Ke(J),
        B.length === 0 &&
          ((fe = i.domElement) == null || fe.releasePointerCapture(J.pointerId),
          (Te = i.domElement) == null ||
            Te.ownerDocument.removeEventListener("pointermove", Oe),
          (be = i.domElement) == null ||
            be.ownerDocument.removeEventListener("pointerup", Ge)),
        i.dispatchEvent(o),
        (l = a.NONE);
    }
    function Ze(J) {
      Ke(J);
    }
    function vt(J) {
      let fe;
      switch (J.button) {
        case 0:
          fe = i.mouseButtons.LEFT;
          break;
        case 1:
          fe = i.mouseButtons.MIDDLE;
          break;
        case 2:
          fe = i.mouseButtons.RIGHT;
          break;
        default:
          fe = -1;
      }
      switch (fe) {
        case Pa.DOLLY:
          if (i.enableZoom === !1) return;
          k(J), (l = a.DOLLY);
          break;
        case Pa.ROTATE:
          if (J.ctrlKey || J.metaKey || J.shiftKey) {
            if (i.enablePan === !1) return;
            U(J), (l = a.PAN);
          } else {
            if (i.enableRotate === !1) return;
            G(J), (l = a.ROTATE);
          }
          break;
        case Pa.PAN:
          if (J.ctrlKey || J.metaKey || J.shiftKey) {
            if (i.enableRotate === !1) return;
            G(J), (l = a.ROTATE);
          } else {
            if (i.enablePan === !1) return;
            U(J), (l = a.PAN);
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && i.dispatchEvent(s);
    }
    function kt(J) {
      if (i.enabled !== !1)
        switch (l) {
          case a.ROTATE:
            if (i.enableRotate === !1) return;
            j(J);
            break;
          case a.DOLLY:
            if (i.enableZoom === !1) return;
            he(J);
            break;
          case a.PAN:
            if (i.enablePan === !1) return;
            ae(J);
            break;
        }
    }
    function H(J) {
      i.enabled === !1 ||
        i.enableZoom === !1 ||
        (l !== a.NONE && l !== a.ROTATE) ||
        (J.preventDefault(), i.dispatchEvent(s), xe(J), i.dispatchEvent(o));
    }
    function D(J) {
      i.enabled === !1 || i.enablePan === !1 || Ae(J);
    }
    function ce(J) {
      switch ((Ie(J), B.length)) {
        case 1:
          switch (i.touches.ONE) {
            case Ba.ROTATE:
              if (i.enableRotate === !1) return;
              Le(), (l = a.TOUCH_ROTATE);
              break;
            case Ba.PAN:
              if (i.enablePan === !1) return;
              Ve(), (l = a.TOUCH_PAN);
              break;
            default:
              l = a.NONE;
          }
          break;
        case 2:
          switch (i.touches.TWO) {
            case Ba.DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1) return;
              tt(), (l = a.TOUCH_DOLLY_PAN);
              break;
            case Ba.DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1) return;
              Me(), (l = a.TOUCH_DOLLY_ROTATE);
              break;
            default:
              l = a.NONE;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && i.dispatchEvent(s);
    }
    function we(J) {
      switch ((Ie(J), l)) {
        case a.TOUCH_ROTATE:
          if (i.enableRotate === !1) return;
          V(J), i.update();
          break;
        case a.TOUCH_PAN:
          if (i.enablePan === !1) return;
          ye(J), i.update();
          break;
        case a.TOUCH_DOLLY_PAN:
          if (i.enableZoom === !1 && i.enablePan === !1) return;
          Ee(J), i.update();
          break;
        case a.TOUCH_DOLLY_ROTATE:
          if (i.enableZoom === !1 && i.enableRotate === !1) return;
          _e(J), i.update();
          break;
        default:
          l = a.NONE;
      }
    }
    function Se(J) {
      i.enabled !== !1 && J.preventDefault();
    }
    function Fe(J) {
      B.push(J);
    }
    function Ke(J) {
      delete b[J.pointerId];
      for (let fe = 0; fe < B.length; fe++)
        if (B[fe].pointerId == J.pointerId) {
          B.splice(fe, 1);
          return;
        }
    }
    function Ie(J) {
      let fe = b[J.pointerId];
      fe === void 0 && ((fe = new ve()), (b[J.pointerId] = fe)),
        fe.set(J.pageX, J.pageY);
    }
    function de(J) {
      const fe = J.pointerId === B[0].pointerId ? B[1] : B[0];
      return b[fe.pointerId];
    }
    t !== void 0 && this.connect(t), this.update();
  }
};
class lS extends ui {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new n9(t);
      }),
      this.register(function (t) {
        return new u9(t);
      }),
      this.register(function (t) {
        return new f9(t);
      }),
      this.register(function (t) {
        return new h9(t);
      }),
      this.register(function (t) {
        return new r9(t);
      }),
      this.register(function (t) {
        return new s9(t);
      }),
      this.register(function (t) {
        return new o9(t);
      }),
      this.register(function (t) {
        return new a9(t);
      }),
      this.register(function (t) {
        return new t9(t);
      }),
      this.register(function (t) {
        return new l9(t);
      }),
      this.register(function (t) {
        return new i9(t);
      }),
      this.register(function (t) {
        return new c9(t);
      }),
      this.register(function (t) {
        return new $5(t);
      }),
      this.register(function (t) {
        return new d9(t);
      }),
      this.register(function (t) {
        return new p9(t);
      });
  }
  load(e, t, i, r) {
    const s = this;
    let o;
    this.resourcePath !== ""
      ? (o = this.resourcePath)
      : this.path !== ""
      ? (o = this.path)
      : (o = vs.extractUrlBase(e)),
      this.manager.itemStart(e);
    const a = function (u) {
        r ? r(u) : console.error(u),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      l = new $i(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (u) {
          try {
            s.parse(
              u,
              o,
              function (h) {
                t(h), s.manager.itemEnd(e);
              },
              a
            );
          } catch (h) {
            a(h);
          }
        },
        i,
        a
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, i, r) {
    let s;
    const o = {},
      a = {};
    if (typeof e == "string") s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (vs.decodeText(new Uint8Array(e.slice(0, 4))) === PL) {
        try {
          o[Ct.KHR_BINARY_GLTF] = new m9(e);
        } catch (h) {
          r && r(h);
          return;
        }
        s = JSON.parse(o[Ct.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(vs.decodeText(new Uint8Array(e)));
    else s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      r &&
        r(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const l = new b9(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const h = this.pluginCallbacks[u](l);
      (a[h.name] = h), (o[h.name] = !0);
    }
    if (s.extensionsUsed)
      for (let u = 0; u < s.extensionsUsed.length; ++u) {
        const h = s.extensionsUsed[u],
          d = s.extensionsRequired || [];
        switch (h) {
          case Ct.KHR_MATERIALS_UNLIT:
            o[h] = new e9();
            break;
          case Ct.KHR_DRACO_MESH_COMPRESSION:
            o[h] = new g9(s, this.dracoLoader);
            break;
          case Ct.KHR_TEXTURE_TRANSFORM:
            o[h] = new v9();
            break;
          case Ct.KHR_MESH_QUANTIZATION:
            o[h] = new y9();
            break;
          default:
            d.indexOf(h) >= 0 &&
              a[h] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    l.setExtensions(o), l.setPlugins(a), l.parse(i, r);
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.parse(e, t, r, s);
    });
  }
}
function Z5() {
  let n = {};
  return {
    get: function (e) {
      return n[e];
    },
    add: function (e, t) {
      n[e] = t;
    },
    remove: function (e) {
      delete n[e];
    },
    removeAll: function () {
      n = {};
    },
  };
}
const Ct = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class $5 {
  constructor(e) {
    (this.parser = e),
      (this.name = Ct.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      s.extensions &&
        s.extensions[this.name] &&
        s.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      i = "light:" + e;
    let r = t.cache.get(i);
    if (r) return r;
    const s = t.json,
      l = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let u;
    const h = new Ue(16777215);
    l.color !== void 0 && h.fromArray(l.color);
    const d = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        (u = new Z1(h)), u.target.position.set(0, 0, -1), u.add(u.target);
        break;
      case "point":
        (u = new q1(h)), (u.distance = d);
        break;
      case "spot":
        (u = new Q1(h)),
          (u.distance = d),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle =
            l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0
              ? l.spot.outerConeAngle
              : Math.PI / 4),
          (u.angle = l.spot.outerConeAngle),
          (u.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          u.target.position.set(0, 0, -1),
          u.add(u.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return (
      u.position.set(0, 0, 0),
      (u.decay = 2),
      Eo(u, l),
      l.intensity !== void 0 && (u.intensity = l.intensity),
      (u.name = t.createUniqueName(l.name || "light_" + e)),
      (r = Promise.resolve(u)),
      t.cache.add(i, r),
      r
    );
  }
  getDependency(e, t) {
    if (e === "light") return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      i = this.parser,
      s = i.json.nodes[e],
      a = ((s.extensions && s.extensions[this.name]) || {}).light;
    return a === void 0
      ? null
      : this._loadLight(a).then(function (l) {
          return i._getNodeRef(t.cache, a, l);
        });
  }
}
class e9 {
  constructor() {
    this.name = Ct.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Ji;
  }
  extendParams(e, t, i) {
    const r = [];
    (e.color = new Ue(1, 1, 1)), (e.opacity = 1);
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const o = s.baseColorFactor;
        e.color.fromArray(o), (e.opacity = o[3]);
      }
      s.baseColorTexture !== void 0 &&
        r.push(i.assignTexture(e, "map", s.baseColorTexture, 3001));
    }
    return Promise.all(r);
  }
}
class t9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name].emissiveStrength;
    return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
  }
}
class n9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Ms;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    if (
      (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
      o.clearcoatTexture !== void 0 &&
        s.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
      o.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
      o.clearcoatRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            t,
            "clearcoatRoughnessMap",
            o.clearcoatRoughnessTexture
          )
        ),
      o.clearcoatNormalTexture !== void 0 &&
        (s.push(
          i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)
        ),
        o.clearcoatNormalTexture.scale !== void 0))
    ) {
      const a = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new ve(a, a);
    }
    return Promise.all(s);
  }
}
class i9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Ms;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
      o.iridescenceTexture !== void 0 &&
        s.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
      o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      o.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
      o.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
      o.iridescenceThicknessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            t,
            "iridescenceThicknessMap",
            o.iridescenceThicknessTexture
          )
        ),
      Promise.all(s)
    );
  }
}
class r9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Ms;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [];
    (t.sheenColor = new Ue(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const o = r.extensions[this.name];
    return (
      o.sheenColorFactor !== void 0 &&
        t.sheenColor.fromArray(o.sheenColorFactor),
      o.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = o.sheenRoughnessFactor),
      o.sheenColorTexture !== void 0 &&
        s.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, 3001)),
      o.sheenRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)
        ),
      Promise.all(s)
    );
  }
}
class s9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Ms;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.transmissionFactor !== void 0 &&
        (t.transmission = o.transmissionFactor),
      o.transmissionTexture !== void 0 &&
        s.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class o9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Ms;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    (t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
      o.thicknessTexture !== void 0 &&
        s.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)),
      (t.attenuationDistance = o.attenuationDistance || 1 / 0);
    const a = o.attenuationColor || [1, 1, 1];
    return (t.attenuationColor = new Ue(a[0], a[1], a[2])), Promise.all(s);
  }
}
class a9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Ms;
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name];
    return (t.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve();
  }
}
class l9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Ms;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    (t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1),
      o.specularTexture !== void 0 &&
        s.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const a = o.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new Ue(a[0], a[1], a[2])),
      o.specularColorTexture !== void 0 &&
        s.push(
          i.assignTexture(t, "specularColorMap", o.specularColorTexture, 3001)
        ),
      Promise.all(s)
    );
  }
}
class c9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Ms;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength),
      o.anisotropyRotation !== void 0 &&
        (t.anisotropyRotation = o.anisotropyRotation),
      o.anisotropyTexture !== void 0 &&
        s.push(i.assignTexture(t, "anisotropyMap", o.anisotropyTexture)),
      Promise.all(s)
    );
  }
}
class u9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      i = t.json,
      r = i.textures[e];
    if (!r.extensions || !r.extensions[this.name]) return null;
    const s = r.extensions[this.name],
      o = t.options.ktx2Loader;
    if (!o) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, s.source, o);
  }
}
class f9 {
  constructor(e) {
    (this.parser = e),
      (this.name = Ct.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      r = i.json,
      s = r.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const o = s.extensions[t],
      a = r.images[o.source];
    let l = i.textureLoader;
    if (a.uri) {
      const u = i.options.manager.getHandler(a.uri);
      u !== null && (l = u);
    }
    return this.detectSupport().then(function (u) {
      if (u) return i.loadTextureImage(e, o.source, l);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class h9 {
  constructor(e) {
    (this.parser = e),
      (this.name = Ct.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      r = i.json,
      s = r.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const o = s.extensions[t],
      a = r.images[o.source];
    let l = i.textureLoader;
    if (a.uri) {
      const u = i.options.manager.getHandler(a.uri);
      u !== null && (l = u);
    }
    return this.detectSupport().then(function (u) {
      if (u) return i.loadTextureImage(e, o.source, l);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class d9 {
  constructor(e) {
    (this.name = Ct.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const r = i.extensions[this.name],
        s = this.parser.getDependency("buffer", r.buffer),
        o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return s.then(function (a) {
        const l = r.byteOffset || 0,
          u = r.byteLength || 0,
          h = r.count,
          d = r.byteStride,
          p = new Uint8Array(a, l, u);
        return o.decodeGltfBufferAsync
          ? o
              .decodeGltfBufferAsync(h, d, p, r.mode, r.filter)
              .then(function (m) {
                return m.buffer;
              })
          : o.ready.then(function () {
              const m = new ArrayBuffer(h * d);
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(m),
                  h,
                  d,
                  p,
                  r.mode,
                  r.filter
                ),
                m
              );
            });
      });
    } else return null;
  }
}
class p9 {
  constructor(e) {
    (this.name = Ct.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      i = t.nodes[e];
    if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
      return null;
    const r = t.meshes[i.mesh];
    for (const u of r.primitives)
      if (
        u.mode !== gr.TRIANGLES &&
        u.mode !== gr.TRIANGLE_STRIP &&
        u.mode !== gr.TRIANGLE_FAN &&
        u.mode !== void 0
      )
        return null;
    const o = i.extensions[this.name].attributes,
      a = [],
      l = {};
    for (const u in o)
      a.push(
        this.parser
          .getDependency("accessor", o[u])
          .then((h) => ((l[u] = h), l[u]))
      );
    return a.length < 1
      ? null
      : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then((u) => {
          const h = u.pop(),
            d = h.isGroup ? h.children : [h],
            p = u[0].count,
            m = [];
          for (const y of d) {
            const M = new rt(),
              A = new F(),
              g = new Wn(),
              x = new F(1, 1, 1),
              _ = new D1(y.geometry, y.material, p);
            for (let E = 0; E < p; E++)
              l.TRANSLATION && A.fromBufferAttribute(l.TRANSLATION, E),
                l.ROTATION && g.fromBufferAttribute(l.ROTATION, E),
                l.SCALE && x.fromBufferAttribute(l.SCALE, E),
                _.setMatrixAt(E, M.compose(A, g, x));
            for (const E in l)
              E !== "TRANSLATION" &&
                E !== "ROTATION" &&
                E !== "SCALE" &&
                y.geometry.setAttribute(E, l[E]);
            Rt.prototype.copy.call(_, y),
              this.parser.assignFinalMaterial(_),
              m.push(_);
          }
          return h.isGroup ? (h.clear(), h.add(...m), h) : m[0];
        }));
  }
}
const PL = "glTF",
  $u = 12,
  mC = { JSON: 1313821514, BIN: 5130562 };
class m9 {
  constructor(e) {
    (this.name = Ct.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, $u);
    if (
      ((this.header = {
        magic: vs.decodeText(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== PL)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - $u,
      r = new DataView(e, $u);
    let s = 0;
    for (; s < i; ) {
      const o = r.getUint32(s, !0);
      s += 4;
      const a = r.getUint32(s, !0);
      if (((s += 4), a === mC.JSON)) {
        const l = new Uint8Array(e, $u + s, o);
        this.content = vs.decodeText(l);
      } else if (a === mC.BIN) {
        const l = $u + s;
        this.body = e.slice(l, l + o);
      }
      s += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class g9 {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = Ct.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const i = this.json,
      r = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      o = e.extensions[this.name].attributes,
      a = {},
      l = {},
      u = {};
    for (const h in o) {
      const d = X_[h] || h.toLowerCase();
      a[d] = o[h];
    }
    for (const h in e.attributes) {
      const d = X_[h] || h.toLowerCase();
      if (o[h] !== void 0) {
        const p = i.accessors[e.attributes[h]],
          m = Fc[p.componentType];
        (u[d] = m.name), (l[d] = p.normalized === !0);
      }
    }
    return t.getDependency("bufferView", s).then(function (h) {
      return new Promise(function (d) {
        r.decodeDracoFile(
          h,
          function (p) {
            for (const m in p.attributes) {
              const y = p.attributes[m],
                M = l[m];
              M !== void 0 && (y.normalized = M);
            }
            d(p);
          },
          a,
          u
        );
      });
    });
  }
}
class v9 {
  constructor() {
    this.name = Ct.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class y9 {
  constructor() {
    this.name = Ct.KHR_MESH_QUANTIZATION;
  }
}
class BL extends uu {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r * 3 + r;
    for (let o = 0; o !== r; o++) t[o] = i[s + o];
    return t;
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = a * 2,
      u = a * 3,
      h = r - t,
      d = (i - t) / h,
      p = d * d,
      m = p * d,
      y = e * u,
      M = y - u,
      A = -2 * m + 3 * p,
      g = m - p,
      x = 1 - A,
      _ = g - p + d;
    for (let E = 0; E !== a; E++) {
      const T = o[M + E + a],
        R = o[M + E + l] * h,
        P = o[y + E + a],
        B = o[y + E] * h;
      s[E] = x * T + _ * R + A * P + g * B;
    }
    return s;
  }
}
const x9 = new Wn();
class _9 extends BL {
  interpolate_(e, t, i, r) {
    const s = super.interpolate_(e, t, i, r);
    return x9.fromArray(s).normalize().toArray(s), s;
  }
}
const gr = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  Fc = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  gC = { 9728: gn, 9729: sn, 9984: $f, 9985: Dg, 9986: Lc, 9987: _s },
  vC = { 33071: Kn, 33648: jc, 10497: Yo },
  zy = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  X_ = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    ...(Sh.replace(/\D+/g, "") >= 152
      ? {
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv1",
          TEXCOORD_2: "uv2",
          TEXCOORD_3: "uv3",
        }
      : { TEXCOORD_0: "uv", TEXCOORD_1: "uv2" }),
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  xo = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  A9 = { CUBICSPLINE: void 0, LINEAR: al, STEP: Jc },
  Gy = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function S9(n) {
  return (
    n.DefaultMaterial === void 0 &&
      (n.DefaultMaterial = new Dh({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: xs,
      })),
    n.DefaultMaterial
  );
}
function wa(n, e, t) {
  for (const i in t.extensions)
    n[i] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[i] = t.extensions[i]));
}
function Eo(n, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(n.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function M9(n, e, t) {
  let i = !1,
    r = !1,
    s = !1;
  for (let u = 0, h = e.length; u < h; u++) {
    const d = e[u];
    if (
      (d.POSITION !== void 0 && (i = !0),
      d.NORMAL !== void 0 && (r = !0),
      d.COLOR_0 !== void 0 && (s = !0),
      i && r && s)
    )
      break;
  }
  if (!i && !r && !s) return Promise.resolve(n);
  const o = [],
    a = [],
    l = [];
  for (let u = 0, h = e.length; u < h; u++) {
    const d = e[u];
    if (i) {
      const p =
        d.POSITION !== void 0
          ? t.getDependency("accessor", d.POSITION)
          : n.attributes.position;
      o.push(p);
    }
    if (r) {
      const p =
        d.NORMAL !== void 0
          ? t.getDependency("accessor", d.NORMAL)
          : n.attributes.normal;
      a.push(p);
    }
    if (s) {
      const p =
        d.COLOR_0 !== void 0
          ? t.getDependency("accessor", d.COLOR_0)
          : n.attributes.color;
      l.push(p);
    }
  }
  return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(
    function (u) {
      const h = u[0],
        d = u[1],
        p = u[2];
      return (
        i && (n.morphAttributes.position = h),
        r && (n.morphAttributes.normal = d),
        s && (n.morphAttributes.color = p),
        (n.morphTargetsRelative = !0),
        n
      );
    }
  );
}
function E9(n, e) {
  if ((n.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, i = e.weights.length; t < i; t++)
      n.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (n.morphTargetInfluences.length === t.length) {
      n.morphTargetDictionary = {};
      for (let i = 0, r = t.length; i < r; i++)
        n.morphTargetDictionary[t[i]] = i;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function w9(n) {
  let e;
  const t = n.extensions && n.extensions[Ct.KHR_DRACO_MESH_COMPRESSION];
  if (
    (t
      ? (e = "draco:" + t.bufferView + ":" + t.indices + ":" + Vy(t.attributes))
      : (e = n.indices + ":" + Vy(n.attributes) + ":" + n.mode),
    n.targets !== void 0)
  )
    for (let i = 0, r = n.targets.length; i < r; i++)
      e += ":" + Vy(n.targets[i]);
  return e;
}
function Vy(n) {
  let e = "";
  const t = Object.keys(n).sort();
  for (let i = 0, r = t.length; i < r; i++) e += t[i] + ":" + n[t[i]] + ";";
  return e;
}
function J_(n) {
  switch (n) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function T9(n) {
  return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
const C9 = new rt();
class b9 {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new Z5()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let i = !1,
      r = !1,
      s = -1;
    typeof navigator < "u" &&
      typeof navigator.userAgent < "u" &&
      ((i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (r = navigator.userAgent.indexOf("Firefox") > -1),
      (s = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > "u" || i || (r && s < 98)
        ? (this.textureLoader = new jB(this.options.manager))
        : (this.textureLoader = new ZB(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new $i(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this,
      r = this.json,
      s = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (o) {
        return o._markDefs && o._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (o) {
          return o.beforeRoot && o.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            i.getDependencies("scene"),
            i.getDependencies("animation"),
            i.getDependencies("camera"),
          ]);
        })
        .then(function (o) {
          const a = {
            scene: o[0][r.scene || 0],
            scenes: o[0],
            animations: o[1],
            cameras: o[2],
            asset: r.asset,
            parser: i,
            userData: {},
          };
          wa(s, a, r),
            Eo(a, r),
            Promise.all(
              i._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(a);
              })
            ).then(function () {
              e(a);
            });
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      i = this.json.meshes || [];
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r].joints;
      for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
    }
    for (let r = 0, s = e.length; r < s; r++) {
      const o = e[r];
      o.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, o.mesh),
        o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)),
        o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    const r = i.clone(),
      s = (o, a) => {
        const l = this.associations.get(o);
        l != null && this.associations.set(a, l);
        for (const [u, h] of o.children.entries()) s(h, a.children[u]);
      };
    return s(i, r), (r.name += "_instance_" + e.uses[t]++), r;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      if (r) return r;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let r = 0; r < t.length; r++) {
      const s = e(t[r]);
      s && i.push(s);
    }
    return i;
  }
  getDependency(e, t) {
    const i = e + ":" + t;
    let r = this.cache.get(i);
    if (!r) {
      switch (e) {
        case "scene":
          r = this.loadScene(t);
          break;
        case "node":
          r = this._invokeOne(function (s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          r = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          r = this.loadAccessor(t);
          break;
        case "bufferView":
          r = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          r = this.loadBuffer(t);
          break;
        case "material":
          r = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          r = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          r = this.loadSkin(t);
          break;
        case "animation":
          r = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          r = this.loadCamera(t);
          break;
        default:
          if (
            ((r = this._invokeOne(function (s) {
              return s != this && s.getDependency && s.getDependency(e, t);
            })),
            !r)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(i, r);
    }
    return r;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this,
        r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        r.map(function (s, o) {
          return i.getDependency(e, o);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      i = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Ct.KHR_BINARY_GLTF].body);
    const r = this.options;
    return new Promise(function (s, o) {
      i.load(vs.resolveURL(t.uri, r.path), s, void 0, function () {
        o(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (i) {
      const r = t.byteLength || 0,
        s = t.byteOffset || 0;
      return i.slice(s, s + r);
    });
  }
  loadAccessor(e) {
    const t = this,
      i = this.json,
      r = this.json.accessors[e];
    if (r.bufferView === void 0 && r.sparse === void 0) {
      const o = zy[r.type],
        a = Fc[r.componentType],
        l = r.normalized === !0,
        u = new a(r.count * o);
      return Promise.resolve(new Ft(u, o, l));
    }
    const s = [];
    return (
      r.bufferView !== void 0
        ? s.push(this.getDependency("bufferView", r.bufferView))
        : s.push(null),
      r.sparse !== void 0 &&
        (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
      Promise.all(s).then(function (o) {
        const a = o[0],
          l = zy[r.type],
          u = Fc[r.componentType],
          h = u.BYTES_PER_ELEMENT,
          d = h * l,
          p = r.byteOffset || 0,
          m =
            r.bufferView !== void 0
              ? i.bufferViews[r.bufferView].byteStride
              : void 0,
          y = r.normalized === !0;
        let M, A;
        if (m && m !== d) {
          const g = Math.floor(p / m),
            x =
              "InterleavedBuffer:" +
              r.bufferView +
              ":" +
              r.componentType +
              ":" +
              g +
              ":" +
              r.count;
          let _ = t.cache.get(x);
          _ ||
            ((M = new u(a, g * m, (r.count * m) / h)),
            (_ = new bh(M, m / h)),
            t.cache.add(x, _)),
            (A = new Qo(_, l, (p % m) / h, y));
        } else a === null ? (M = new u(r.count * l)) : (M = new u(a, p, r.count * l)), (A = new Ft(M, l, y));
        if (r.sparse !== void 0) {
          const g = zy.SCALAR,
            x = Fc[r.sparse.indices.componentType],
            _ = r.sparse.indices.byteOffset || 0,
            E = r.sparse.values.byteOffset || 0,
            T = new x(o[1], _, r.sparse.count * g),
            R = new u(o[2], E, r.sparse.count * l);
          a !== null && (A = new Ft(A.array.slice(), A.itemSize, A.normalized));
          for (let P = 0, B = T.length; P < B; P++) {
            const b = T[P];
            if (
              (A.setX(b, R[P * l]),
              l >= 2 && A.setY(b, R[P * l + 1]),
              l >= 3 && A.setZ(b, R[P * l + 2]),
              l >= 4 && A.setW(b, R[P * l + 3]),
              l >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return A;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      i = this.options,
      s = t.textures[e].source,
      o = t.images[s];
    let a = this.textureLoader;
    if (o.uri) {
      const l = i.manager.getHandler(o.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, s, a);
  }
  loadTextureImage(e, t, i) {
    const r = this,
      s = this.json,
      o = s.textures[e],
      a = s.images[t],
      l = (a.uri || a.bufferView) + ":" + o.sampler;
    if (this.textureCache[l]) return this.textureCache[l];
    const u = this.loadImageSource(t, i)
      .then(function (h) {
        (h.flipY = !1),
          (h.name = o.name || a.name || ""),
          h.name === "" &&
            typeof a.uri == "string" &&
            a.uri.startsWith("data:image/") === !1 &&
            (h.name = a.uri);
        const p = (s.samplers || {})[o.sampler] || {};
        return (
          (h.magFilter = gC[p.magFilter] || sn),
          (h.minFilter = gC[p.minFilter] || _s),
          (h.wrapS = vC[p.wrapS] || Yo),
          (h.wrapT = vC[p.wrapT] || Yo),
          r.associations.set(h, { textures: e }),
          h
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[l] = u), u;
  }
  loadImageSource(e, t) {
    const i = this,
      r = this.json,
      s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((d) => d.clone());
    const o = r.images[e],
      a = self.URL || self.webkitURL;
    let l = o.uri || "",
      u = !1;
    if (o.bufferView !== void 0)
      l = i.getDependency("bufferView", o.bufferView).then(function (d) {
        u = !0;
        const p = new Blob([d], { type: o.mimeType });
        return (l = a.createObjectURL(p)), l;
      });
    else if (o.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const h = Promise.resolve(l)
      .then(function (d) {
        return new Promise(function (p, m) {
          let y = p;
          t.isImageBitmapLoader === !0 &&
            (y = function (M) {
              const A = new en(M);
              (A.needsUpdate = !0), p(A);
            }),
            t.load(vs.resolveURL(d, s.path), y, void 0, m);
        });
      })
      .then(function (d) {
        return (
          u === !0 && a.revokeObjectURL(l),
          (d.userData.mimeType = o.mimeType || T9(o.uri)),
          d
        );
      })
      .catch(function (d) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), d);
      });
    return (this.sourceCache[e] = h), h;
  }
  assignTexture(e, t, i, r) {
    const s = this;
    return this.getDependency("texture", i.index).then(function (o) {
      if (!o) return null;
      if (
        (i.texCoord !== void 0 &&
          i.texCoord > 0 &&
          ((o = o.clone()), (o.channel = i.texCoord)),
        s.extensions[Ct.KHR_TEXTURE_TRANSFORM])
      ) {
        const a =
          i.extensions !== void 0
            ? i.extensions[Ct.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (a) {
          const l = s.associations.get(o);
          (o = s.extensions[Ct.KHR_TEXTURE_TRANSFORM].extendTexture(o, a)),
            s.associations.set(o, l);
        }
      }
      return (
        r !== void 0 &&
          ("colorSpace" in o
            ? (o.colorSpace = r === 3001 ? "srgb" : "srgb-linear")
            : (o.encoding = r)),
        (e[t] = o),
        o
      );
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const r = t.attributes.tangent === void 0,
      s = t.attributes.color !== void 0,
      o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + i.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new Ph()),
        bn.prototype.copy.call(l, i),
        l.color.copy(i.color),
        (l.map = i.map),
        (l.sizeAttenuation = !1),
        this.cache.add(a, l)),
        (i = l);
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + i.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new ci()),
        bn.prototype.copy.call(l, i),
        l.color.copy(i.color),
        (l.map = i.map),
        this.cache.add(a, l)),
        (i = l);
    }
    if (r || s || o) {
      let a = "ClonedMaterial:" + i.uuid + ":";
      r && (a += "derivative-tangents:"),
        s && (a += "vertex-colors:"),
        o && (a += "flat-shading:");
      let l = this.cache.get(a);
      l ||
        ((l = i.clone()),
        s && (l.vertexColors = !0),
        o && (l.flatShading = !0),
        r &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(a, l),
        this.associations.set(l, this.associations.get(i))),
        (i = l);
    }
    e.material = i;
  }
  getMaterialType() {
    return Dh;
  }
  loadMaterial(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      s = i.materials[e];
    let o;
    const a = {},
      l = s.extensions || {},
      u = [];
    if (l[Ct.KHR_MATERIALS_UNLIT]) {
      const d = r[Ct.KHR_MATERIALS_UNLIT];
      (o = d.getMaterialType()), u.push(d.extendParams(a, s, t));
    } else {
      const d = s.pbrMetallicRoughness || {};
      if (
        ((a.color = new Ue(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(d.baseColorFactor))
      ) {
        const p = d.baseColorFactor;
        a.color.fromArray(p), (a.opacity = p[3]);
      }
      d.baseColorTexture !== void 0 &&
        u.push(t.assignTexture(a, "map", d.baseColorTexture, 3001)),
        (a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1),
        (a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1),
        d.metallicRoughnessTexture !== void 0 &&
          (u.push(
            t.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)
          ),
          u.push(
            t.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture)
          )),
        (o = this._invokeOne(function (p) {
          return p.getMaterialType && p.getMaterialType(e);
        })),
        u.push(
          Promise.all(
            this._invokeAll(function (p) {
              return p.extendMaterialParams && p.extendMaterialParams(e, a);
            })
          )
        );
    }
    s.doubleSided === !0 && (a.side = Ar);
    const h = s.alphaMode || Gy.OPAQUE;
    if (
      (h === Gy.BLEND
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          h === Gy.MASK &&
            (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
      s.normalTexture !== void 0 &&
        o !== Ji &&
        (u.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        (a.normalScale = new ve(1, 1)),
        s.normalTexture.scale !== void 0))
    ) {
      const d = s.normalTexture.scale;
      a.normalScale.set(d, d);
    }
    return (
      s.occlusionTexture !== void 0 &&
        o !== Ji &&
        (u.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 &&
          (a.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 &&
        o !== Ji &&
        (a.emissive = new Ue().fromArray(s.emissiveFactor)),
      s.emissiveTexture !== void 0 &&
        o !== Ji &&
        u.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, 3001)),
      Promise.all(u).then(function () {
        const d = new o(a);
        return (
          s.name && (d.name = s.name),
          Eo(d, s),
          t.associations.set(d, { materials: e }),
          s.extensions && wa(r, d, s),
          d
        );
      })
    );
  }
  createUniqueName(e) {
    const t = bt.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed
      ? t + "_" + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    const t = this,
      i = this.extensions,
      r = this.primitiveCache;
    function s(a) {
      return i[Ct.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(a, t)
        .then(function (l) {
          return yC(l, a, t);
        });
    }
    const o = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a],
        h = w9(u),
        d = r[h];
      if (d) o.push(d.promise);
      else {
        let p;
        u.extensions && u.extensions[Ct.KHR_DRACO_MESH_COMPRESSION]
          ? (p = s(u))
          : (p = yC(new gt(), u, t)),
          (r[h] = { primitive: u, promise: p }),
          o.push(p);
      }
    }
    return Promise.all(o);
  }
  loadMesh(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      s = i.meshes[e],
      o = s.primitives,
      a = [];
    for (let l = 0, u = o.length; l < u; l++) {
      const h =
        o[l].material === void 0
          ? S9(this.cache)
          : this.getDependency("material", o[l].material);
      a.push(h);
    }
    return (
      a.push(t.loadGeometries(o)),
      Promise.all(a).then(function (l) {
        const u = l.slice(0, l.length - 1),
          h = l[l.length - 1],
          d = [];
        for (let m = 0, y = h.length; m < y; m++) {
          const M = h[m],
            A = o[m];
          let g;
          const x = u[m];
          if (
            A.mode === gr.TRIANGLES ||
            A.mode === gr.TRIANGLE_STRIP ||
            A.mode === gr.TRIANGLE_FAN ||
            A.mode === void 0
          )
            (g = s.isSkinnedMesh === !0 ? new I1(M, x) : new Gn(M, x)),
              g.isSkinnedMesh === !0 && g.normalizeSkinWeights(),
              A.mode === gr.TRIANGLE_STRIP
                ? (g.geometry = dC(g.geometry, y1))
                : A.mode === gr.TRIANGLE_FAN &&
                  (g.geometry = dC(g.geometry, Qm));
          else if (A.mode === gr.LINES) g = new Qr(M, x);
          else if (A.mode === gr.LINE_STRIP) g = new $s(M, x);
          else if (A.mode === gr.LINE_LOOP) g = new F1(M, x);
          else if (A.mode === gr.POINTS) g = new N1(M, x);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + A.mode
            );
          Object.keys(g.geometry.morphAttributes).length > 0 && E9(g, s),
            (g.name = t.createUniqueName(s.name || "mesh_" + e)),
            Eo(g, s),
            A.extensions && wa(r, g, A),
            t.assignFinalMaterial(g),
            d.push(g);
        }
        for (let m = 0, y = d.length; m < y; m++)
          t.associations.set(d[m], { meshes: e, primitives: m });
        if (d.length === 1) return s.extensions && wa(r, d[0], s), d[0];
        const p = new Vs();
        s.extensions && wa(r, p, s), t.associations.set(p, { meshes: e });
        for (let m = 0, y = d.length; m < y; m++) p.add(d[m]);
        return p;
      })
    );
  }
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e],
      r = i[i.type];
    if (!r) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      i.type === "perspective"
        ? (t = new $t(
            oB.radToDeg(r.yfov),
            r.aspectRatio || 1,
            r.znear || 1,
            r.zfar || 2e6
          ))
        : i.type === "orthographic" &&
          (t = new Wr(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)),
      i.name && (t.name = this.createUniqueName(i.name)),
      Eo(t, i),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      i = [];
    for (let r = 0, s = t.joints.length; r < s; r++)
      i.push(this._loadNodeShallow(t.joints[r]));
    return (
      t.inverseBindMatrices !== void 0
        ? i.push(this.getDependency("accessor", t.inverseBindMatrices))
        : i.push(null),
      Promise.all(i).then(function (r) {
        const s = r.pop(),
          o = r,
          a = [],
          l = [];
        for (let u = 0, h = o.length; u < h; u++) {
          const d = o[u];
          if (d) {
            a.push(d);
            const p = new rt();
            s !== null && p.fromArray(s.array, u * 16), l.push(p);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[u]
            );
        }
        return new Rh(a, l);
      })
    );
  }
  loadAnimation(e) {
    const i = this.json.animations[e],
      r = i.name ? i.name : "animation_" + e,
      s = [],
      o = [],
      a = [],
      l = [],
      u = [];
    for (let h = 0, d = i.channels.length; h < d; h++) {
      const p = i.channels[h],
        m = i.samplers[p.sampler],
        y = p.target,
        M = y.node,
        A = i.parameters !== void 0 ? i.parameters[m.input] : m.input,
        g = i.parameters !== void 0 ? i.parameters[m.output] : m.output;
      y.node !== void 0 &&
        (s.push(this.getDependency("node", M)),
        o.push(this.getDependency("accessor", A)),
        a.push(this.getDependency("accessor", g)),
        l.push(m),
        u.push(y));
    }
    return Promise.all([
      Promise.all(s),
      Promise.all(o),
      Promise.all(a),
      Promise.all(l),
      Promise.all(u),
    ]).then(function (h) {
      const d = h[0],
        p = h[1],
        m = h[2],
        y = h[3],
        M = h[4],
        A = [];
      for (let g = 0, x = d.length; g < x; g++) {
        const _ = d[g],
          E = p[g],
          T = m[g],
          R = y[g],
          P = M[g];
        if (_ === void 0) continue;
        _.updateMatrix();
        let B;
        switch (xo[P.path]) {
          case xo.weights:
            B = qc;
            break;
          case xo.rotation:
            B = qo;
            break;
          case xo.position:
          case xo.scale:
          default:
            B = Zc;
            break;
        }
        const b = _.name ? _.name : _.uuid,
          L = R.interpolation !== void 0 ? A9[R.interpolation] : al,
          z = [];
        xo[P.path] === xo.weights
          ? _.traverse(function (X) {
              X.morphTargetInfluences && z.push(X.name ? X.name : X.uuid);
            })
          : z.push(b);
        let $ = T.array;
        if (T.normalized) {
          const X = J_($.constructor),
            Y = new Float32Array($.length);
          for (let K = 0, ie = $.length; K < ie; K++) Y[K] = $[K] * X;
          $ = Y;
        }
        for (let X = 0, Y = z.length; X < Y; X++) {
          const K = new B(z[X] + "." + xo[P.path], E.array, $, L);
          R.interpolation === "CUBICSPLINE" &&
            ((K.createInterpolant = function (ee) {
              const I = this instanceof qo ? _9 : BL;
              return new I(
                this.times,
                this.values,
                this.getValueSize() / 3,
                ee
              );
            }),
            (K.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0)),
            A.push(K);
        }
      }
      return new $c(r, void 0, A);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      i = this,
      r = t.nodes[e];
    return r.mesh === void 0
      ? null
      : i.getDependency("mesh", r.mesh).then(function (s) {
          const o = i._getNodeRef(i.meshCache, r.mesh, s);
          return (
            r.weights !== void 0 &&
              o.traverse(function (a) {
                if (a.isMesh)
                  for (let l = 0, u = r.weights.length; l < u; l++)
                    a.morphTargetInfluences[l] = r.weights[l];
              }),
            o
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      i = this,
      r = t.nodes[e],
      s = i._loadNodeShallow(e),
      o = [],
      a = r.children || [];
    for (let u = 0, h = a.length; u < h; u++)
      o.push(i.getDependency("node", a[u]));
    const l =
      r.skin === void 0
        ? Promise.resolve(null)
        : i.getDependency("skin", r.skin);
    return Promise.all([s, Promise.all(o), l]).then(function (u) {
      const h = u[0],
        d = u[1],
        p = u[2];
      p !== null &&
        h.traverse(function (m) {
          m.isSkinnedMesh && m.bind(p, C9);
        });
      for (let m = 0, y = d.length; m < y; m++) h.add(d[m]);
      return h;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      i = this.extensions,
      r = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const s = t.nodes[e],
      o = s.name ? r.createUniqueName(s.name) : "",
      a = [],
      l = r._invokeOne(function (u) {
        return u.createNodeMesh && u.createNodeMesh(e);
      });
    return (
      l && a.push(l),
      s.camera !== void 0 &&
        a.push(
          r.getDependency("camera", s.camera).then(function (u) {
            return r._getNodeRef(r.cameraCache, s.camera, u);
          })
        ),
      r
        ._invokeAll(function (u) {
          return u.createNodeAttachment && u.createNodeAttachment(e);
        })
        .forEach(function (u) {
          a.push(u);
        }),
      (this.nodeCache[e] = Promise.all(a).then(function (u) {
        let h;
        if (
          (s.isBone === !0
            ? (h = new Gg())
            : u.length > 1
            ? (h = new Vs())
            : u.length === 1
            ? (h = u[0])
            : (h = new Rt()),
          h !== u[0])
        )
          for (let d = 0, p = u.length; d < p; d++) h.add(u[d]);
        if (
          (s.name && ((h.userData.name = s.name), (h.name = o)),
          Eo(h, s),
          s.extensions && wa(i, h, s),
          s.matrix !== void 0)
        ) {
          const d = new rt();
          d.fromArray(s.matrix), h.applyMatrix4(d);
        } else s.translation !== void 0 && h.position.fromArray(s.translation), s.rotation !== void 0 && h.quaternion.fromArray(s.rotation), s.scale !== void 0 && h.scale.fromArray(s.scale);
        return (
          r.associations.has(h) || r.associations.set(h, {}),
          (r.associations.get(h).nodes = e),
          h
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      i = this.json.scenes[e],
      r = this,
      s = new Vs();
    i.name && (s.name = r.createUniqueName(i.name)),
      Eo(s, i),
      i.extensions && wa(t, s, i);
    const o = i.nodes || [],
      a = [];
    for (let l = 0, u = o.length; l < u; l++)
      a.push(r.getDependency("node", o[l]));
    return Promise.all(a).then(function (l) {
      for (let h = 0, d = l.length; h < d; h++) s.add(l[h]);
      const u = (h) => {
        const d = new Map();
        for (const [p, m] of r.associations)
          (p instanceof bn || p instanceof en) && d.set(p, m);
        return (
          h.traverse((p) => {
            const m = r.associations.get(p);
            m != null && d.set(p, m);
          }),
          d
        );
      };
      return (r.associations = u(s)), s;
    });
  }
}
function R9(n, e, t) {
  const i = e.attributes,
    r = new Yr();
  if (i.POSITION !== void 0) {
    const a = t.json.accessors[i.POSITION],
      l = a.min,
      u = a.max;
    if (l !== void 0 && u !== void 0) {
      if (
        (r.set(new F(l[0], l[1], l[2]), new F(u[0], u[1], u[2])), a.normalized)
      ) {
        const h = J_(Fc[a.componentType]);
        r.min.multiplyScalar(h), r.max.multiplyScalar(h);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const s = e.targets;
  if (s !== void 0) {
    const a = new F(),
      l = new F();
    for (let u = 0, h = s.length; u < h; u++) {
      const d = s[u];
      if (d.POSITION !== void 0) {
        const p = t.json.accessors[d.POSITION],
          m = p.min,
          y = p.max;
        if (m !== void 0 && y !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(m[0]), Math.abs(y[0]))),
            l.setY(Math.max(Math.abs(m[1]), Math.abs(y[1]))),
            l.setZ(Math.max(Math.abs(m[2]), Math.abs(y[2]))),
            p.normalized)
          ) {
            const M = J_(Fc[p.componentType]);
            l.multiplyScalar(M);
          }
          a.max(l);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    r.expandByVector(a);
  }
  n.boundingBox = r;
  const o = new Tr();
  r.getCenter(o.center),
    (o.radius = r.min.distanceTo(r.max) / 2),
    (n.boundingSphere = o);
}
function yC(n, e, t) {
  const i = e.attributes,
    r = [];
  function s(o, a) {
    return t.getDependency("accessor", o).then(function (l) {
      n.setAttribute(a, l);
    });
  }
  for (const o in i) {
    const a = X_[o] || o.toLowerCase();
    a in n.attributes || r.push(s(i[o], a));
  }
  if (e.indices !== void 0 && !n.index) {
    const o = t.getDependency("accessor", e.indices).then(function (a) {
      n.setIndex(a);
    });
    r.push(o);
  }
  return (
    Eo(n, e),
    R9(n, e, t),
    Promise.all(r).then(function () {
      return e.targets !== void 0 ? M9(n, e.targets, t) : n;
    })
  );
}
const Wy = new WeakMap();
class P9 extends ui {
  constructor(e) {
    super(e),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      });
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this;
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this;
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this;
  }
  load(e, t, i, r) {
    const s = new $i(this.manager);
    s.setPath(this.path),
      s.setResponseType("arraybuffer"),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        (o) => {
          const a = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1,
          };
          this.decodeGeometry(o, a).then(t).catch(r);
        },
        i,
        r
      );
  }
  decodeDracoFile(e, t, i, r) {
    const s = {
      attributeIDs: i || this.defaultAttributeIDs,
      attributeTypes: r || this.defaultAttributeTypes,
      useUniqueIDs: !!i,
    };
    this.decodeGeometry(e, s).then(t);
  }
  decodeGeometry(e, t) {
    for (const l in t.attributeTypes) {
      const u = t.attributeTypes[l];
      u.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = u.name);
    }
    const i = JSON.stringify(t);
    if (Wy.has(e)) {
      const l = Wy.get(e);
      if (l.key === i) return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let r;
    const s = this.workerNextTaskID++,
      o = e.byteLength,
      a = this._getWorker(s, o)
        .then(
          (l) => (
            (r = l),
            new Promise((u, h) => {
              (r._callbacks[s] = { resolve: u, reject: h }),
                r.postMessage(
                  { type: "decode", id: s, taskConfig: t, buffer: e },
                  [e]
                );
            })
          )
        )
        .then((l) => this._createGeometry(l.geometry));
    return (
      a
        .catch(() => !0)
        .then(() => {
          r && s && this._releaseTask(r, s);
        }),
      Wy.set(e, { key: i, promise: a }),
      a
    );
  }
  _createGeometry(e) {
    const t = new gt();
    e.index && t.setIndex(new Ft(e.index.array, 1));
    for (let i = 0; i < e.attributes.length; i++) {
      const r = e.attributes[i],
        s = r.name,
        o = r.array,
        a = r.itemSize;
      t.setAttribute(s, new Ft(o, a));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const i = new $i(this.manager);
    return (
      i.setPath(this.decoderPath),
      i.setResponseType(t),
      i.setWithCredentials(this.withCredentials),
      new Promise((r, s) => {
        i.load(e, r, void 0, s);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      t = [];
    return (
      e
        ? t.push(this._loadLibrary("draco_decoder.js", "text"))
        : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(t).then((i) => {
        const r = i[0];
        e || (this.decoderConfig.wasmBinary = i[1]);
        const s = B9.toString(),
          o = [
            "/* draco decoder */",
            r,
            "",
            "/* worker */",
            s.substring(s.indexOf("{") + 1, s.lastIndexOf("}")),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([o]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const r = new Worker(this.workerSourceURL);
        (r._callbacks = {}),
          (r._taskCosts = {}),
          (r._taskLoad = 0),
          r.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (r.onmessage = function (s) {
            const o = s.data;
            switch (o.type) {
              case "decode":
                r._callbacks[o.id].resolve(o);
                break;
              case "error":
                r._callbacks[o.id].reject(o);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + o.type + '"'
                );
            }
          }),
          this.workerPool.push(r);
      } else
        this.workerPool.sort(function (r, s) {
          return r._taskLoad > s._taskLoad ? -1 : 1;
        });
      const i = this.workerPool[this.workerPool.length - 1];
      return (i._taskCosts[e] = t), (i._taskLoad += t), i;
    });
  }
  _releaseTask(e, t) {
    (e._taskLoad -= e._taskCosts[t]),
      delete e._callbacks[t],
      delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return (this.workerPool.length = 0), this;
  }
}
function B9() {
  let n, e;
  onmessage = function (o) {
    const a = o.data;
    switch (a.type) {
      case "init":
        (n = a.decoderConfig),
          (e = new Promise(function (h) {
            (n.onModuleLoaded = function (d) {
              h({ draco: d });
            }),
              DracoDecoderModule(n);
          }));
        break;
      case "decode":
        const l = a.buffer,
          u = a.taskConfig;
        e.then((h) => {
          const d = h.draco,
            p = new d.Decoder(),
            m = new d.DecoderBuffer();
          m.Init(new Int8Array(l), l.byteLength);
          try {
            const y = t(d, p, m, u),
              M = y.attributes.map((A) => A.array.buffer);
            y.index && M.push(y.index.array.buffer),
              self.postMessage({ type: "decode", id: a.id, geometry: y }, M);
          } catch (y) {
            console.error(y),
              self.postMessage({ type: "error", id: a.id, error: y.message });
          } finally {
            d.destroy(m), d.destroy(p);
          }
        });
        break;
    }
  };
  function t(o, a, l, u) {
    const h = u.attributeIDs,
      d = u.attributeTypes;
    let p, m;
    const y = a.GetEncodedGeometryType(l);
    if (y === o.TRIANGULAR_MESH)
      (p = new o.Mesh()), (m = a.DecodeBufferToMesh(l, p));
    else if (y === o.POINT_CLOUD)
      (p = new o.PointCloud()), (m = a.DecodeBufferToPointCloud(l, p));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!m.ok() || p.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg());
    const M = { index: null, attributes: [] };
    for (const A in h) {
      const g = self[d[A]];
      let x, _;
      if (u.useUniqueIDs) (_ = h[A]), (x = a.GetAttributeByUniqueId(p, _));
      else {
        if (((_ = a.GetAttributeId(p, o[h[A]])), _ === -1)) continue;
        x = a.GetAttribute(p, _);
      }
      M.attributes.push(r(o, a, p, A, g, x));
    }
    return y === o.TRIANGULAR_MESH && (M.index = i(o, a, p)), o.destroy(p), M;
  }
  function i(o, a, l) {
    const h = l.num_faces() * 3,
      d = h * 4,
      p = o._malloc(d);
    a.GetTrianglesUInt32Array(l, d, p);
    const m = new Uint32Array(o.HEAPF32.buffer, p, h).slice();
    return o._free(p), { array: m, itemSize: 1 };
  }
  function r(o, a, l, u, h, d) {
    const p = d.num_components(),
      y = l.num_points() * p,
      M = y * h.BYTES_PER_ELEMENT,
      A = s(o, h),
      g = o._malloc(M);
    a.GetAttributeDataArrayForAllPoints(l, d, A, M, g);
    const x = new h(o.HEAPF32.buffer, g, y).slice();
    return o._free(g), { name: u, array: x, itemSize: p };
  }
  function s(o, a) {
    switch (a) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
let Jp;
const jy = () => {
  if (Jp) return Jp;
  const n =
      "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
    e =
      "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
    t = new Uint8Array([
      0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0,
      1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7,
      0, 65, 0, 253, 15, 26, 11,
    ]),
    i = new Uint8Array([
      32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16,
      128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136,
      107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131,
      44, 45, 74, 156, 154, 70, 167,
    ]);
  if (typeof WebAssembly != "object") return { supported: !1 };
  let r = n;
  WebAssembly.validate(t) && (r = e);
  let s;
  const o = WebAssembly.instantiate(a(r), {}).then((d) => {
    (s = d.instance), s.exports.__wasm_call_ctors();
  });
  function a(d) {
    const p = new Uint8Array(d.length);
    for (let y = 0; y < d.length; ++y) {
      const M = d.charCodeAt(y);
      p[y] =
        M > 96 ? M - 71 : M > 64 ? M - 65 : M > 47 ? M + 4 : M > 46 ? 63 : 62;
    }
    let m = 0;
    for (let y = 0; y < d.length; ++y)
      p[m++] = p[y] < 60 ? i[p[y]] : (p[y] - 60) * 64 + p[++y];
    return p.buffer.slice(0, m);
  }
  function l(d, p, m, y, M, A) {
    const g = s.exports.sbrk,
      x = (m + 3) & -4,
      _ = g(x * y),
      E = g(M.length),
      T = new Uint8Array(s.exports.memory.buffer);
    T.set(M, E);
    const R = d(_, m, y, E, M.length);
    if (
      (R === 0 && A && A(_, x, y),
      p.set(T.subarray(_, _ + m * y)),
      g(_ - g(0)),
      R !== 0)
    )
      throw new Error(`Malformed buffer data: ${R}`);
  }
  const u = {
      0: "",
      1: "meshopt_decodeFilterOct",
      2: "meshopt_decodeFilterQuat",
      3: "meshopt_decodeFilterExp",
      NONE: "",
      OCTAHEDRAL: "meshopt_decodeFilterOct",
      QUATERNION: "meshopt_decodeFilterQuat",
      EXPONENTIAL: "meshopt_decodeFilterExp",
    },
    h = {
      0: "meshopt_decodeVertexBuffer",
      1: "meshopt_decodeIndexBuffer",
      2: "meshopt_decodeIndexSequence",
      ATTRIBUTES: "meshopt_decodeVertexBuffer",
      TRIANGLES: "meshopt_decodeIndexBuffer",
      INDICES: "meshopt_decodeIndexSequence",
    };
  return (
    (Jp = {
      ready: o,
      supported: !0,
      decodeVertexBuffer(d, p, m, y, M) {
        l(s.exports.meshopt_decodeVertexBuffer, d, p, m, y, s.exports[u[M]]);
      },
      decodeIndexBuffer(d, p, m, y) {
        l(s.exports.meshopt_decodeIndexBuffer, d, p, m, y);
      },
      decodeIndexSequence(d, p, m, y) {
        l(s.exports.meshopt_decodeIndexSequence, d, p, m, y);
      },
      decodeGltfBuffer(d, p, m, y, M, A) {
        l(s.exports[h[M]], d, p, m, y, s.exports[u[A]]);
      },
    }),
    Jp
  );
};
let Kp = null;
function LL(n, e, t) {
  return (i) => {
    t && t(i),
      n &&
        (Kp || (Kp = new P9()),
        Kp.setDecoderPath(
          typeof n == "string"
            ? n
            : "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"
        ),
        i.setDRACOLoader(Kp)),
      e && i.setMeshoptDecoder(typeof jy == "function" ? jy() : jy);
  };
}
function o0(n, e = !0, t = !0, i) {
  return Nh(lS, n, LL(e, t, i));
}
o0.preload = (n, e = !0, t = !0, i) => Nh.preload(lS, n, LL(e, t, i));
o0.clear = (n) => Nh.clear(lS, n);
const IL = W.forwardRef(
  (
    {
      makeDefault: n,
      camera: e,
      regress: t,
      domElement: i,
      enableDamping: r = !0,
      keyEvents: s = !1,
      onChange: o,
      onStart: a,
      onEnd: l,
      ...u
    },
    h
  ) => {
    const d = yr((R) => R.invalidate),
      p = yr((R) => R.camera),
      m = yr((R) => R.gl),
      y = yr((R) => R.events),
      M = yr((R) => R.setEvents),
      A = yr((R) => R.set),
      g = yr((R) => R.get),
      x = yr((R) => R.performance),
      _ = e || p,
      E = i || y.connected || m.domElement,
      T = W.useMemo(() => new q5(_), [_]);
    return (
      fu(() => {
        T.enabled && T.update();
      }, -1),
      W.useEffect(
        () => (
          s && T.connect(s === !0 ? E : s), T.connect(E), () => void T.dispose()
        ),
        [s, E, t, T, d]
      ),
      W.useEffect(() => {
        const R = (b) => {
            d(), t && x.regress(), o && o(b);
          },
          P = (b) => {
            a && a(b);
          },
          B = (b) => {
            l && l(b);
          };
        return (
          T.addEventListener("change", R),
          T.addEventListener("start", P),
          T.addEventListener("end", B),
          () => {
            T.removeEventListener("start", P),
              T.removeEventListener("end", B),
              T.removeEventListener("change", R);
          }
        );
      }, [o, a, l, T, d, M]),
      W.useEffect(() => {
        if (n) {
          const R = g().controls;
          return A({ controls: T }), () => A({ controls: R });
        }
      }, [n, T]),
      W.createElement(
        "primitive",
        Kr({ ref: h, object: T, enableDamping: r }, u)
      )
    );
  }
);
class L9 extends Ph {
  constructor(e) {
    super(e),
      (this.onBeforeCompile = (t, i) => {
        const { isWebGL2: r } = i.capabilities;
        t.fragmentShader = t.fragmentShader.replace(
          "#include <output_fragment>",
          `
        ${
          r
            ? "#include <output_fragment>"
            : `#extension GL_OES_standard_derivatives : enable
#include <output_fragment>`
        }
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <encodings_fragment>
      `
        );
      });
  }
}
const I9 = W.forwardRef((n, e) => {
  const [t] = W.useState(() => new L9(null));
  return W.createElement(
    "primitive",
    Kr({}, n, { object: t, ref: e, attach: "material" })
  );
});
let Ta, ef;
const D9 = W.createContext(null),
  xC = new rt(),
  _C = new F(),
  F9 = W.forwardRef(({ children: n, range: e, limit: t = 1e3, ...i }, r) => {
    const s = W.useRef(null),
      [o, a] = W.useState([]),
      [[l, u, h]] = W.useState(() => [
        new Float32Array(t * 3),
        Float32Array.from({ length: t * 3 }, () => 1),
        Float32Array.from({ length: t }, () => 1),
      ]);
    W.useEffect(() => {
      s.current.geometry.attributes.position.needsUpdate = !0;
    }),
      fu(() => {
        for (
          s.current.updateMatrix(),
            s.current.updateMatrixWorld(),
            xC.copy(s.current.matrixWorld).invert(),
            s.current.geometry.drawRange.count = Math.min(
              t,
              e !== void 0 ? e : t,
              o.length
            ),
            Ta = 0;
          Ta < o.length;
          Ta++
        )
          (ef = o[Ta].current),
            ef.getWorldPosition(_C).applyMatrix4(xC),
            _C.toArray(l, Ta * 3),
            (s.current.geometry.attributes.position.needsUpdate = !0),
            (ef.matrixWorldNeedsUpdate = !0),
            ef.color.toArray(u, Ta * 3),
            (s.current.geometry.attributes.color.needsUpdate = !0),
            h.set([ef.size], Ta),
            (s.current.geometry.attributes.size.needsUpdate = !0);
      });
    const d = W.useMemo(
      () => ({
        getParent: () => s,
        subscribe: (p) => (
          a((m) => [...m, p]),
          () => a((m) => m.filter((y) => y.current !== p.current))
        ),
      }),
      []
    );
    return W.createElement(
      "points",
      Kr(
        {
          userData: { instances: o },
          matrixAutoUpdate: !1,
          ref: RL([r, s]),
          raycast: () => null,
        },
        i
      ),
      W.createElement(
        "bufferGeometry",
        null,
        W.createElement("bufferAttribute", {
          attach: "attributes-position",
          count: l.length / 3,
          array: l,
          itemSize: 3,
          usage: Qa,
        }),
        W.createElement("bufferAttribute", {
          attach: "attributes-color",
          count: u.length / 3,
          array: u,
          itemSize: 3,
          usage: Qa,
        }),
        W.createElement("bufferAttribute", {
          attach: "attributes-size",
          count: h.length,
          array: h,
          itemSize: 1,
          usage: Qa,
        })
      ),
      W.createElement(D9.Provider, { value: d }, n)
    );
  }),
  N9 = W.forwardRef(
    (
      { children: n, positions: e, colors: t, sizes: i, stride: r = 3, ...s },
      o
    ) => {
      const a = W.useRef(null);
      return (
        fu(() => {
          const l = a.current.geometry.attributes;
          (l.position.needsUpdate = !0),
            t && (l.color.needsUpdate = !0),
            i && (l.size.needsUpdate = !0);
        }),
        W.createElement(
          "points",
          Kr({ ref: RL([o, a]) }, s),
          W.createElement(
            "bufferGeometry",
            null,
            W.createElement("bufferAttribute", {
              attach: "attributes-position",
              count: e.length / r,
              array: e,
              itemSize: r,
              usage: Qa,
            }),
            t &&
              W.createElement("bufferAttribute", {
                attach: "attributes-color",
                count: t.length / r,
                array: t,
                itemSize: 3,
                usage: Qa,
              }),
            i &&
              W.createElement("bufferAttribute", {
                attach: "attributes-size",
                count: i.length / r,
                array: i,
                itemSize: 1,
                usage: Qa,
              })
          ),
          n
        )
      );
    }
  ),
  U9 = W.forwardRef((n, e) =>
    n.positions instanceof Float32Array
      ? W.createElement(N9, Kr({}, n, { ref: e }))
      : W.createElement(F9, Kr({}, n, { ref: e }))
  );
var DL = { exports: {} },
  O9 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  k9 = O9,
  H9 = k9;
function FL() {}
function NL() {}
NL.resetWarningCache = FL;
var z9 = function () {
  function n(i, r, s, o, a, l) {
    if (l !== H9) {
      var u = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw ((u.name = "Invariant Violation"), u);
    }
  }
  n.isRequired = n;
  function e() {
    return n;
  }
  var t = {
    array: n,
    bigint: n,
    bool: n,
    func: n,
    number: n,
    object: n,
    string: n,
    symbol: n,
    any: n,
    arrayOf: e,
    element: n,
    elementType: n,
    instanceOf: e,
    node: n,
    objectOf: e,
    oneOf: e,
    oneOfType: e,
    shape: e,
    exact: e,
    checkPropTypes: NL,
    resetWarningCache: FL,
  };
  return (t.PropTypes = t), t;
};
DL.exports = z9();
var G9 = DL.exports;
const Hn = hg(G9);
function cS({ all: n, scene: e, camera: t }) {
  const i = yr(({ gl: o }) => o),
    r = yr(({ camera: o }) => o),
    s = yr(({ scene: o }) => o);
  return (
    W.useLayoutEffect(() => {
      const o = [];
      n &&
        (e || s).traverse((u) => {
          u.visible === !1 && (o.push(u), (u.visible = !0));
        }),
        i.compile(e || s, t || r);
      const a = new C1(128);
      new T1(0.01, 1e5, a).update(i, e || s),
        a.dispose(),
        o.forEach((u) => (u.visible = !1));
    }, []),
    null
  );
}
const UL = () => {
    const { progress: n } = K5();
    return q.jsxs(J5, {
      as: "div",
      center: !0,
      style: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        flexDirection: "column",
      },
      children: [
        q.jsx("span", { className: "canvas-loader" }),
        q.jsxs("p", {
          style: {
            fontSize: 14,
            color: "#F1F1F1",
            fontWeight: 800,
            marginTop: 40,
          },
          children: [n.toFixed(2), "%"],
        }),
      ],
    });
  },
  V9 = () => {
    const n = o0("./planet_earth/scene.gltf");
    return q.jsx("primitive", {
      object: n.scene,
      scale: 0.3,
      "position-y": 0,
      "rotation-y": 0,
    });
  },
  W9 = () =>
    q.jsx(oS, {
      shadows: !0,
      frameloop: "demand",
      dpr: [1, 2],
      gl: { preserveDrawingBuffer: !0 },
      camera: { fov: 45, near: 0.1, far: 200, position: [-4, 3, 6] },
      children: q.jsxs(W.Suspense, {
        fallback: q.jsx(UL, {}),
        children: [
          q.jsx(IL, {
            autoRotate: !0,
            enableZoom: !1,
            maxPolarAngle: Math.PI,
            minPolarAngle: 0,
          }),
          q.jsx("hemisphereLight", { intensity: 0.35, groundColor: "black" }),
          q.jsx("spotLight", {
            position: [10, 20, 10],
            angle: 0.25,
            penumbra: 1,
            intensity: 2,
            castShadow: !0,
            "shadow-mapSize": 1024,
          }),
          q.jsx("pointLight", { position: [-10, -10, -10], intensity: 1 }),
          q.jsx(V9, {}),
          q.jsx(cS, { all: !0 }),
        ],
      }),
    });
function Nc(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function AC(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n);
    e &&
      (i = i.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, i);
  }
  return t;
}
function SC(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? AC(Object(t), !0).forEach(function (i) {
          Nc(n, i, t[i]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : AC(Object(t)).forEach(function (i) {
          Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
        });
  }
  return n;
}
function OL(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
new ve();
new ve();
var dr = function n(e, t, i) {
    var r = this;
    OL(this, n),
      Nc(this, "dot2", function (s, o) {
        return r.x * s + r.y * o;
      }),
      Nc(this, "dot3", function (s, o, a) {
        return r.x * s + r.y * o + r.z * a;
      }),
      (this.x = e),
      (this.y = t),
      (this.z = i);
  },
  j9 = [
    new dr(1, 1, 0),
    new dr(-1, 1, 0),
    new dr(1, -1, 0),
    new dr(-1, -1, 0),
    new dr(1, 0, 1),
    new dr(-1, 0, 1),
    new dr(1, 0, -1),
    new dr(-1, 0, -1),
    new dr(0, 1, 1),
    new dr(0, -1, 1),
    new dr(0, 1, -1),
    new dr(0, -1, -1),
  ],
  MC = [
    151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140,
    36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
    234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
    134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,
    230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
    1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130,
    116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250,
    124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227,
    47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,
    154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98,
    108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,
    242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
    239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
    50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243,
    141, 128, 195, 78, 66, 215, 61, 156, 180,
  ],
  EC = new Array(512),
  wC = new Array(512),
  X9 = function (e) {
    e > 0 && e < 1 && (e *= 65536),
      (e = Math.floor(e)),
      e < 256 && (e |= e << 8);
    for (var t = 0; t < 256; t++) {
      var i;
      t & 1 ? (i = MC[t] ^ (e & 255)) : (i = MC[t] ^ ((e >> 8) & 255)),
        (EC[t] = EC[t + 256] = i),
        (wC[t] = wC[t + 256] = j9[i % 12]);
    }
  };
X9(0);
function J9(n) {
  if (typeof n == "number") n = Math.abs(n);
  else if (typeof n == "string") {
    var e = n;
    n = 0;
    for (var t = 0; t < e.length; t++)
      n = (n + (t + 1) * (e.charCodeAt(t) % 96)) % 2147483647;
  }
  return n === 0 && (n = 311), n;
}
function TC(n) {
  var e = J9(n);
  return function () {
    var t = (e * 48271) % 2147483647;
    return (e = t), t / 2147483647;
  };
}
var K9 = function n(e) {
    var t = this;
    OL(this, n),
      Nc(this, "seed", 0),
      Nc(this, "init", function (i) {
        (t.seed = i), (t.value = TC(i));
      }),
      Nc(this, "value", TC(this.seed)),
      this.init(e);
  },
  Y9 = new K9(Math.random()),
  Q9 = { radius: 1, center: [0, 0, 0] };
function q9(n, e) {
  for (
    var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Y9,
      i = SC(SC({}, Q9), e),
      r = i.radius,
      s = i.center,
      o = 0;
    o < n.length;
    o += 3
  ) {
    var a = Math.pow(t.value(), 0.3333333333333333),
      l = t.value() * 2 - 1,
      u = t.value() * 2 - 1,
      h = t.value() * 2 - 1,
      d = Math.sqrt(l * l + u * u + h * h);
    (l = (a * l) / d),
      (u = (a * u) / d),
      (h = (a * h) / d),
      (n[o] = l * r + s[0]),
      (n[o + 1] = u * r + s[1]),
      (n[o + 2] = h * r + s[2]);
  }
  return n;
}
const Z9 = (n) => {
    const e = W.useRef(),
      [t] = W.useState(() => q9(new Float32Array(5e3), { radius: 1.2 }));
    return (
      fu((i, r) => {
        (e.current.rotation.x -= r / 10), (e.current.rotation.y -= r / 15);
      }),
      q.jsx("group", {
        rotation: [0, 0, Math.PI / 4],
        children: q.jsx(U9, {
          ref: e,
          positions: t,
          stride: 3,
          frustumCulled: !0,
          ...n,
          children: q.jsx(I9, {
            transparent: !0,
            color: "#f272c8",
            size: 0.002,
            sizeAttenuation: !0,
            depthWrite: !1,
          }),
        }),
      })
    );
  },
  tf = () =>
    q.jsx("div", {
      className: "w-full h-auto absolute inset-0 z-[-1]",
      children: q.jsxs(oS, {
        camera: { position: [0, 0, 1] },
        children: [
          q.jsx(W.Suspense, { fallback: null, children: q.jsx(Z9, {}) }),
          q.jsx(cS, { all: !0 }),
        ],
      }),
    }),
  $9 = ({ isMobile: n }) => {
    const e = o0("./astronaut/scene.gltf"),
      [t, i] = W.useState(!1),
      [r, s] = W.useState(0),
      o = 0.4,
      a = 1;
    return (
      fu((l) => {
        const u = l.clock.elapsedTime,
          h = Math.sin(u * a) * o;
        s(h);
      }),
      q.jsxs("mesh", {
        onPointerOver: () => i(!0),
        onPointerOut: () => i(!1),
        children: [
          q.jsx("hemisphereLight", { intensity: 0.15, groundColor: "black" }),
          q.jsx("spotLight", {
            position: [-20, 50, 10],
            angle: 0.12,
            penumbra: 1,
            intensity: 1,
            castShadow: !0,
            "shadow-mapSize": 1024,
          }),
          q.jsx("pointLight", { intensity: 1 }),
          q.jsx("primitive", {
            object: e.scene,
            scale: n ? 2.5 : 2.6,
            position: n ? [0, -4 + r, -1.5] : [0, -4.5 + r, -0.5],
            rotation: [-0.01, -0.2, -0.1],
          }),
        ],
      })
    );
  },
  e8 = () => {
    const [n, e] = W.useState(!1);
    return (
      W.useEffect(() => {
        const t = window.matchMedia("(max-width: 500px)");
        e(t.matches);
        const i = (r) => {
          e(r.matches);
        };
        return (
          t.addEventListener("change", i),
          () => {
            t.removeEventListener("change", i);
          }
        );
      }, []),
      q.jsxs(oS, {
        frameloop: "demand",
        shadows: !0,
        dpr: [1, 2],
        camera: { position: [20, 3, 5], fov: 25 },
        gl: { preserveDrawingBuffer: !0 },
        children: [
          q.jsxs(W.Suspense, {
            fallback: q.jsx(UL, {}),
            children: [
              q.jsx(IL, {
                enableZoom: !1,
                maxPolarAngle: Math.PI / 2,
                minPolarAngle: Math.PI / 2,
              }),
              q.jsx($9, { isMobile: n }),
            ],
          }),
          q.jsx(cS, { all: !0 }),
        ],
      })
    );
  },
  kL = W.createContext({
    transformPagePoint: (n) => n,
    isStatic: !1,
    reducedMotion: "never",
  }),
  a0 = W.createContext({}),
  uS = W.createContext(null),
  l0 = typeof document < "u",
  CC = l0 ? W.useLayoutEffect : W.useEffect,
  HL = W.createContext({ strict: !1 });
function t8(n, e, t, i) {
  const { visualElement: r } = W.useContext(a0),
    s = W.useContext(HL),
    o = W.useContext(uS),
    a = W.useContext(kL).reducedMotion,
    l = W.useRef();
  (i = i || s.renderer),
    !l.current &&
      i &&
      (l.current = i(n, {
        visualState: e,
        parent: r,
        props: t,
        presenceContext: o,
        blockInitialAnimation: o ? o.initial === !1 : !1,
        reducedMotionConfig: a,
      }));
  const u = l.current;
  return (
    W.useInsertionEffect(() => {
      u && u.update(t, o);
    }),
    CC(() => {
      u && u.render();
    }),
    W.useEffect(() => {
      u && u.updateFeatures();
    }),
    (window.HandoffAppearAnimations ? CC : W.useEffect)(() => {
      u && u.animationState && u.animationState.animateChanges();
    }),
    u
  );
}
function Sc(n) {
  return (
    typeof n == "object" && Object.prototype.hasOwnProperty.call(n, "current")
  );
}
function n8(n, e, t) {
  return W.useCallback(
    (i) => {
      i && n.mount && n.mount(i),
        e && (i ? e.mount(i) : e.unmount()),
        t && (typeof t == "function" ? t(i) : Sc(t) && (t.current = i));
    },
    [e]
  );
}
function ch(n) {
  return typeof n == "string" || Array.isArray(n);
}
function c0(n) {
  return typeof n == "object" && typeof n.start == "function";
}
const fS = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
  ],
  hS = ["initial", ...fS];
function u0(n) {
  return c0(n.animate) || hS.some((e) => ch(n[e]));
}
function zL(n) {
  return !!(u0(n) || n.variants);
}
function i8(n, e) {
  if (u0(n)) {
    const { initial: t, animate: i } = n;
    return {
      initial: t === !1 || ch(t) ? t : void 0,
      animate: ch(i) ? i : void 0,
    };
  }
  return n.inherit !== !1 ? e : {};
}
function r8(n) {
  const { initial: e, animate: t } = i8(n, W.useContext(a0));
  return W.useMemo(() => ({ initial: e, animate: t }), [bC(e), bC(t)]);
}
function bC(n) {
  return Array.isArray(n) ? n.join(" ") : n;
}
const RC = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  },
  uh = {};
for (const n in RC) uh[n] = { isEnabled: (e) => RC[n].some((t) => !!e[t]) };
function s8(n) {
  for (const e in n) uh[e] = { ...uh[e], ...n[e] };
}
const GL = W.createContext({}),
  VL = W.createContext({}),
  o8 = Symbol.for("motionComponentSymbol");
function a8({
  preloadedFeatures: n,
  createVisualElement: e,
  useRender: t,
  useVisualState: i,
  Component: r,
}) {
  n && s8(n);
  function s(a, l) {
    let u;
    const h = { ...W.useContext(kL), ...a, layoutId: l8(a) },
      { isStatic: d } = h,
      p = r8(a),
      m = i(a, d);
    if (!d && l0) {
      p.visualElement = t8(r, m, h, e);
      const y = W.useContext(VL),
        M = W.useContext(HL).strict;
      p.visualElement && (u = p.visualElement.loadFeatures(h, M, n, y));
    }
    return W.createElement(
      a0.Provider,
      { value: p },
      u && p.visualElement
        ? W.createElement(u, { visualElement: p.visualElement, ...h })
        : null,
      t(r, a, n8(m, p.visualElement, l), m, d, p.visualElement)
    );
  }
  const o = W.forwardRef(s);
  return (o[o8] = r), o;
}
function l8({ layoutId: n }) {
  const e = W.useContext(GL).id;
  return e && n !== void 0 ? e + "-" + n : n;
}
function c8(n) {
  function e(i, r = {}) {
    return a8(n(i, r));
  }
  if (typeof Proxy > "u") return e;
  const t = new Map();
  return new Proxy(e, {
    get: (i, r) => (t.has(r) || t.set(r, e(r)), t.get(r)),
  });
}
const u8 = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function dS(n) {
  return typeof n != "string" || n.includes("-")
    ? !1
    : !!(u8.indexOf(n) > -1 || /[A-Z]/.test(n));
}
const tg = {};
function f8(n) {
  Object.assign(tg, n);
}
const Oh = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  gl = new Set(Oh);
function WL(n, { layout: e, layoutId: t }) {
  return (
    gl.has(n) ||
    n.startsWith("origin") ||
    ((e || t !== void 0) && (!!tg[n] || n === "opacity"))
  );
}
const Ii = (n) => !!(n && n.getVelocity),
  h8 = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  d8 = Oh.length;
function p8(
  n,
  { enableHardwareAcceleration: e = !0, allowTransformNone: t = !0 },
  i,
  r
) {
  let s = "";
  for (let o = 0; o < d8; o++) {
    const a = Oh[o];
    if (n[a] !== void 0) {
      const l = h8[a] || a;
      s += `${l}(${n[a]}) `;
    }
  }
  return (
    e && !n.z && (s += "translateZ(0)"),
    (s = s.trim()),
    r ? (s = r(n, i ? "" : s)) : t && i && (s = "none"),
    s
  );
}
const jL = (n) => (e) => typeof e == "string" && e.startsWith(n),
  XL = jL("--"),
  K_ = jL("var(--"),
  m8 =
    /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,
  g8 = (n, e) => (e && typeof n == "number" ? e.transform(n) : n),
  Zo = (n, e, t) => Math.min(Math.max(t, n), e),
  vl = {
    test: (n) => typeof n == "number",
    parse: parseFloat,
    transform: (n) => n,
  },
  bf = { ...vl, transform: (n) => Zo(0, 1, n) },
  Yp = { ...vl, default: 1 },
  Rf = (n) => Math.round(n * 1e5) / 1e5,
  f0 = /(-)?([\d]*\.?[\d])+/g,
  JL =
    /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,
  v8 =
    /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function kh(n) {
  return typeof n == "string";
}
const Hh = (n) => ({
    test: (e) => kh(e) && e.endsWith(n) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${n}`,
  }),
  _o = Hh("deg"),
  ys = Hh("%"),
  it = Hh("px"),
  y8 = Hh("vh"),
  x8 = Hh("vw"),
  PC = {
    ...ys,
    parse: (n) => ys.parse(n) / 100,
    transform: (n) => ys.transform(n * 100),
  },
  BC = { ...vl, transform: Math.round },
  KL = {
    borderWidth: it,
    borderTopWidth: it,
    borderRightWidth: it,
    borderBottomWidth: it,
    borderLeftWidth: it,
    borderRadius: it,
    radius: it,
    borderTopLeftRadius: it,
    borderTopRightRadius: it,
    borderBottomRightRadius: it,
    borderBottomLeftRadius: it,
    width: it,
    maxWidth: it,
    height: it,
    maxHeight: it,
    size: it,
    top: it,
    right: it,
    bottom: it,
    left: it,
    padding: it,
    paddingTop: it,
    paddingRight: it,
    paddingBottom: it,
    paddingLeft: it,
    margin: it,
    marginTop: it,
    marginRight: it,
    marginBottom: it,
    marginLeft: it,
    rotate: _o,
    rotateX: _o,
    rotateY: _o,
    rotateZ: _o,
    scale: Yp,
    scaleX: Yp,
    scaleY: Yp,
    scaleZ: Yp,
    skew: _o,
    skewX: _o,
    skewY: _o,
    distance: it,
    translateX: it,
    translateY: it,
    translateZ: it,
    x: it,
    y: it,
    z: it,
    perspective: it,
    transformPerspective: it,
    opacity: bf,
    originX: PC,
    originY: PC,
    originZ: it,
    zIndex: BC,
    fillOpacity: bf,
    strokeOpacity: bf,
    numOctaves: BC,
  };
function pS(n, e, t, i) {
  const { style: r, vars: s, transform: o, transformOrigin: a } = n;
  let l = !1,
    u = !1,
    h = !0;
  for (const d in e) {
    const p = e[d];
    if (XL(d)) {
      s[d] = p;
      continue;
    }
    const m = KL[d],
      y = g8(p, m);
    if (gl.has(d)) {
      if (((l = !0), (o[d] = y), !h)) continue;
      p !== (m.default || 0) && (h = !1);
    } else d.startsWith("origin") ? ((u = !0), (a[d] = y)) : (r[d] = y);
  }
  if (
    (e.transform ||
      (l || i
        ? (r.transform = p8(n.transform, t, h, i))
        : r.transform && (r.transform = "none")),
    u)
  ) {
    const { originX: d = "50%", originY: p = "50%", originZ: m = 0 } = a;
    r.transformOrigin = `${d} ${p} ${m}`;
  }
}
const mS = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} });
function YL(n, e, t) {
  for (const i in e) !Ii(e[i]) && !WL(i, t) && (n[i] = e[i]);
}
function _8({ transformTemplate: n }, e, t) {
  return W.useMemo(() => {
    const i = mS();
    return (
      pS(i, e, { enableHardwareAcceleration: !t }, n),
      Object.assign({}, i.vars, i.style)
    );
  }, [e]);
}
function A8(n, e, t) {
  const i = n.style || {},
    r = {};
  return (
    YL(r, i, n),
    Object.assign(r, _8(n, e, t)),
    n.transformValues ? n.transformValues(r) : r
  );
}
function S8(n, e, t) {
  const i = {},
    r = A8(n, e, t);
  return (
    n.drag &&
      n.dragListener !== !1 &&
      ((i.draggable = !1),
      (r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none"),
      (r.touchAction =
        n.drag === !0 ? "none" : `pan-${n.drag === "x" ? "y" : "x"}`)),
    n.tabIndex === void 0 &&
      (n.onTap || n.onTapStart || n.whileTap) &&
      (i.tabIndex = 0),
    (i.style = r),
    i
  );
}
const M8 = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "ignoreStrict",
  "viewport",
]);
function ng(n) {
  return (
    n.startsWith("while") ||
    (n.startsWith("drag") && n !== "draggable") ||
    n.startsWith("layout") ||
    n.startsWith("onTap") ||
    n.startsWith("onPan") ||
    M8.has(n)
  );
}
let QL = (n) => !ng(n);
function E8(n) {
  n && (QL = (e) => (e.startsWith("on") ? !ng(e) : n(e)));
}
try {
  E8(require("@emotion/is-prop-valid").default);
} catch {}
function w8(n, e, t) {
  const i = {};
  for (const r in n)
    (r === "values" && typeof n.values == "object") ||
      ((QL(r) ||
        (t === !0 && ng(r)) ||
        (!e && !ng(r)) ||
        (n.draggable && r.startsWith("onDrag"))) &&
        (i[r] = n[r]));
  return i;
}
function LC(n, e, t) {
  return typeof n == "string" ? n : it.transform(e + t * n);
}
function T8(n, e, t) {
  const i = LC(e, n.x, n.width),
    r = LC(t, n.y, n.height);
  return `${i} ${r}`;
}
const C8 = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  b8 = { offset: "strokeDashoffset", array: "strokeDasharray" };
function R8(n, e, t = 1, i = 0, r = !0) {
  n.pathLength = 1;
  const s = r ? C8 : b8;
  n[s.offset] = it.transform(-i);
  const o = it.transform(e),
    a = it.transform(t);
  n[s.array] = `${o} ${a}`;
}
function gS(
  n,
  {
    attrX: e,
    attrY: t,
    attrScale: i,
    originX: r,
    originY: s,
    pathLength: o,
    pathSpacing: a = 1,
    pathOffset: l = 0,
    ...u
  },
  h,
  d,
  p
) {
  if ((pS(n, u, h, p), d)) {
    n.style.viewBox && (n.attrs.viewBox = n.style.viewBox);
    return;
  }
  (n.attrs = n.style), (n.style = {});
  const { attrs: m, style: y, dimensions: M } = n;
  m.transform && (M && (y.transform = m.transform), delete m.transform),
    M &&
      (r !== void 0 || s !== void 0 || y.transform) &&
      (y.transformOrigin = T8(
        M,
        r !== void 0 ? r : 0.5,
        s !== void 0 ? s : 0.5
      )),
    e !== void 0 && (m.x = e),
    t !== void 0 && (m.y = t),
    i !== void 0 && (m.scale = i),
    o !== void 0 && R8(m, o, a, l, !1);
}
const qL = () => ({ ...mS(), attrs: {} }),
  vS = (n) => typeof n == "string" && n.toLowerCase() === "svg";
function P8(n, e, t, i) {
  const r = W.useMemo(() => {
    const s = qL();
    return (
      gS(s, e, { enableHardwareAcceleration: !1 }, vS(i), n.transformTemplate),
      { ...s.attrs, style: { ...s.style } }
    );
  }, [e]);
  if (n.style) {
    const s = {};
    YL(s, n.style, n), (r.style = { ...s, ...r.style });
  }
  return r;
}
function B8(n = !1) {
  return (t, i, r, { latestValues: s }, o) => {
    const l = (dS(t) ? P8 : S8)(i, s, o, t),
      h = { ...w8(i, typeof t == "string", n), ...l, ref: r },
      { children: d } = i,
      p = W.useMemo(() => (Ii(d) ? d.get() : d), [d]);
    return W.createElement(t, { ...h, children: p });
  };
}
const yS = (n) => n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function ZL(n, { style: e, vars: t }, i, r) {
  Object.assign(n.style, e, r && r.getProjectionStyles(i));
  for (const s in t) n.style.setProperty(s, t[s]);
}
const $L = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
]);
function eI(n, e, t, i) {
  ZL(n, e, void 0, i);
  for (const r in e.attrs) n.setAttribute($L.has(r) ? r : yS(r), e.attrs[r]);
}
function xS(n, e) {
  const { style: t } = n,
    i = {};
  for (const r in t)
    (Ii(t[r]) || (e.style && Ii(e.style[r])) || WL(r, n)) && (i[r] = t[r]);
  return i;
}
function tI(n, e) {
  const t = xS(n, e);
  for (const i in n)
    if (Ii(n[i]) || Ii(e[i])) {
      const r =
        Oh.indexOf(i) !== -1
          ? "attr" + i.charAt(0).toUpperCase() + i.substring(1)
          : i;
      t[r] = n[i];
    }
  return t;
}
function _S(n, e, t, i = {}, r = {}) {
  return (
    typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)),
    typeof e == "string" && (e = n.variants && n.variants[e]),
    typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)),
    e
  );
}
function L8(n) {
  const e = W.useRef(null);
  return e.current === null && (e.current = n()), e.current;
}
const ig = (n) => Array.isArray(n),
  I8 = (n) => !!(n && typeof n == "object" && n.mix && n.toValue),
  D8 = (n) => (ig(n) ? n[n.length - 1] || 0 : n);
function _m(n) {
  const e = Ii(n) ? n.get() : n;
  return I8(e) ? e.toValue() : e;
}
function F8(
  { scrapeMotionValuesFromProps: n, createRenderState: e, onMount: t },
  i,
  r,
  s
) {
  const o = { latestValues: N8(i, r, s, n), renderState: e() };
  return t && (o.mount = (a) => t(i, a, o)), o;
}
const nI = (n) => (e, t) => {
  const i = W.useContext(a0),
    r = W.useContext(uS),
    s = () => F8(n, e, i, r);
  return t ? s() : L8(s);
};
function N8(n, e, t, i) {
  const r = {},
    s = i(n, {});
  for (const p in s) r[p] = _m(s[p]);
  let { initial: o, animate: a } = n;
  const l = u0(n),
    u = zL(n);
  e &&
    u &&
    !l &&
    n.inherit !== !1 &&
    (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
  let h = t ? t.initial === !1 : !1;
  h = h || o === !1;
  const d = h ? a : o;
  return (
    d &&
      typeof d != "boolean" &&
      !c0(d) &&
      (Array.isArray(d) ? d : [d]).forEach((m) => {
        const y = _S(n, m);
        if (!y) return;
        const { transitionEnd: M, transition: A, ...g } = y;
        for (const x in g) {
          let _ = g[x];
          if (Array.isArray(_)) {
            const E = h ? _.length - 1 : 0;
            _ = _[E];
          }
          _ !== null && (r[x] = _);
        }
        for (const x in M) r[x] = M[x];
      }),
    r
  );
}
const U8 = {
    useVisualState: nI({
      scrapeMotionValuesFromProps: tI,
      createRenderState: qL,
      onMount: (n, e, { renderState: t, latestValues: i }) => {
        try {
          t.dimensions =
            typeof e.getBBox == "function"
              ? e.getBBox()
              : e.getBoundingClientRect();
        } catch {
          t.dimensions = { x: 0, y: 0, width: 0, height: 0 };
        }
        gS(
          t,
          i,
          { enableHardwareAcceleration: !1 },
          vS(e.tagName),
          n.transformTemplate
        ),
          eI(e, t);
      },
    }),
  },
  O8 = {
    useVisualState: nI({
      scrapeMotionValuesFromProps: xS,
      createRenderState: mS,
    }),
  };
function k8(n, { forwardMotionProps: e = !1 }, t, i) {
  return {
    ...(dS(n) ? U8 : O8),
    preloadedFeatures: t,
    useRender: B8(e),
    createVisualElement: i,
    Component: n,
  };
}
function Ws(n, e, t, i = { passive: !0 }) {
  return n.addEventListener(e, t, i), () => n.removeEventListener(e, t);
}
const iI = (n) =>
  n.pointerType === "mouse"
    ? typeof n.button != "number" || n.button <= 0
    : n.isPrimary !== !1;
function h0(n, e = "page") {
  return { point: { x: n[e + "X"], y: n[e + "Y"] } };
}
const H8 = (n) => (e) => iI(e) && n(e, h0(e));
function Js(n, e, t, i) {
  return Ws(n, e, H8(t), i);
}
const z8 = (n, e) => (t) => e(n(t)),
  Vo = (...n) => n.reduce(z8);
function rI(n) {
  let e = null;
  return () => {
    const t = () => {
      e = null;
    };
    return e === null ? ((e = n), t) : !1;
  };
}
const IC = rI("dragHorizontal"),
  DC = rI("dragVertical");
function sI(n) {
  let e = !1;
  if (n === "y") e = DC();
  else if (n === "x") e = IC();
  else {
    const t = IC(),
      i = DC();
    t && i
      ? (e = () => {
          t(), i();
        })
      : (t && t(), i && i());
  }
  return e;
}
function oI() {
  const n = sI(!0);
  return n ? (n(), !1) : !0;
}
class oa {
  constructor(e) {
    (this.isMounted = !1), (this.node = e);
  }
  update() {}
}
function G8(n) {
  let e = [],
    t = [],
    i = 0,
    r = !1,
    s = !1;
  const o = new WeakSet(),
    a = {
      schedule: (l, u = !1, h = !1) => {
        const d = h && r,
          p = d ? e : t;
        return (
          u && o.add(l),
          p.indexOf(l) === -1 && (p.push(l), d && r && (i = e.length)),
          l
        );
      },
      cancel: (l) => {
        const u = t.indexOf(l);
        u !== -1 && t.splice(u, 1), o.delete(l);
      },
      process: (l) => {
        if (r) {
          s = !0;
          return;
        }
        if (((r = !0), ([e, t] = [t, e]), (t.length = 0), (i = e.length), i))
          for (let u = 0; u < i; u++) {
            const h = e[u];
            h(l), o.has(h) && (a.schedule(h), n());
          }
        (r = !1), s && ((s = !1), a.process(l));
      },
    };
  return a;
}
const nn = { delta: 0, timestamp: 0, isProcessing: !1 },
  V8 = 40;
let Y_ = !0,
  fh = !1;
const d0 = ["read", "update", "preRender", "render", "postRender"],
  Uc = d0.reduce((n, e) => ((n[e] = G8(() => (fh = !0))), n), {}),
  W8 = (n) => Uc[n].process(nn),
  aI = (n) => {
    (fh = !1),
      (nn.delta = Y_ ? 1e3 / 60 : Math.max(Math.min(n - nn.timestamp, V8), 1)),
      (nn.timestamp = n),
      (nn.isProcessing = !0),
      d0.forEach(W8),
      (nn.isProcessing = !1),
      fh && ((Y_ = !1), requestAnimationFrame(aI));
  },
  j8 = () => {
    (fh = !0), (Y_ = !0), nn.isProcessing || requestAnimationFrame(aI);
  },
  ln = d0.reduce((n, e) => {
    const t = Uc[e];
    return (n[e] = (i, r = !1, s = !1) => (fh || j8(), t.schedule(i, r, s))), n;
  }, {});
function eo(n) {
  d0.forEach((e) => Uc[e].cancel(n));
}
function FC(n, e) {
  const t = "pointer" + (e ? "enter" : "leave"),
    i = "onHover" + (e ? "Start" : "End"),
    r = (s, o) => {
      if (s.type === "touch" || oI()) return;
      const a = n.getProps();
      n.animationState &&
        a.whileHover &&
        n.animationState.setActive("whileHover", e),
        a[i] && ln.update(() => a[i](s, o));
    };
  return Js(n.current, t, r, { passive: !n.getProps()[i] });
}
class X8 extends oa {
  mount() {
    this.unmount = Vo(FC(this.node, !0), FC(this.node, !1));
  }
  unmount() {}
}
class J8 extends oa {
  constructor() {
    super(...arguments), (this.isActive = !1);
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1));
  }
  mount() {
    this.unmount = Vo(
      Ws(this.node.current, "focus", () => this.onFocus()),
      Ws(this.node.current, "blur", () => this.onBlur())
    );
  }
  unmount() {}
}
const lI = (n, e) => (e ? (n === e ? !0 : lI(n, e.parentElement)) : !1),
  Ln = (n) => n;
function Xy(n, e) {
  if (!e) return;
  const t = new PointerEvent("pointer" + n);
  e(t, h0(t));
}
class K8 extends oa {
  constructor() {
    super(...arguments),
      (this.removeStartListeners = Ln),
      (this.removeEndListeners = Ln),
      (this.removeAccessibleListeners = Ln),
      (this.startPointerPress = (e, t) => {
        if ((this.removeEndListeners(), this.isPressing)) return;
        const i = this.node.getProps(),
          s = Js(
            window,
            "pointerup",
            (a, l) => {
              if (!this.checkPressEnd()) return;
              const { onTap: u, onTapCancel: h } = this.node.getProps();
              ln.update(() => {
                lI(this.node.current, a.target) ? u && u(a, l) : h && h(a, l);
              });
            },
            { passive: !(i.onTap || i.onPointerUp) }
          ),
          o = Js(window, "pointercancel", (a, l) => this.cancelPress(a, l), {
            passive: !(i.onTapCancel || i.onPointerCancel),
          });
        (this.removeEndListeners = Vo(s, o)), this.startPress(e, t);
      }),
      (this.startAccessiblePress = () => {
        const e = (s) => {
            if (s.key !== "Enter" || this.isPressing) return;
            const o = (a) => {
              a.key !== "Enter" ||
                !this.checkPressEnd() ||
                Xy("up", (l, u) => {
                  const { onTap: h } = this.node.getProps();
                  h && ln.update(() => h(l, u));
                });
            };
            this.removeEndListeners(),
              (this.removeEndListeners = Ws(this.node.current, "keyup", o)),
              Xy("down", (a, l) => {
                this.startPress(a, l);
              });
          },
          t = Ws(this.node.current, "keydown", e),
          i = () => {
            this.isPressing && Xy("cancel", (s, o) => this.cancelPress(s, o));
          },
          r = Ws(this.node.current, "blur", i);
        this.removeAccessibleListeners = Vo(t, r);
      });
  }
  startPress(e, t) {
    this.isPressing = !0;
    const { onTapStart: i, whileTap: r } = this.node.getProps();
    r &&
      this.node.animationState &&
      this.node.animationState.setActive("whileTap", !0),
      i && ln.update(() => i(e, t));
  }
  checkPressEnd() {
    return (
      this.removeEndListeners(),
      (this.isPressing = !1),
      this.node.getProps().whileTap &&
        this.node.animationState &&
        this.node.animationState.setActive("whileTap", !1),
      !oI()
    );
  }
  cancelPress(e, t) {
    if (!this.checkPressEnd()) return;
    const { onTapCancel: i } = this.node.getProps();
    i && ln.update(() => i(e, t));
  }
  mount() {
    const e = this.node.getProps(),
      t = Js(this.node.current, "pointerdown", this.startPointerPress, {
        passive: !(e.onTapStart || e.onPointerStart),
      }),
      i = Ws(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = Vo(t, i);
  }
  unmount() {
    this.removeStartListeners(),
      this.removeEndListeners(),
      this.removeAccessibleListeners();
  }
}
const Q_ = new WeakMap(),
  Jy = new WeakMap(),
  Y8 = (n) => {
    const e = Q_.get(n.target);
    e && e(n);
  },
  Q8 = (n) => {
    n.forEach(Y8);
  };
function q8({ root: n, ...e }) {
  const t = n || document;
  Jy.has(t) || Jy.set(t, {});
  const i = Jy.get(t),
    r = JSON.stringify(e);
  return i[r] || (i[r] = new IntersectionObserver(Q8, { root: n, ...e })), i[r];
}
function Z8(n, e, t) {
  const i = q8(e);
  return (
    Q_.set(n, t),
    i.observe(n),
    () => {
      Q_.delete(n), i.unobserve(n);
    }
  );
}
const $8 = { some: 0, all: 1 };
class e6 extends oa {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1);
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(),
      { root: t, margin: i, amount: r = "some", once: s } = e,
      o = {
        root: t ? t.current : void 0,
        rootMargin: i,
        threshold: typeof r == "number" ? r : $8[r],
      },
      a = (l) => {
        const { isIntersecting: u } = l;
        if (
          this.isInView === u ||
          ((this.isInView = u), s && !u && this.hasEnteredView)
        )
          return;
        u && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", u);
        const { onViewportEnter: h, onViewportLeave: d } = this.node.getProps(),
          p = u ? h : d;
        p && p(l);
      };
    return Z8(this.node.current, o, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u") return;
    const { props: e, prevProps: t } = this.node;
    ["amount", "margin", "root"].some(t6(e, t)) && this.startObserver();
  }
  unmount() {}
}
function t6({ viewport: n = {} }, { viewport: e = {} } = {}) {
  return (t) => n[t] !== e[t];
}
const n6 = {
  inView: { Feature: e6 },
  tap: { Feature: K8 },
  focus: { Feature: J8 },
  hover: { Feature: X8 },
};
function cI(n, e) {
  if (!Array.isArray(e)) return !1;
  const t = e.length;
  if (t !== n.length) return !1;
  for (let i = 0; i < t; i++) if (e[i] !== n[i]) return !1;
  return !0;
}
function i6(n) {
  const e = {};
  return n.values.forEach((t, i) => (e[i] = t.get())), e;
}
function r6(n) {
  const e = {};
  return n.values.forEach((t, i) => (e[i] = t.getVelocity())), e;
}
function p0(n, e, t) {
  const i = n.getProps();
  return _S(i, e, t !== void 0 ? t : i.custom, i6(n), r6(n));
}
const s6 = "framerAppearId",
  o6 = "data-" + yS(s6);
let a6 = Ln,
  AS = Ln;
const Wo = (n) => n * 1e3,
  Ks = (n) => n / 1e3,
  l6 = { current: !1 },
  uI = (n) => Array.isArray(n) && typeof n[0] == "number";
function fI(n) {
  return !!(
    !n ||
    (typeof n == "string" && hI[n]) ||
    uI(n) ||
    (Array.isArray(n) && n.every(fI))
  );
}
const df = ([n, e, t, i]) => `cubic-bezier(${n}, ${e}, ${t}, ${i})`,
  hI = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: df([0, 0.65, 0.55, 1]),
    circOut: df([0.55, 0, 1, 0.45]),
    backIn: df([0.31, 0.01, 0.66, -0.59]),
    backOut: df([0.33, 1.53, 0.69, 0.99]),
  };
function dI(n) {
  if (n) return uI(n) ? df(n) : Array.isArray(n) ? n.map(dI) : hI[n];
}
function c6(
  n,
  e,
  t,
  {
    delay: i = 0,
    duration: r,
    repeat: s = 0,
    repeatType: o = "loop",
    ease: a,
    times: l,
  } = {}
) {
  const u = { [e]: t };
  l && (u.offset = l);
  const h = dI(a);
  return (
    Array.isArray(h) && (u.easing = h),
    n.animate(u, {
      delay: i,
      duration: r,
      easing: Array.isArray(h) ? "linear" : h,
      fill: "both",
      iterations: s + 1,
      direction: o === "reverse" ? "alternate" : "normal",
    })
  );
}
const NC = {
    waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate"),
  },
  Ky = {},
  pI = {};
for (const n in NC)
  pI[n] = () => (Ky[n] === void 0 && (Ky[n] = NC[n]()), Ky[n]);
function u6(n, { repeat: e, repeatType: t = "loop" }) {
  const i = e && t !== "loop" && e % 2 === 1 ? 0 : n.length - 1;
  return n[i];
}
const mI = (n, e, t) =>
    (((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n,
  f6 = 1e-7,
  h6 = 12;
function d6(n, e, t, i, r) {
  let s,
    o,
    a = 0;
  do (o = e + (t - e) / 2), (s = mI(o, i, r) - n), s > 0 ? (t = o) : (e = o);
  while (Math.abs(s) > f6 && ++a < h6);
  return o;
}
function zh(n, e, t, i) {
  if (n === e && t === i) return Ln;
  const r = (s) => d6(s, 0, 1, n, t);
  return (s) => (s === 0 || s === 1 ? s : mI(r(s), e, i));
}
const p6 = zh(0.42, 0, 1, 1),
  m6 = zh(0, 0, 0.58, 1),
  gI = zh(0.42, 0, 0.58, 1),
  g6 = (n) => Array.isArray(n) && typeof n[0] != "number",
  vI = (n) => (e) => e <= 0.5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2,
  yI = (n) => (e) => 1 - n(1 - e),
  xI = (n) => 1 - Math.sin(Math.acos(n)),
  SS = yI(xI),
  v6 = vI(SS),
  _I = zh(0.33, 1.53, 0.69, 0.99),
  MS = yI(_I),
  y6 = vI(MS),
  x6 = (n) =>
    (n *= 2) < 1 ? 0.5 * MS(n) : 0.5 * (2 - Math.pow(2, -10 * (n - 1))),
  _6 = {
    linear: Ln,
    easeIn: p6,
    easeInOut: gI,
    easeOut: m6,
    circIn: xI,
    circInOut: v6,
    circOut: SS,
    backIn: MS,
    backInOut: y6,
    backOut: _I,
    anticipate: x6,
  },
  UC = (n) => {
    if (Array.isArray(n)) {
      AS(n.length === 4);
      const [e, t, i, r] = n;
      return zh(e, t, i, r);
    } else if (typeof n == "string") return _6[n];
    return n;
  },
  ES = (n, e) => (t) =>
    !!(
      (kh(t) && v8.test(t) && t.startsWith(n)) ||
      (e && Object.prototype.hasOwnProperty.call(t, e))
    ),
  AI = (n, e, t) => (i) => {
    if (!kh(i)) return i;
    const [r, s, o, a] = i.match(f0);
    return {
      [n]: parseFloat(r),
      [e]: parseFloat(s),
      [t]: parseFloat(o),
      alpha: a !== void 0 ? parseFloat(a) : 1,
    };
  },
  A6 = (n) => Zo(0, 255, n),
  Yy = { ...vl, transform: (n) => Math.round(A6(n)) },
  Xa = {
    test: ES("rgb", "red"),
    parse: AI("red", "green", "blue"),
    transform: ({ red: n, green: e, blue: t, alpha: i = 1 }) =>
      "rgba(" +
      Yy.transform(n) +
      ", " +
      Yy.transform(e) +
      ", " +
      Yy.transform(t) +
      ", " +
      Rf(bf.transform(i)) +
      ")",
  };
function S6(n) {
  let e = "",
    t = "",
    i = "",
    r = "";
  return (
    n.length > 5
      ? ((e = n.substring(1, 3)),
        (t = n.substring(3, 5)),
        (i = n.substring(5, 7)),
        (r = n.substring(7, 9)))
      : ((e = n.substring(1, 2)),
        (t = n.substring(2, 3)),
        (i = n.substring(3, 4)),
        (r = n.substring(4, 5)),
        (e += e),
        (t += t),
        (i += i),
        (r += r)),
    {
      red: parseInt(e, 16),
      green: parseInt(t, 16),
      blue: parseInt(i, 16),
      alpha: r ? parseInt(r, 16) / 255 : 1,
    }
  );
}
const q_ = { test: ES("#"), parse: S6, transform: Xa.transform },
  Mc = {
    test: ES("hsl", "hue"),
    parse: AI("hue", "saturation", "lightness"),
    transform: ({ hue: n, saturation: e, lightness: t, alpha: i = 1 }) =>
      "hsla(" +
      Math.round(n) +
      ", " +
      ys.transform(Rf(e)) +
      ", " +
      ys.transform(Rf(t)) +
      ", " +
      Rf(bf.transform(i)) +
      ")",
  },
  mi = {
    test: (n) => Xa.test(n) || q_.test(n) || Mc.test(n),
    parse: (n) =>
      Xa.test(n) ? Xa.parse(n) : Mc.test(n) ? Mc.parse(n) : q_.parse(n),
    transform: (n) =>
      kh(n) ? n : n.hasOwnProperty("red") ? Xa.transform(n) : Mc.transform(n),
  },
  an = (n, e, t) => -t * n + t * e + n;
function Qy(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * (2 / 3 - t) * 6
      : n
  );
}
function M6({ hue: n, saturation: e, lightness: t, alpha: i }) {
  (n /= 360), (e /= 100), (t /= 100);
  let r = 0,
    s = 0,
    o = 0;
  if (!e) r = s = o = t;
  else {
    const a = t < 0.5 ? t * (1 + e) : t + e - t * e,
      l = 2 * t - a;
    (r = Qy(l, a, n + 1 / 3)), (s = Qy(l, a, n)), (o = Qy(l, a, n - 1 / 3));
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: i,
  };
}
const qy = (n, e, t) => {
    const i = n * n;
    return Math.sqrt(Math.max(0, t * (e * e - i) + i));
  },
  E6 = [q_, Xa, Mc],
  w6 = (n) => E6.find((e) => e.test(n));
function OC(n) {
  const e = w6(n);
  let t = e.parse(n);
  return e === Mc && (t = M6(t)), t;
}
const SI = (n, e) => {
  const t = OC(n),
    i = OC(e),
    r = { ...t };
  return (s) => (
    (r.red = qy(t.red, i.red, s)),
    (r.green = qy(t.green, i.green, s)),
    (r.blue = qy(t.blue, i.blue, s)),
    (r.alpha = an(t.alpha, i.alpha, s)),
    Xa.transform(r)
  );
};
function T6(n) {
  var e, t;
  return (
    isNaN(n) &&
    kh(n) &&
    (((e = n.match(f0)) === null || e === void 0 ? void 0 : e.length) || 0) +
      (((t = n.match(JL)) === null || t === void 0 ? void 0 : t.length) || 0) >
      0
  );
}
const MI = { regex: m8, countKey: "Vars", token: "${v}", parse: Ln },
  EI = { regex: JL, countKey: "Colors", token: "${c}", parse: mi.parse },
  wI = { regex: f0, countKey: "Numbers", token: "${n}", parse: vl.parse };
function Zy(n, { regex: e, countKey: t, token: i, parse: r }) {
  const s = n.tokenised.match(e);
  s &&
    ((n["num" + t] = s.length),
    (n.tokenised = n.tokenised.replace(e, i)),
    n.values.push(...s.map(r)));
}
function rg(n) {
  const e = n.toString(),
    t = {
      value: e,
      tokenised: e,
      values: [],
      numVars: 0,
      numColors: 0,
      numNumbers: 0,
    };
  return t.value.includes("var(--") && Zy(t, MI), Zy(t, EI), Zy(t, wI), t;
}
function TI(n) {
  return rg(n).values;
}
function CI(n) {
  const { values: e, numColors: t, numVars: i, tokenised: r } = rg(n),
    s = e.length;
  return (o) => {
    let a = r;
    for (let l = 0; l < s; l++)
      l < i
        ? (a = a.replace(MI.token, o[l]))
        : l < i + t
        ? (a = a.replace(EI.token, mi.transform(o[l])))
        : (a = a.replace(wI.token, Rf(o[l])));
    return a;
  };
}
const C6 = (n) => (typeof n == "number" ? 0 : n);
function b6(n) {
  const e = TI(n);
  return CI(n)(e.map(C6));
}
const $o = {
    test: T6,
    parse: TI,
    createTransformer: CI,
    getAnimatableNone: b6,
  },
  bI = (n, e) => (t) => `${t > 0 ? e : n}`;
function RI(n, e) {
  return typeof n == "number"
    ? (t) => an(n, e, t)
    : mi.test(n)
    ? SI(n, e)
    : n.startsWith("var(")
    ? bI(n, e)
    : BI(n, e);
}
const PI = (n, e) => {
    const t = [...n],
      i = t.length,
      r = n.map((s, o) => RI(s, e[o]));
    return (s) => {
      for (let o = 0; o < i; o++) t[o] = r[o](s);
      return t;
    };
  },
  R6 = (n, e) => {
    const t = { ...n, ...e },
      i = {};
    for (const r in t)
      n[r] !== void 0 && e[r] !== void 0 && (i[r] = RI(n[r], e[r]));
    return (r) => {
      for (const s in i) t[s] = i[s](r);
      return t;
    };
  },
  BI = (n, e) => {
    const t = $o.createTransformer(e),
      i = rg(n),
      r = rg(e);
    return i.numVars === r.numVars &&
      i.numColors === r.numColors &&
      i.numNumbers >= r.numNumbers
      ? Vo(PI(i.values, r.values), t)
      : bI(n, e);
  },
  hh = (n, e, t) => {
    const i = e - n;
    return i === 0 ? 1 : (t - n) / i;
  },
  kC = (n, e) => (t) => an(n, e, t);
function P6(n) {
  return typeof n == "number"
    ? kC
    : typeof n == "string"
    ? mi.test(n)
      ? SI
      : BI
    : Array.isArray(n)
    ? PI
    : typeof n == "object"
    ? R6
    : kC;
}
function B6(n, e, t) {
  const i = [],
    r = t || P6(n[0]),
    s = n.length - 1;
  for (let o = 0; o < s; o++) {
    let a = r(n[o], n[o + 1]);
    if (e) {
      const l = Array.isArray(e) ? e[o] || Ln : e;
      a = Vo(l, a);
    }
    i.push(a);
  }
  return i;
}
function LI(n, e, { clamp: t = !0, ease: i, mixer: r } = {}) {
  const s = n.length;
  if ((AS(s === e.length), s === 1)) return () => e[0];
  n[0] > n[s - 1] && ((n = [...n].reverse()), (e = [...e].reverse()));
  const o = B6(e, i, r),
    a = o.length,
    l = (u) => {
      let h = 0;
      if (a > 1) for (; h < n.length - 2 && !(u < n[h + 1]); h++);
      const d = hh(n[h], n[h + 1], u);
      return o[h](d);
    };
  return t ? (u) => l(Zo(n[0], n[s - 1], u)) : l;
}
function L6(n, e) {
  const t = n[n.length - 1];
  for (let i = 1; i <= e; i++) {
    const r = hh(0, e, i);
    n.push(an(t, 1, r));
  }
}
function I6(n) {
  const e = [0];
  return L6(e, n.length - 1), e;
}
function D6(n, e) {
  return n.map((t) => t * e);
}
function F6(n, e) {
  return n.map(() => e || gI).splice(0, n.length - 1);
}
function sg({
  duration: n = 300,
  keyframes: e,
  times: t,
  ease: i = "easeInOut",
}) {
  const r = g6(i) ? i.map(UC) : UC(i),
    s = { done: !1, value: e[0] },
    o = D6(t && t.length === e.length ? t : I6(e), n),
    a = LI(o, e, { ease: Array.isArray(r) ? r : F6(e, r) });
  return {
    calculatedDuration: n,
    next: (l) => ((s.value = a(l)), (s.done = l >= n), s),
  };
}
function II(n, e) {
  return e ? n * (1e3 / e) : 0;
}
const N6 = 5;
function DI(n, e, t) {
  const i = Math.max(e - N6, 0);
  return II(t - n(i), e - i);
}
const $y = 0.001,
  U6 = 0.01,
  HC = 10,
  O6 = 0.05,
  k6 = 1;
function H6({
  duration: n = 800,
  bounce: e = 0.25,
  velocity: t = 0,
  mass: i = 1,
}) {
  let r, s;
  a6(n <= Wo(HC));
  let o = 1 - e;
  (o = Zo(O6, k6, o)),
    (n = Zo(U6, HC, Ks(n))),
    o < 1
      ? ((r = (u) => {
          const h = u * o,
            d = h * n,
            p = h - t,
            m = Z_(u, o),
            y = Math.exp(-d);
          return $y - (p / m) * y;
        }),
        (s = (u) => {
          const d = u * o * n,
            p = d * t + t,
            m = Math.pow(o, 2) * Math.pow(u, 2) * n,
            y = Math.exp(-d),
            M = Z_(Math.pow(u, 2), o);
          return ((-r(u) + $y > 0 ? -1 : 1) * ((p - m) * y)) / M;
        }))
      : ((r = (u) => {
          const h = Math.exp(-u * n),
            d = (u - t) * n + 1;
          return -$y + h * d;
        }),
        (s = (u) => {
          const h = Math.exp(-u * n),
            d = (t - u) * (n * n);
          return h * d;
        }));
  const a = 5 / n,
    l = G6(r, s, a);
  if (((n = Wo(n)), isNaN(l)))
    return { stiffness: 100, damping: 10, duration: n };
  {
    const u = Math.pow(l, 2) * i;
    return { stiffness: u, damping: o * 2 * Math.sqrt(i * u), duration: n };
  }
}
const z6 = 12;
function G6(n, e, t) {
  let i = t;
  for (let r = 1; r < z6; r++) i = i - n(i) / e(i);
  return i;
}
function Z_(n, e) {
  return n * Math.sqrt(1 - e * e);
}
const V6 = ["duration", "bounce"],
  W6 = ["stiffness", "damping", "mass"];
function zC(n, e) {
  return e.some((t) => n[t] !== void 0);
}
function j6(n) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...n,
  };
  if (!zC(n, W6) && zC(n, V6)) {
    const t = H6(n);
    (e = { ...e, ...t, velocity: 0, mass: 1 }), (e.isResolvedFromDuration = !0);
  }
  return e;
}
function FI({ keyframes: n, restDelta: e, restSpeed: t, ...i }) {
  const r = n[0],
    s = n[n.length - 1],
    o = { done: !1, value: r },
    {
      stiffness: a,
      damping: l,
      mass: u,
      velocity: h,
      duration: d,
      isResolvedFromDuration: p,
    } = j6(i),
    m = h ? -Ks(h) : 0,
    y = l / (2 * Math.sqrt(a * u)),
    M = s - r,
    A = Ks(Math.sqrt(a / u)),
    g = Math.abs(M) < 5;
  t || (t = g ? 0.01 : 2), e || (e = g ? 0.005 : 0.5);
  let x;
  if (y < 1) {
    const _ = Z_(A, y);
    x = (E) => {
      const T = Math.exp(-y * A * E);
      return (
        s - T * (((m + y * A * M) / _) * Math.sin(_ * E) + M * Math.cos(_ * E))
      );
    };
  } else if (y === 1) x = (_) => s - Math.exp(-A * _) * (M + (m + A * M) * _);
  else {
    const _ = A * Math.sqrt(y * y - 1);
    x = (E) => {
      const T = Math.exp(-y * A * E),
        R = Math.min(_ * E, 300);
      return (
        s - (T * ((m + y * A * M) * Math.sinh(R) + _ * M * Math.cosh(R))) / _
      );
    };
  }
  return {
    calculatedDuration: (p && d) || null,
    next: (_) => {
      const E = x(_);
      if (p) o.done = _ >= d;
      else {
        let T = m;
        _ !== 0 && (y < 1 ? (T = DI(x, _, E)) : (T = 0));
        const R = Math.abs(T) <= t,
          P = Math.abs(s - E) <= e;
        o.done = R && P;
      }
      return (o.value = o.done ? s : E), o;
    },
  };
}
function GC({
  keyframes: n,
  velocity: e = 0,
  power: t = 0.8,
  timeConstant: i = 325,
  bounceDamping: r = 10,
  bounceStiffness: s = 500,
  modifyTarget: o,
  min: a,
  max: l,
  restDelta: u = 0.5,
  restSpeed: h,
}) {
  const d = n[0],
    p = { done: !1, value: d },
    m = (B) => (a !== void 0 && B < a) || (l !== void 0 && B > l),
    y = (B) =>
      a === void 0
        ? l
        : l === void 0 || Math.abs(a - B) < Math.abs(l - B)
        ? a
        : l;
  let M = t * e;
  const A = d + M,
    g = o === void 0 ? A : o(A);
  g !== A && (M = g - d);
  const x = (B) => -M * Math.exp(-B / i),
    _ = (B) => g + x(B),
    E = (B) => {
      const b = x(B),
        L = _(B);
      (p.done = Math.abs(b) <= u), (p.value = p.done ? g : L);
    };
  let T, R;
  const P = (B) => {
    m(p.value) &&
      ((T = B),
      (R = FI({
        keyframes: [p.value, y(p.value)],
        velocity: DI(_, B, p.value),
        damping: r,
        stiffness: s,
        restDelta: u,
        restSpeed: h,
      })));
  };
  return (
    P(0),
    {
      calculatedDuration: null,
      next: (B) => {
        let b = !1;
        return (
          !R && T === void 0 && ((b = !0), E(B), P(B)),
          T !== void 0 && B > T ? R.next(B - T) : (!b && E(B), p)
        );
      },
    }
  );
}
const X6 = (n) => {
    const e = ({ timestamp: t }) => n(t);
    return {
      start: () => ln.update(e, !0),
      stop: () => eo(e),
      now: () => (nn.isProcessing ? nn.timestamp : performance.now()),
    };
  },
  VC = 2e4;
function WC(n) {
  let e = 0;
  const t = 50;
  let i = n.next(e);
  for (; !i.done && e < VC; ) (e += t), (i = n.next(e));
  return e >= VC ? 1 / 0 : e;
}
const J6 = { decay: GC, inertia: GC, tween: sg, keyframes: sg, spring: FI };
function og({
  autoplay: n = !0,
  delay: e = 0,
  driver: t = X6,
  keyframes: i,
  type: r = "keyframes",
  repeat: s = 0,
  repeatDelay: o = 0,
  repeatType: a = "loop",
  onPlay: l,
  onStop: u,
  onComplete: h,
  onUpdate: d,
  ...p
}) {
  let m = 1,
    y = !1,
    M,
    A;
  const g = () => {
    A = new Promise((U) => {
      M = U;
    });
  };
  g();
  let x;
  const _ = J6[r] || sg;
  let E;
  _ !== sg &&
    typeof i[0] != "number" &&
    ((E = LI([0, 100], i, { clamp: !1 })), (i = [0, 100]));
  const T = _({ ...p, keyframes: i });
  let R;
  a === "mirror" &&
    (R = _({
      ...p,
      keyframes: [...i].reverse(),
      velocity: -(p.velocity || 0),
    }));
  let P = "idle",
    B = null,
    b = null,
    L = null;
  T.calculatedDuration === null && s && (T.calculatedDuration = WC(T));
  const { calculatedDuration: z } = T;
  let $ = 1 / 0,
    X = 1 / 0;
  z !== null && (($ = z + o), (X = $ * (s + 1) - o));
  let Y = 0;
  const K = (U) => {
      if (b === null) return;
      m > 0 && (b = Math.min(b, U)),
        m < 0 && (b = Math.min(U - X / m, b)),
        B !== null ? (Y = B) : (Y = Math.round(U - b) * m);
      const j = Y - e * (m >= 0 ? 1 : -1),
        he = m >= 0 ? j < 0 : j > X;
      (Y = Math.max(j, 0)), P === "finished" && B === null && (Y = X);
      let ae = Y,
        xe = T;
      if (s) {
        const ct = Y / $;
        let tt = Math.floor(ct),
          Me = ct % 1;
        !Me && ct >= 1 && (Me = 1),
          Me === 1 && tt--,
          (tt = Math.min(tt, s + 1));
        const V = !!(tt % 2);
        V &&
          (a === "reverse"
            ? ((Me = 1 - Me), o && (Me -= o / $))
            : a === "mirror" && (xe = R));
        let ye = Zo(0, 1, Me);
        Y > X && (ye = a === "reverse" && V ? 1 : 0), (ae = ye * $);
      }
      const Ae = he ? { done: !1, value: i[0] } : xe.next(ae);
      E && (Ae.value = E(Ae.value));
      let { done: Le } = Ae;
      !he && z !== null && (Le = m >= 0 ? Y >= X : Y <= 0);
      const Ve = B === null && (P === "finished" || (P === "running" && Le));
      return d && d(Ae.value), Ve && I(), Ae;
    },
    ie = () => {
      x && x.stop(), (x = void 0);
    },
    ee = () => {
      (P = "idle"), ie(), M(), g(), (b = L = null);
    },
    I = () => {
      (P = "finished"), h && h(), ie(), M();
    },
    G = () => {
      if (y) return;
      x || (x = t(K));
      const U = x.now();
      l && l(),
        B !== null ? (b = U - B) : (!b || P === "finished") && (b = U),
        P === "finished" && g(),
        (L = b),
        (B = null),
        (P = "running"),
        x.start();
    };
  n && G();
  const k = {
    then(U, j) {
      return A.then(U, j);
    },
    get time() {
      return Ks(Y);
    },
    set time(U) {
      (U = Wo(U)),
        (Y = U),
        B !== null || !x || m === 0 ? (B = U) : (b = x.now() - U / m);
    },
    get duration() {
      const U = T.calculatedDuration === null ? WC(T) : T.calculatedDuration;
      return Ks(U);
    },
    get speed() {
      return m;
    },
    set speed(U) {
      U === m || !x || ((m = U), (k.time = Ks(Y)));
    },
    get state() {
      return P;
    },
    play: G,
    pause: () => {
      (P = "paused"), (B = Y);
    },
    stop: () => {
      (y = !0), P !== "idle" && ((P = "idle"), u && u(), ee());
    },
    cancel: () => {
      L !== null && K(L), ee();
    },
    complete: () => {
      P = "finished";
    },
    sample: (U) => ((b = 0), K(U)),
  };
  return k;
}
const K6 = new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform",
    "backgroundColor",
  ]),
  Qp = 10,
  Y6 = 2e4,
  Q6 = (n, e) => e.type === "spring" || n === "backgroundColor" || !fI(e.ease);
function q6(n, e, { onUpdate: t, onComplete: i, ...r }) {
  if (
    !(
      pI.waapi() &&
      K6.has(e) &&
      !r.repeatDelay &&
      r.repeatType !== "mirror" &&
      r.damping !== 0 &&
      r.type !== "inertia"
    )
  )
    return !1;
  let o = !1,
    a,
    l;
  const u = () => {
    l = new Promise((g) => {
      a = g;
    });
  };
  u();
  let { keyframes: h, duration: d = 300, ease: p, times: m } = r;
  if (Q6(e, r)) {
    const g = og({ ...r, repeat: 0, delay: 0 });
    let x = { done: !1, value: h[0] };
    const _ = [];
    let E = 0;
    for (; !x.done && E < Y6; ) (x = g.sample(E)), _.push(x.value), (E += Qp);
    (m = void 0), (h = _), (d = E - Qp), (p = "linear");
  }
  const y = c6(n.owner.current, e, h, { ...r, duration: d, ease: p, times: m }),
    M = () => y.cancel(),
    A = () => {
      ln.update(M), a(), u();
    };
  return (
    (y.onfinish = () => {
      n.set(u6(h, r)), i && i(), A();
    }),
    {
      then(g, x) {
        return l.then(g, x);
      },
      get time() {
        return Ks(y.currentTime || 0);
      },
      set time(g) {
        y.currentTime = Wo(g);
      },
      get speed() {
        return y.playbackRate;
      },
      set speed(g) {
        y.playbackRate = g;
      },
      get duration() {
        return Ks(d);
      },
      play: () => {
        o || (y.play(), eo(M));
      },
      pause: () => y.pause(),
      stop: () => {
        if (((o = !0), y.playState === "idle")) return;
        const { currentTime: g } = y;
        if (g) {
          const x = og({ ...r, autoplay: !1 });
          n.setWithVelocity(x.sample(g - Qp).value, x.sample(g).value, Qp);
        }
        A();
      },
      complete: () => y.finish(),
      cancel: A,
    }
  );
}
function Z6({ keyframes: n, delay: e, onUpdate: t, onComplete: i }) {
  const r = () => (
    t && t(n[n.length - 1]),
    i && i(),
    {
      time: 0,
      speed: 1,
      duration: 0,
      play: Ln,
      pause: Ln,
      stop: Ln,
      then: (s) => (s(), Promise.resolve()),
      cancel: Ln,
      complete: Ln,
    }
  );
  return e
    ? og({ keyframes: [0, 1], duration: 0, delay: e, onComplete: r })
    : r();
}
const $6 = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
  eW = (n) => ({
    type: "spring",
    stiffness: 550,
    damping: n === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  tW = { type: "keyframes", duration: 0.8 },
  nW = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  iW = (n, { keyframes: e }) =>
    e.length > 2
      ? tW
      : gl.has(n)
      ? n.startsWith("scale")
        ? eW(e[1])
        : $6
      : nW,
  $_ = (n, e) =>
    n === "zIndex"
      ? !1
      : !!(
          typeof e == "number" ||
          Array.isArray(e) ||
          (typeof e == "string" &&
            ($o.test(e) || e === "0") &&
            !e.startsWith("url("))
        ),
  rW = new Set(["brightness", "contrast", "saturate", "opacity"]);
function sW(n) {
  const [e, t] = n.slice(0, -1).split("(");
  if (e === "drop-shadow") return n;
  const [i] = t.match(f0) || [];
  if (!i) return n;
  const r = t.replace(i, "");
  let s = rW.has(e) ? 1 : 0;
  return i !== t && (s *= 100), e + "(" + s + r + ")";
}
const oW = /([a-z-]*)\(.*?\)/g,
  eA = {
    ...$o,
    getAnimatableNone: (n) => {
      const e = n.match(oW);
      return e ? e.map(sW).join(" ") : n;
    },
  },
  aW = {
    ...KL,
    color: mi,
    backgroundColor: mi,
    outlineColor: mi,
    fill: mi,
    stroke: mi,
    borderColor: mi,
    borderTopColor: mi,
    borderRightColor: mi,
    borderBottomColor: mi,
    borderLeftColor: mi,
    filter: eA,
    WebkitFilter: eA,
  },
  wS = (n) => aW[n];
function NI(n, e) {
  let t = wS(n);
  return (
    t !== eA && (t = $o), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
  );
}
const UI = (n) => /^0[^.\s]+$/.test(n);
function lW(n) {
  if (typeof n == "number") return n === 0;
  if (n !== null) return n === "none" || n === "0" || UI(n);
}
function cW(n, e, t, i) {
  const r = $_(e, t);
  let s;
  Array.isArray(t) ? (s = [...t]) : (s = [null, t]);
  const o = i.from !== void 0 ? i.from : n.get();
  let a;
  const l = [];
  for (let u = 0; u < s.length; u++)
    s[u] === null && (s[u] = u === 0 ? o : s[u - 1]),
      lW(s[u]) && l.push(u),
      typeof s[u] == "string" && s[u] !== "none" && s[u] !== "0" && (a = s[u]);
  if (r && l.length && a)
    for (let u = 0; u < l.length; u++) {
      const h = l[u];
      s[h] = NI(e, a);
    }
  return s;
}
function uW({
  when: n,
  delay: e,
  delayChildren: t,
  staggerChildren: i,
  staggerDirection: r,
  repeat: s,
  repeatType: o,
  repeatDelay: a,
  from: l,
  elapsed: u,
  ...h
}) {
  return !!Object.keys(h).length;
}
function OI(n, e) {
  return n[e] || n.default || n;
}
const TS =
  (n, e, t, i = {}) =>
  (r) => {
    const s = OI(i, n) || {},
      o = s.delay || i.delay || 0;
    let { elapsed: a = 0 } = i;
    a = a - Wo(o);
    const l = cW(e, n, t, s),
      u = l[0],
      h = l[l.length - 1],
      d = $_(n, u),
      p = $_(n, h);
    let m = {
      keyframes: l,
      velocity: e.getVelocity(),
      ease: "easeOut",
      ...s,
      delay: -a,
      onUpdate: (y) => {
        e.set(y), s.onUpdate && s.onUpdate(y);
      },
      onComplete: () => {
        r(), s.onComplete && s.onComplete();
      },
    };
    if (
      (uW(s) || (m = { ...m, ...iW(n, m) }),
      m.duration && (m.duration = Wo(m.duration)),
      m.repeatDelay && (m.repeatDelay = Wo(m.repeatDelay)),
      !d || !p || l6.current || s.type === !1)
    )
      return Z6(m);
    if (
      e.owner &&
      e.owner.current instanceof HTMLElement &&
      !e.owner.getProps().onUpdate
    ) {
      const y = q6(e, n, m);
      if (y) return y;
    }
    return og(m);
  };
function ag(n) {
  return !!(Ii(n) && n.add);
}
const fW = (n) => /^\-?\d*\.?\d+$/.test(n);
function CS(n, e) {
  n.indexOf(e) === -1 && n.push(e);
}
function bS(n, e) {
  const t = n.indexOf(e);
  t > -1 && n.splice(t, 1);
}
class RS {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return CS(this.subscriptions, e), () => bS(this.subscriptions, e);
  }
  notify(e, t, i) {
    const r = this.subscriptions.length;
    if (r)
      if (r === 1) this.subscriptions[0](e, t, i);
      else
        for (let s = 0; s < r; s++) {
          const o = this.subscriptions[s];
          o && o(e, t, i);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const hW = (n) => !isNaN(parseFloat(n));
class dW {
  constructor(e, t = {}) {
    (this.version = "10.12.20"),
      (this.timeDelta = 0),
      (this.lastUpdated = 0),
      (this.canTrackVelocity = !1),
      (this.events = {}),
      (this.updateAndNotify = (i, r = !0) => {
        (this.prev = this.current), (this.current = i);
        const { delta: s, timestamp: o } = nn;
        this.lastUpdated !== o &&
          ((this.timeDelta = s),
          (this.lastUpdated = o),
          ln.postRender(this.scheduleVelocityCheck)),
          this.prev !== this.current &&
            this.events.change &&
            this.events.change.notify(this.current),
          this.events.velocityChange &&
            this.events.velocityChange.notify(this.getVelocity()),
          r &&
            this.events.renderRequest &&
            this.events.renderRequest.notify(this.current);
      }),
      (this.scheduleVelocityCheck = () => ln.postRender(this.velocityCheck)),
      (this.velocityCheck = ({ timestamp: i }) => {
        i !== this.lastUpdated &&
          ((this.prev = this.current),
          this.events.velocityChange &&
            this.events.velocityChange.notify(this.getVelocity()));
      }),
      (this.hasAnimated = !1),
      (this.prev = this.current = e),
      (this.canTrackVelocity = hW(this.current)),
      (this.owner = t.owner);
  }
  onChange(e) {
    return this.on("change", e);
  }
  on(e, t) {
    this.events[e] || (this.events[e] = new RS());
    const i = this.events[e].add(t);
    return e === "change"
      ? () => {
          i(),
            ln.read(() => {
              this.events.change.getSize() || this.stop();
            });
        }
      : i;
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear();
  }
  attach(e, t) {
    (this.passiveEffect = e), (this.stopPassiveEffect = t);
  }
  set(e, t = !0) {
    !t || !this.passiveEffect
      ? this.updateAndNotify(e, t)
      : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, t, i) {
    this.set(t), (this.prev = e), (this.timeDelta = i);
  }
  jump(e) {
    this.updateAndNotify(e),
      (this.prev = e),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    return this.canTrackVelocity
      ? II(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
      : 0;
  }
  start(e) {
    return (
      this.stop(),
      new Promise((t) => {
        (this.hasAnimated = !0),
          (this.animation = e(t)),
          this.events.animationStart && this.events.animationStart.notify();
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation();
      })
    );
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation();
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function tu(n, e) {
  return new dW(n, e);
}
const kI = (n) => (e) => e.test(n),
  pW = { test: (n) => n === "auto", parse: (n) => n },
  HI = [vl, it, ys, _o, x8, y8, pW],
  nf = (n) => HI.find(kI(n)),
  mW = [...HI, mi, $o],
  gW = (n) => mW.find(kI(n));
function vW(n, e, t) {
  n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, tu(t));
}
function yW(n, e) {
  const t = p0(n, e);
  let {
    transitionEnd: i = {},
    transition: r = {},
    ...s
  } = t ? n.makeTargetAnimatable(t, !1) : {};
  s = { ...s, ...i };
  for (const o in s) {
    const a = D8(s[o]);
    vW(n, o, a);
  }
}
function xW(n, e, t) {
  var i, r;
  const s = Object.keys(e).filter((a) => !n.hasValue(a)),
    o = s.length;
  if (o)
    for (let a = 0; a < o; a++) {
      const l = s[a],
        u = e[l];
      let h = null;
      Array.isArray(u) && (h = u[0]),
        h === null &&
          (h =
            (r = (i = t[l]) !== null && i !== void 0 ? i : n.readValue(l)) !==
              null && r !== void 0
              ? r
              : e[l]),
        h != null &&
          (typeof h == "string" && (fW(h) || UI(h))
            ? (h = parseFloat(h))
            : !gW(h) && $o.test(u) && (h = NI(l, u)),
          n.addValue(l, tu(h, { owner: n })),
          t[l] === void 0 && (t[l] = h),
          h !== null && n.setBaseTarget(l, h));
    }
}
function _W(n, e) {
  return e ? (e[n] || e.default || e).from : void 0;
}
function AW(n, e, t) {
  const i = {};
  for (const r in n) {
    const s = _W(r, e);
    if (s !== void 0) i[r] = s;
    else {
      const o = t.getValue(r);
      o && (i[r] = o.get());
    }
  }
  return i;
}
function SW({ protectedKeys: n, needsAnimating: e }, t) {
  const i = n.hasOwnProperty(t) && e[t] !== !0;
  return (e[t] = !1), i;
}
function zI(n, e, { delay: t = 0, transitionOverride: i, type: r } = {}) {
  let {
    transition: s = n.getDefaultTransition(),
    transitionEnd: o,
    ...a
  } = n.makeTargetAnimatable(e);
  const l = n.getValue("willChange");
  i && (s = i);
  const u = [],
    h = r && n.animationState && n.animationState.getState()[r];
  for (const d in a) {
    const p = n.getValue(d),
      m = a[d];
    if (!p || m === void 0 || (h && SW(h, d))) continue;
    const y = { delay: t, elapsed: 0, ...s };
    if (window.HandoffAppearAnimations && !p.hasAnimated) {
      const A = n.getProps()[o6];
      A && (y.elapsed = window.HandoffAppearAnimations(A, d, p, ln));
    }
    p.start(TS(d, p, m, n.shouldReduceMotion && gl.has(d) ? { type: !1 } : y));
    const M = p.animation;
    ag(l) && (l.add(d), M.then(() => l.remove(d))), u.push(M);
  }
  return (
    o &&
      Promise.all(u).then(() => {
        o && yW(n, o);
      }),
    u
  );
}
function tA(n, e, t = {}) {
  const i = p0(n, e, t.custom);
  let { transition: r = n.getDefaultTransition() || {} } = i || {};
  t.transitionOverride && (r = t.transitionOverride);
  const s = i ? () => Promise.all(zI(n, i, t)) : () => Promise.resolve(),
    o =
      n.variantChildren && n.variantChildren.size
        ? (l = 0) => {
            const {
              delayChildren: u = 0,
              staggerChildren: h,
              staggerDirection: d,
            } = r;
            return MW(n, e, u + l, h, d, t);
          }
        : () => Promise.resolve(),
    { when: a } = r;
  if (a) {
    const [l, u] = a === "beforeChildren" ? [s, o] : [o, s];
    return l().then(() => u());
  } else return Promise.all([s(), o(t.delay)]);
}
function MW(n, e, t = 0, i = 0, r = 1, s) {
  const o = [],
    a = (n.variantChildren.size - 1) * i,
    l = r === 1 ? (u = 0) => u * i : (u = 0) => a - u * i;
  return (
    Array.from(n.variantChildren)
      .sort(EW)
      .forEach((u, h) => {
        u.notify("AnimationStart", e),
          o.push(
            tA(u, e, { ...s, delay: t + l(h) }).then(() =>
              u.notify("AnimationComplete", e)
            )
          );
      }),
    Promise.all(o)
  );
}
function EW(n, e) {
  return n.sortNodePosition(e);
}
function wW(n, e, t = {}) {
  n.notify("AnimationStart", e);
  let i;
  if (Array.isArray(e)) {
    const r = e.map((s) => tA(n, s, t));
    i = Promise.all(r);
  } else if (typeof e == "string") i = tA(n, e, t);
  else {
    const r = typeof e == "function" ? p0(n, e, t.custom) : e;
    i = Promise.all(zI(n, r, t));
  }
  return i.then(() => n.notify("AnimationComplete", e));
}
const TW = [...fS].reverse(),
  CW = fS.length;
function bW(n) {
  return (e) =>
    Promise.all(e.map(({ animation: t, options: i }) => wW(n, t, i)));
}
function RW(n) {
  let e = bW(n);
  const t = BW();
  let i = !0;
  const r = (l, u) => {
    const h = p0(n, u);
    if (h) {
      const { transition: d, transitionEnd: p, ...m } = h;
      l = { ...l, ...m, ...p };
    }
    return l;
  };
  function s(l) {
    e = l(n);
  }
  function o(l, u) {
    const h = n.getProps(),
      d = n.getVariantContext(!0) || {},
      p = [],
      m = new Set();
    let y = {},
      M = 1 / 0;
    for (let g = 0; g < CW; g++) {
      const x = TW[g],
        _ = t[x],
        E = h[x] !== void 0 ? h[x] : d[x],
        T = ch(E),
        R = x === u ? _.isActive : null;
      R === !1 && (M = g);
      let P = E === d[x] && E !== h[x] && T;
      if (
        (P && i && n.manuallyAnimateOnMount && (P = !1),
        (_.protectedKeys = { ...y }),
        (!_.isActive && R === null) ||
          (!E && !_.prevProp) ||
          c0(E) ||
          typeof E == "boolean")
      )
        continue;
      const B = PW(_.prevProp, E);
      let b = B || (x === u && _.isActive && !P && T) || (g > M && T);
      const L = Array.isArray(E) ? E : [E];
      let z = L.reduce(r, {});
      R === !1 && (z = {});
      const { prevResolvedValues: $ = {} } = _,
        X = { ...$, ...z },
        Y = (K) => {
          (b = !0), m.delete(K), (_.needsAnimating[K] = !0);
        };
      for (const K in X) {
        const ie = z[K],
          ee = $[K];
        y.hasOwnProperty(K) ||
          (ie !== ee
            ? ig(ie) && ig(ee)
              ? !cI(ie, ee) || B
                ? Y(K)
                : (_.protectedKeys[K] = !0)
              : ie !== void 0
              ? Y(K)
              : m.add(K)
            : ie !== void 0 && m.has(K)
            ? Y(K)
            : (_.protectedKeys[K] = !0));
      }
      (_.prevProp = E),
        (_.prevResolvedValues = z),
        _.isActive && (y = { ...y, ...z }),
        i && n.blockInitialAnimation && (b = !1),
        b &&
          !P &&
          p.push(
            ...L.map((K) => ({ animation: K, options: { type: x, ...l } }))
          );
    }
    if (m.size) {
      const g = {};
      m.forEach((x) => {
        const _ = n.getBaseTarget(x);
        _ !== void 0 && (g[x] = _);
      }),
        p.push({ animation: g });
    }
    let A = !!p.length;
    return (
      i && h.initial === !1 && !n.manuallyAnimateOnMount && (A = !1),
      (i = !1),
      A ? e(p) : Promise.resolve()
    );
  }
  function a(l, u, h) {
    var d;
    if (t[l].isActive === u) return Promise.resolve();
    (d = n.variantChildren) === null ||
      d === void 0 ||
      d.forEach((m) => {
        var y;
        return (y = m.animationState) === null || y === void 0
          ? void 0
          : y.setActive(l, u);
      }),
      (t[l].isActive = u);
    const p = o(h, l);
    for (const m in t) t[m].protectedKeys = {};
    return p;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: s,
    getState: () => t,
  };
}
function PW(n, e) {
  return typeof e == "string" ? e !== n : Array.isArray(e) ? !cI(e, n) : !1;
}
function Ca(n = !1) {
  return {
    isActive: n,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function BW() {
  return {
    animate: Ca(!0),
    whileInView: Ca(),
    whileHover: Ca(),
    whileTap: Ca(),
    whileDrag: Ca(),
    whileFocus: Ca(),
    exit: Ca(),
  };
}
class LW extends oa {
  constructor(e) {
    super(e), e.animationState || (e.animationState = RW(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    this.unmount(), c0(e) && (this.unmount = e.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: t } = this.node.prevProps || {};
    e !== t && this.updateAnimationControlsSubscription();
  }
  unmount() {}
}
let IW = 0;
class DW extends oa {
  constructor() {
    super(...arguments), (this.id = IW++);
  }
  update() {
    if (!this.node.presenceContext) return;
    const {
        isPresent: e,
        onExitComplete: t,
        custom: i,
      } = this.node.presenceContext,
      { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === r) return;
    const s = this.node.animationState.setActive("exit", !e, {
      custom: i ?? this.node.getProps().custom,
    });
    t && !e && s.then(() => t(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {}
}
const FW = { animation: { Feature: LW }, exit: { Feature: DW } },
  jC = (n, e) => Math.abs(n - e);
function NW(n, e) {
  const t = jC(n.x, e.x),
    i = jC(n.y, e.y);
  return Math.sqrt(t ** 2 + i ** 2);
}
class GI {
  constructor(e, t, { transformPagePoint: i } = {}) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const u = tx(this.lastMoveEventInfo, this.history),
          h = this.startEvent !== null,
          d = NW(u.offset, { x: 0, y: 0 }) >= 3;
        if (!h && !d) return;
        const { point: p } = u,
          { timestamp: m } = nn;
        this.history.push({ ...p, timestamp: m });
        const { onStart: y, onMove: M } = this.handlers;
        h ||
          (y && y(this.lastMoveEvent, u),
          (this.startEvent = this.lastMoveEvent)),
          M && M(this.lastMoveEvent, u);
      }),
      (this.handlePointerMove = (u, h) => {
        (this.lastMoveEvent = u),
          (this.lastMoveEventInfo = ex(h, this.transformPagePoint)),
          ln.update(this.updatePoint, !0);
      }),
      (this.handlePointerUp = (u, h) => {
        if ((this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo)))
          return;
        const { onEnd: d, onSessionEnd: p } = this.handlers,
          m = tx(
            u.type === "pointercancel"
              ? this.lastMoveEventInfo
              : ex(h, this.transformPagePoint),
            this.history
          );
        this.startEvent && d && d(u, m), p && p(u, m);
      }),
      !iI(e))
    )
      return;
    (this.handlers = t), (this.transformPagePoint = i);
    const r = h0(e),
      s = ex(r, this.transformPagePoint),
      { point: o } = s,
      { timestamp: a } = nn;
    this.history = [{ ...o, timestamp: a }];
    const { onSessionStart: l } = t;
    l && l(e, tx(s, this.history)),
      (this.removeListeners = Vo(
        Js(window, "pointermove", this.handlePointerMove),
        Js(window, "pointerup", this.handlePointerUp),
        Js(window, "pointercancel", this.handlePointerUp)
      ));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), eo(this.updatePoint);
  }
}
function ex(n, e) {
  return e ? { point: e(n.point) } : n;
}
function XC(n, e) {
  return { x: n.x - e.x, y: n.y - e.y };
}
function tx({ point: n }, e) {
  return {
    point: n,
    delta: XC(n, VI(e)),
    offset: XC(n, UW(e)),
    velocity: OW(e, 0.1),
  };
}
function UW(n) {
  return n[0];
}
function VI(n) {
  return n[n.length - 1];
}
function OW(n, e) {
  if (n.length < 2) return { x: 0, y: 0 };
  let t = n.length - 1,
    i = null;
  const r = VI(n);
  for (; t >= 0 && ((i = n[t]), !(r.timestamp - i.timestamp > Wo(e))); ) t--;
  if (!i) return { x: 0, y: 0 };
  const s = Ks(r.timestamp - i.timestamp);
  if (s === 0) return { x: 0, y: 0 };
  const o = { x: (r.x - i.x) / s, y: (r.y - i.y) / s };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
}
function er(n) {
  return n.max - n.min;
}
function nA(n, e = 0, t = 0.01) {
  return Math.abs(n - e) <= t;
}
function JC(n, e, t, i = 0.5) {
  (n.origin = i),
    (n.originPoint = an(e.min, e.max, n.origin)),
    (n.scale = er(t) / er(e)),
    (nA(n.scale, 1, 1e-4) || isNaN(n.scale)) && (n.scale = 1),
    (n.translate = an(t.min, t.max, n.origin) - n.originPoint),
    (nA(n.translate) || isNaN(n.translate)) && (n.translate = 0);
}
function Pf(n, e, t, i) {
  JC(n.x, e.x, t.x, i ? i.originX : void 0),
    JC(n.y, e.y, t.y, i ? i.originY : void 0);
}
function KC(n, e, t) {
  (n.min = t.min + e.min), (n.max = n.min + er(e));
}
function kW(n, e, t) {
  KC(n.x, e.x, t.x), KC(n.y, e.y, t.y);
}
function YC(n, e, t) {
  (n.min = e.min - t.min), (n.max = n.min + er(e));
}
function Bf(n, e, t) {
  YC(n.x, e.x, t.x), YC(n.y, e.y, t.y);
}
function HW(n, { min: e, max: t }, i) {
  return (
    e !== void 0 && n < e
      ? (n = i ? an(e, n, i.min) : Math.max(n, e))
      : t !== void 0 && n > t && (n = i ? an(t, n, i.max) : Math.min(n, t)),
    n
  );
}
function QC(n, e, t) {
  return {
    min: e !== void 0 ? n.min + e : void 0,
    max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0,
  };
}
function zW(n, { top: e, left: t, bottom: i, right: r }) {
  return { x: QC(n.x, t, r), y: QC(n.y, e, i) };
}
function qC(n, e) {
  let t = e.min - n.min,
    i = e.max - n.max;
  return e.max - e.min < n.max - n.min && ([t, i] = [i, t]), { min: t, max: i };
}
function GW(n, e) {
  return { x: qC(n.x, e.x), y: qC(n.y, e.y) };
}
function VW(n, e) {
  let t = 0.5;
  const i = er(n),
    r = er(e);
  return (
    r > i
      ? (t = hh(e.min, e.max - i, n.min))
      : i > r && (t = hh(n.min, n.max - r, e.min)),
    Zo(0, 1, t)
  );
}
function WW(n, e) {
  const t = {};
  return (
    e.min !== void 0 && (t.min = e.min - n.min),
    e.max !== void 0 && (t.max = e.max - n.min),
    t
  );
}
const iA = 0.35;
function jW(n = iA) {
  return (
    n === !1 ? (n = 0) : n === !0 && (n = iA),
    { x: ZC(n, "left", "right"), y: ZC(n, "top", "bottom") }
  );
}
function ZC(n, e, t) {
  return { min: $C(n, e), max: $C(n, t) };
}
function $C(n, e) {
  return typeof n == "number" ? n : n[e] || 0;
}
const eb = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  Ec = () => ({ x: eb(), y: eb() }),
  tb = () => ({ min: 0, max: 0 }),
  Tn = () => ({ x: tb(), y: tb() });
function cs(n) {
  return [n("x"), n("y")];
}
function WI({ top: n, left: e, right: t, bottom: i }) {
  return { x: { min: e, max: t }, y: { min: n, max: i } };
}
function XW({ x: n, y: e }) {
  return { top: e.min, right: n.max, bottom: e.max, left: n.min };
}
function JW(n, e) {
  if (!e) return n;
  const t = e({ x: n.left, y: n.top }),
    i = e({ x: n.right, y: n.bottom });
  return { top: t.y, left: t.x, bottom: i.y, right: i.x };
}
function nx(n) {
  return n === void 0 || n === 1;
}
function rA({ scale: n, scaleX: e, scaleY: t }) {
  return !nx(n) || !nx(e) || !nx(t);
}
function Ia(n) {
  return rA(n) || jI(n) || n.z || n.rotate || n.rotateX || n.rotateY;
}
function jI(n) {
  return nb(n.x) || nb(n.y);
}
function nb(n) {
  return n && n !== "0%";
}
function lg(n, e, t) {
  const i = n - t,
    r = e * i;
  return t + r;
}
function ib(n, e, t, i, r) {
  return r !== void 0 && (n = lg(n, r, i)), lg(n, t, i) + e;
}
function sA(n, e = 0, t = 1, i, r) {
  (n.min = ib(n.min, e, t, i, r)), (n.max = ib(n.max, e, t, i, r));
}
function XI(n, { x: e, y: t }) {
  sA(n.x, e.translate, e.scale, e.originPoint),
    sA(n.y, t.translate, t.scale, t.originPoint);
}
function KW(n, e, t, i = !1) {
  const r = t.length;
  if (!r) return;
  e.x = e.y = 1;
  let s, o;
  for (let a = 0; a < r; a++) {
    (s = t[a]), (o = s.projectionDelta);
    const l = s.instance;
    (l && l.style && l.style.display === "contents") ||
      (i &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        wc(n, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
      o && ((e.x *= o.x.scale), (e.y *= o.y.scale), XI(n, o)),
      i && Ia(s.latestValues) && wc(n, s.latestValues));
  }
  (e.x = rb(e.x)), (e.y = rb(e.y));
}
function rb(n) {
  return Number.isInteger(n) || n > 1.0000000000001 || n < 0.999999999999
    ? n
    : 1;
}
function wo(n, e) {
  (n.min = n.min + e), (n.max = n.max + e);
}
function sb(n, e, [t, i, r]) {
  const s = e[r] !== void 0 ? e[r] : 0.5,
    o = an(n.min, n.max, s);
  sA(n, e[t], e[i], o, e.scale);
}
const YW = ["x", "scaleX", "originX"],
  QW = ["y", "scaleY", "originY"];
function wc(n, e) {
  sb(n.x, e, YW), sb(n.y, e, QW);
}
function JI(n, e) {
  return WI(JW(n.getBoundingClientRect(), e));
}
function qW(n, e, t) {
  const i = JI(n, t),
    { scroll: r } = e;
  return r && (wo(i.x, r.offset.x), wo(i.y, r.offset.y)), i;
}
const ZW = new WeakMap();
class $W {
  constructor(e) {
    (this.openGlobalLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = Tn()),
      (this.visualElement = e);
  }
  start(e, { snapToCursor: t = !1 } = {}) {
    const { presenceContext: i } = this.visualElement;
    if (i && i.isPresent === !1) return;
    const r = (l) => {
        this.stopAnimation(), t && this.snapToCursor(h0(l, "page").point);
      },
      s = (l, u) => {
        const { drag: h, dragPropagation: d, onDragStart: p } = this.getProps();
        if (
          h &&
          !d &&
          (this.openGlobalLock && this.openGlobalLock(),
          (this.openGlobalLock = sI(h)),
          !this.openGlobalLock)
        )
          return;
        (this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          cs((y) => {
            let M = this.getAxisMotionValue(y).get() || 0;
            if (ys.test(M)) {
              const { projection: A } = this.visualElement;
              if (A && A.layout) {
                const g = A.layout.layoutBox[y];
                g && (M = er(g) * (parseFloat(M) / 100));
              }
            }
            this.originPoint[y] = M;
          }),
          p && ln.update(() => p(l, u), !1, !0);
        const { animationState: m } = this.visualElement;
        m && m.setActive("whileDrag", !0);
      },
      o = (l, u) => {
        const {
          dragPropagation: h,
          dragDirectionLock: d,
          onDirectionLock: p,
          onDrag: m,
        } = this.getProps();
        if (!h && !this.openGlobalLock) return;
        const { offset: y } = u;
        if (d && this.currentDirection === null) {
          (this.currentDirection = ej(y)),
            this.currentDirection !== null && p && p(this.currentDirection);
          return;
        }
        this.updateAxis("x", u.point, y),
          this.updateAxis("y", u.point, y),
          this.visualElement.render(),
          m && m(l, u);
      },
      a = (l, u) => this.stop(l, u);
    this.panSession = new GI(
      e,
      { onSessionStart: r, onStart: s, onMove: o, onSessionEnd: a },
      { transformPagePoint: this.visualElement.getTransformPagePoint() }
    );
  }
  stop(e, t) {
    const i = this.isDragging;
    if ((this.cancel(), !i)) return;
    const { velocity: r } = t;
    this.startAnimation(r);
    const { onDragEnd: s } = this.getProps();
    s && ln.update(() => s(e, t));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: t } = this.visualElement;
    e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0);
    const { dragPropagation: i } = this.getProps();
    !i &&
      this.openGlobalLock &&
      (this.openGlobalLock(), (this.openGlobalLock = null)),
      t && t.setActive("whileDrag", !1);
  }
  updateAxis(e, t, i) {
    const { drag: r } = this.getProps();
    if (!i || !qp(e, r, this.currentDirection)) return;
    const s = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + i[e];
    this.constraints &&
      this.constraints[e] &&
      (o = HW(o, this.constraints[e], this.elastic[e])),
      s.set(o);
  }
  resolveConstraints() {
    const { dragConstraints: e, dragElastic: t } = this.getProps(),
      { layout: i } = this.visualElement.projection || {},
      r = this.constraints;
    e && Sc(e)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : e && i
      ? (this.constraints = zW(i.layoutBox, e))
      : (this.constraints = !1),
      (this.elastic = jW(t)),
      r !== this.constraints &&
        i &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        cs((s) => {
          this.getAxisMotionValue(s) &&
            (this.constraints[s] = WW(i.layoutBox[s], this.constraints[s]));
        });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps();
    if (!e || !Sc(e)) return !1;
    const i = e.current,
      { projection: r } = this.visualElement;
    if (!r || !r.layout) return !1;
    const s = qW(i, r.root, this.visualElement.getTransformPagePoint());
    let o = GW(r.layout.layoutBox, s);
    if (t) {
      const a = t(XW(o));
      (this.hasMutatedConstraints = !!a), a && (o = WI(a));
    }
    return o;
  }
  startAnimation(e) {
    const {
        drag: t,
        dragMomentum: i,
        dragElastic: r,
        dragTransition: s,
        dragSnapToOrigin: o,
        onDragTransitionEnd: a,
      } = this.getProps(),
      l = this.constraints || {},
      u = cs((h) => {
        if (!qp(h, t, this.currentDirection)) return;
        let d = (l && l[h]) || {};
        o && (d = { min: 0, max: 0 });
        const p = r ? 200 : 1e6,
          m = r ? 40 : 1e7,
          y = {
            type: "inertia",
            velocity: i ? e[h] : 0,
            bounceStiffness: p,
            bounceDamping: m,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...d,
          };
        return this.startAxisValueAnimation(h, y);
      });
    return Promise.all(u).then(a);
  }
  startAxisValueAnimation(e, t) {
    const i = this.getAxisMotionValue(e);
    return i.start(TS(e, i, 0, t));
  }
  stopAnimation() {
    cs((e) => this.getAxisMotionValue(e).stop());
  }
  getAxisMotionValue(e) {
    const t = "_drag" + e.toUpperCase(),
      i = this.visualElement.getProps(),
      r = i[t];
    return (
      r ||
      this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0)
    );
  }
  snapToCursor(e) {
    cs((t) => {
      const { drag: i } = this.getProps();
      if (!qp(t, i, this.currentDirection)) return;
      const { projection: r } = this.visualElement,
        s = this.getAxisMotionValue(t);
      if (r && r.layout) {
        const { min: o, max: a } = r.layout.layoutBox[t];
        s.set(e[t] - an(o, a, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: e, dragConstraints: t } = this.getProps(),
      { projection: i } = this.visualElement;
    if (!Sc(t) || !i || !this.constraints) return;
    this.stopAnimation();
    const r = { x: 0, y: 0 };
    cs((o) => {
      const a = this.getAxisMotionValue(o);
      if (a) {
        const l = a.get();
        r[o] = VW({ min: l, max: l }, this.constraints[o]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    (this.visualElement.current.style.transform = s ? s({}, "") : "none"),
      i.root && i.root.updateScroll(),
      i.updateLayout(),
      this.resolveConstraints(),
      cs((o) => {
        if (!qp(o, e, null)) return;
        const a = this.getAxisMotionValue(o),
          { min: l, max: u } = this.constraints[o];
        a.set(an(l, u, r[o]));
      });
  }
  addListeners() {
    if (!this.visualElement.current) return;
    ZW.set(this.visualElement, this);
    const e = this.visualElement.current,
      t = Js(e, "pointerdown", (l) => {
        const { drag: u, dragListener: h = !0 } = this.getProps();
        u && h && this.start(l);
      }),
      i = () => {
        const { dragConstraints: l } = this.getProps();
        Sc(l) && (this.constraints = this.resolveRefConstraints());
      },
      { projection: r } = this.visualElement,
      s = r.addEventListener("measure", i);
    r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), i();
    const o = Ws(window, "resize", () => this.scalePositionWithinConstraints()),
      a = r.addEventListener(
        "didUpdate",
        ({ delta: l, hasLayoutChanged: u }) => {
          this.isDragging &&
            u &&
            (cs((h) => {
              const d = this.getAxisMotionValue(h);
              d &&
                ((this.originPoint[h] += l[h].translate),
                d.set(d.get() + l[h].translate));
            }),
            this.visualElement.render());
        }
      );
    return () => {
      o(), t(), s(), a && a();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: t = !1,
        dragDirectionLock: i = !1,
        dragPropagation: r = !1,
        dragConstraints: s = !1,
        dragElastic: o = iA,
        dragMomentum: a = !0,
      } = e;
    return {
      ...e,
      drag: t,
      dragDirectionLock: i,
      dragPropagation: r,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: a,
    };
  }
}
function qp(n, e, t) {
  return (e === !0 || e === n) && (t === null || t === n);
}
function ej(n, e = 10) {
  let t = null;
  return Math.abs(n.y) > e ? (t = "y") : Math.abs(n.x) > e && (t = "x"), t;
}
class tj extends oa {
  constructor(e) {
    super(e),
      (this.removeGroupControls = Ln),
      (this.removeListeners = Ln),
      (this.controls = new $W(e));
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || Ln);
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const ob = (n) => (e, t) => {
  n && ln.update(() => n(e, t));
};
class nj extends oa {
  constructor() {
    super(...arguments), (this.removePointerDownListener = Ln);
  }
  onPointerDown(e) {
    this.session = new GI(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: t,
      onPan: i,
      onPanEnd: r,
    } = this.node.getProps();
    return {
      onSessionStart: ob(e),
      onStart: ob(t),
      onMove: i,
      onEnd: (s, o) => {
        delete this.session, r && ln.update(() => r(s, o));
      },
    };
  }
  mount() {
    this.removePointerDownListener = Js(this.node.current, "pointerdown", (e) =>
      this.onPointerDown(e)
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
function ij() {
  const n = W.useContext(uS);
  if (n === null) return [!0, null];
  const { isPresent: e, onExitComplete: t, register: i } = n,
    r = W.useId();
  return W.useEffect(() => i(r), []), !e && t ? [!1, () => t && t(r)] : [!0];
}
const Am = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 };
function ab(n, e) {
  return e.max === e.min ? 0 : (n / (e.max - e.min)) * 100;
}
const rf = {
    correct: (n, e) => {
      if (!e.target) return n;
      if (typeof n == "string")
        if (it.test(n)) n = parseFloat(n);
        else return n;
      const t = ab(n, e.target.x),
        i = ab(n, e.target.y);
      return `${t}% ${i}%`;
    },
  },
  rj = {
    correct: (n, { treeScale: e, projectionDelta: t }) => {
      const i = n,
        r = $o.parse(n);
      if (r.length > 5) return i;
      const s = $o.createTransformer(n),
        o = typeof r[0] != "number" ? 1 : 0,
        a = t.x.scale * e.x,
        l = t.y.scale * e.y;
      (r[0 + o] /= a), (r[1 + o] /= l);
      const u = an(a, l, 0.5);
      return (
        typeof r[2 + o] == "number" && (r[2 + o] /= u),
        typeof r[3 + o] == "number" && (r[3 + o] /= u),
        s(r)
      );
    },
  };
class sj extends Et.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
        layoutId: r,
      } = this.props,
      { projection: s } = e;
    f8(oj),
      s &&
        (t.group && t.group.add(s),
        i && i.register && r && i.register(s),
        s.root.didUpdate(),
        s.addEventListener("animationComplete", () => {
          this.safeToRemove();
        }),
        s.setOptions({
          ...s.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (Am.hasEverUpdated = !0);
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: t,
        visualElement: i,
        drag: r,
        isPresent: s,
      } = this.props,
      o = i.projection;
    return (
      o &&
        ((o.isPresent = s),
        r || e.layoutDependency !== t || t === void 0
          ? o.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== s &&
          (s
            ? o.promote()
            : o.relegate() ||
              ln.postRender(() => {
                const a = o.getStack();
                (!a || !a.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e &&
      (e.root.didUpdate(),
      queueMicrotask(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove();
      }));
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
      } = this.props,
      { projection: r } = e;
    r &&
      (r.scheduleCheckAfterUnmount(),
      t && t.group && t.group.remove(r),
      i && i.deregister && i.deregister(r));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function KI(n) {
  const [e, t] = ij(),
    i = W.useContext(GL);
  return Et.createElement(sj, {
    ...n,
    layoutGroup: i,
    switchLayoutGroup: W.useContext(VL),
    isPresent: e,
    safeToRemove: t,
  });
}
const oj = {
    borderRadius: {
      ...rf,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
      ],
    },
    borderTopLeftRadius: rf,
    borderTopRightRadius: rf,
    borderBottomLeftRadius: rf,
    borderBottomRightRadius: rf,
    boxShadow: rj,
  },
  YI = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  aj = YI.length,
  lb = (n) => (typeof n == "string" ? parseFloat(n) : n),
  cb = (n) => typeof n == "number" || it.test(n);
function lj(n, e, t, i, r, s) {
  r
    ? ((n.opacity = an(0, t.opacity !== void 0 ? t.opacity : 1, cj(i))),
      (n.opacityExit = an(e.opacity !== void 0 ? e.opacity : 1, 0, uj(i))))
    : s &&
      (n.opacity = an(
        e.opacity !== void 0 ? e.opacity : 1,
        t.opacity !== void 0 ? t.opacity : 1,
        i
      ));
  for (let o = 0; o < aj; o++) {
    const a = `border${YI[o]}Radius`;
    let l = ub(e, a),
      u = ub(t, a);
    if (l === void 0 && u === void 0) continue;
    l || (l = 0),
      u || (u = 0),
      l === 0 || u === 0 || cb(l) === cb(u)
        ? ((n[a] = Math.max(an(lb(l), lb(u), i), 0)),
          (ys.test(u) || ys.test(l)) && (n[a] += "%"))
        : (n[a] = u);
  }
  (e.rotate || t.rotate) && (n.rotate = an(e.rotate || 0, t.rotate || 0, i));
}
function ub(n, e) {
  return n[e] !== void 0 ? n[e] : n.borderRadius;
}
const cj = QI(0, 0.5, SS),
  uj = QI(0.5, 0.95, Ln);
function QI(n, e, t) {
  return (i) => (i < n ? 0 : i > e ? 1 : t(hh(n, e, i)));
}
function fb(n, e) {
  (n.min = e.min), (n.max = e.max);
}
function pr(n, e) {
  fb(n.x, e.x), fb(n.y, e.y);
}
function hb(n, e, t, i, r) {
  return (
    (n -= e), (n = lg(n, 1 / t, i)), r !== void 0 && (n = lg(n, 1 / r, i)), n
  );
}
function fj(n, e = 0, t = 1, i = 0.5, r, s = n, o = n) {
  if (
    (ys.test(e) &&
      ((e = parseFloat(e)), (e = an(o.min, o.max, e / 100) - o.min)),
    typeof e != "number")
  )
    return;
  let a = an(s.min, s.max, i);
  n === s && (a -= e),
    (n.min = hb(n.min, e, t, a, r)),
    (n.max = hb(n.max, e, t, a, r));
}
function db(n, e, [t, i, r], s, o) {
  fj(n, e[t], e[i], e[r], e.scale, s, o);
}
const hj = ["x", "scaleX", "originX"],
  dj = ["y", "scaleY", "originY"];
function pb(n, e, t, i) {
  db(n.x, e, hj, t ? t.x : void 0, i ? i.x : void 0),
    db(n.y, e, dj, t ? t.y : void 0, i ? i.y : void 0);
}
function mb(n) {
  return n.translate === 0 && n.scale === 1;
}
function qI(n) {
  return mb(n.x) && mb(n.y);
}
function oA(n, e) {
  return (
    n.x.min === e.x.min &&
    n.x.max === e.x.max &&
    n.y.min === e.y.min &&
    n.y.max === e.y.max
  );
}
function gb(n) {
  return er(n.x) / er(n.y);
}
class pj {
  constructor() {
    this.members = [];
  }
  add(e) {
    CS(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (
      (bS(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const t = this.members[this.members.length - 1];
      t && this.promote(t);
    }
  }
  relegate(e) {
    const t = this.members.findIndex((r) => e === r);
    if (t === 0) return !1;
    let i;
    for (let r = t; r >= 0; r--) {
      const s = this.members[r];
      if (s.isPresent !== !1) {
        i = s;
        break;
      }
    }
    return i ? (this.promote(i), !0) : !1;
  }
  promote(e, t) {
    const i = this.lead;
    if (e !== i && ((this.prevLead = i), (this.lead = e), e.show(), i)) {
      i.instance && i.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = i),
        t && (e.resumeFrom.preserveOpacity = !0),
        i.snapshot &&
          ((e.snapshot = i.snapshot),
          (e.snapshot.latestValues = i.animationValues || i.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: r } = e.options;
      r === !1 && i.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: t, resumingFrom: i } = e;
      t.onExitComplete && t.onExitComplete(),
        i && i.options.onExitComplete && i.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function vb(n, e, t) {
  let i = "";
  const r = n.x.translate / e.x,
    s = n.y.translate / e.y;
  if (
    ((r || s) && (i = `translate3d(${r}px, ${s}px, 0) `),
    (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `),
    t)
  ) {
    const { rotate: l, rotateX: u, rotateY: h } = t;
    l && (i += `rotate(${l}deg) `),
      u && (i += `rotateX(${u}deg) `),
      h && (i += `rotateY(${h}deg) `);
  }
  const o = n.x.scale * e.x,
    a = n.y.scale * e.y;
  return (o !== 1 || a !== 1) && (i += `scale(${o}, ${a})`), i || "none";
}
const mj = (n, e) => n.depth - e.depth;
class gj {
  constructor() {
    (this.children = []), (this.isDirty = !1);
  }
  add(e) {
    CS(this.children, e), (this.isDirty = !0);
  }
  remove(e) {
    bS(this.children, e), (this.isDirty = !0);
  }
  forEach(e) {
    this.isDirty && this.children.sort(mj),
      (this.isDirty = !1),
      this.children.forEach(e);
  }
}
function vj(n, e) {
  const t = performance.now(),
    i = ({ timestamp: r }) => {
      const s = r - t;
      s >= e && (eo(i), n(s - e));
    };
  return ln.read(i, !0), () => eo(i);
}
function yj(n) {
  window.MotionDebug && window.MotionDebug.record(n);
}
function xj(n) {
  return n instanceof SVGElement && n.tagName !== "svg";
}
function _j(n, e, t) {
  const i = Ii(n) ? n : tu(n);
  return i.start(TS("", i, e, t)), i.animation;
}
const yb = ["", "X", "Y", "Z"],
  xb = 1e3;
let Aj = 0;
const Da = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0,
};
function ZI({
  attachResizeListener: n,
  defaultParent: e,
  measureScroll: t,
  checkIsScrollRoot: i,
  resetTransform: r,
}) {
  return class {
    constructor(o = {}, a = e == null ? void 0 : e()) {
      (this.id = Aj++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          (Da.totalNodes =
            Da.resolvedTargetDeltas =
            Da.recalculatedProjection =
              0),
            this.nodes.forEach(Ej),
            this.nodes.forEach(Rj),
            this.nodes.forEach(Pj),
            this.nodes.forEach(wj),
            yj(Da);
        }),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = o),
        (this.root = a ? a.root || a : this),
        (this.path = a ? [...a.path, a] : []),
        (this.parent = a),
        (this.depth = a ? a.depth + 1 : 0);
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new gj());
    }
    addEventListener(o, a) {
      return (
        this.eventHandlers.has(o) || this.eventHandlers.set(o, new RS()),
        this.eventHandlers.get(o).add(a)
      );
    }
    notifyListeners(o, ...a) {
      const l = this.eventHandlers.get(o);
      l && l.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    mount(o, a = this.root.hasTreeAnimated) {
      if (this.instance) return;
      (this.isSVG = xj(o)), (this.instance = o);
      const { layoutId: l, layout: u, visualElement: h } = this.options;
      if (
        (h && !h.current && h.mount(o),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        a && (u || l) && (this.isLayoutDirty = !0),
        n)
      ) {
        let d;
        const p = () => (this.root.updateBlockedByResize = !1);
        n(o, () => {
          (this.root.updateBlockedByResize = !0),
            d && d(),
            (d = vj(p, 250)),
            Am.hasAnimatedSinceResize &&
              ((Am.hasAnimatedSinceResize = !1), this.nodes.forEach(Ab));
        });
      }
      l && this.root.registerSharedNode(l, this),
        this.options.animate !== !1 &&
          h &&
          (l || u) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: d,
              hasLayoutChanged: p,
              hasRelativeTargetChanged: m,
              layout: y,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                (this.target = void 0), (this.relativeTarget = void 0);
                return;
              }
              const M =
                  this.options.transition || h.getDefaultTransition() || Fj,
                { onLayoutAnimationStart: A, onLayoutAnimationComplete: g } =
                  h.getProps(),
                x = !this.targetLayout || !oA(this.targetLayout, y) || m,
                _ = !p && m;
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                _ ||
                (p && (x || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(d, _);
                const E = { ...OI(M, "layout"), onPlay: A, onComplete: g };
                (h.shouldReduceMotion || this.options.layoutRoot) &&
                  ((E.delay = 0), (E.type = !1)),
                  this.startAnimation(E);
              } else
                p || Ab(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete();
              this.targetLayout = y;
            }
          );
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const o = this.getStack();
      o && o.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        eo(this.updateProjection);
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(Bj),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let h = 0; h < this.path.length; h++) {
        const d = this.path[h];
        (d.shouldResetTransform = !0),
          d.updateScroll("snapshot"),
          d.options.layoutRoot && d.willUpdate(!1);
      }
      const { layoutId: a, layout: l } = this.options;
      if (a === void 0 && !l) return;
      const u = this.getTransformTemplate();
      (this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0),
        this.updateSnapshot(),
        o && this.notifyListeners("willUpdate");
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(_b);
        return;
      }
      this.isUpdating || this.nodes.forEach(Cj),
        (this.isUpdating = !1),
        this.nodes.forEach(bj),
        this.nodes.forEach(Sj),
        this.nodes.forEach(Mj),
        this.clearAllSnapshots();
      const a = performance.now();
      (nn.delta = Zo(0, 1e3 / 60, a - nn.timestamp)),
        (nn.timestamp = a),
        (nn.isProcessing = !0),
        Uc.update.process(nn),
        Uc.preRender.process(nn),
        Uc.render.process(nn),
        (nn.isProcessing = !1);
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), queueMicrotask(() => this.update()));
    }
    clearAllSnapshots() {
      this.nodes.forEach(Tj), this.sharedNodes.forEach(Lj);
    }
    scheduleUpdateProjection() {
      ln.preRender(this.updateProjection, !1, !0);
    }
    scheduleCheckAfterUnmount() {
      ln.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
      const o = this.layout;
      (this.layout = this.measure(!1)),
        (this.layoutCorrected = Tn()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a &&
        a.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          o ? o.layoutBox : void 0
        );
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      this.scroll &&
        this.scroll.animationId === this.root.animationId &&
        this.scroll.phase === o &&
        (a = !1),
        a &&
          (this.scroll = {
            animationId: this.root.animationId,
            phase: o,
            isRoot: i(this.instance),
            offset: t(this.instance),
          });
    }
    resetTransform() {
      if (!r) return;
      const o = this.isLayoutDirty || this.shouldResetTransform,
        a = this.projectionDelta && !qI(this.projectionDelta),
        l = this.getTransformTemplate(),
        u = l ? l(this.latestValues, "") : void 0,
        h = u !== this.prevTransformTemplateValue;
      o &&
        (a || Ia(this.latestValues) || h) &&
        (r(this.instance, u),
        (this.shouldResetTransform = !1),
        this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let l = this.removeElementScroll(a);
      return (
        o && (l = this.removeTransform(l)),
        Nj(l),
        {
          animationId: this.root.animationId,
          measuredBox: a,
          layoutBox: l,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      const { visualElement: o } = this.options;
      if (!o) return Tn();
      const a = o.measureViewportBox(),
        { scroll: l } = this.root;
      return l && (wo(a.x, l.offset.x), wo(a.y, l.offset.y)), a;
    }
    removeElementScroll(o) {
      const a = Tn();
      pr(a, o);
      for (let l = 0; l < this.path.length; l++) {
        const u = this.path[l],
          { scroll: h, options: d } = u;
        if (u !== this.root && h && d.layoutScroll) {
          if (h.isRoot) {
            pr(a, o);
            const { scroll: p } = this.root;
            p && (wo(a.x, -p.offset.x), wo(a.y, -p.offset.y));
          }
          wo(a.x, h.offset.x), wo(a.y, h.offset.y);
        }
      }
      return a;
    }
    applyTransform(o, a = !1) {
      const l = Tn();
      pr(l, o);
      for (let u = 0; u < this.path.length; u++) {
        const h = this.path[u];
        !a &&
          h.options.layoutScroll &&
          h.scroll &&
          h !== h.root &&
          wc(l, { x: -h.scroll.offset.x, y: -h.scroll.offset.y }),
          Ia(h.latestValues) && wc(l, h.latestValues);
      }
      return Ia(this.latestValues) && wc(l, this.latestValues), l;
    }
    removeTransform(o) {
      const a = Tn();
      pr(a, o);
      for (let l = 0; l < this.path.length; l++) {
        const u = this.path[l];
        if (!u.instance || !Ia(u.latestValues)) continue;
        rA(u.latestValues) && u.updateSnapshot();
        const h = Tn(),
          d = u.measurePageBox();
        pr(h, d),
          pb(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, h);
      }
      return Ia(this.latestValues) && pb(a, this.latestValues), a;
    }
    setTargetDelta(o) {
      (this.targetDelta = o),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0);
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0,
      };
    }
    clearMeasurements() {
      (this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1);
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== nn.timestamp &&
        this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(o = !1) {
      var a;
      const l = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
      const u = !!this.resumingFrom || this !== l;
      if (
        !(
          o ||
          (u && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((a = this.parent) === null || a === void 0) &&
            a.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget
        )
      )
        return;
      const { layout: d, layoutId: p } = this.options;
      if (!(!this.layout || !(d || p))) {
        if (
          ((this.resolvedRelativeTargetAt = nn.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const m = this.getClosestProjectingParent();
          m && m.layout && this.animationProgress !== 1
            ? ((this.relativeParent = m),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = Tn()),
              (this.relativeTargetOrigin = Tn()),
              Bf(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                m.layout.layoutBox
              ),
              pr(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target ||
              ((this.target = Tn()), (this.targetWithTransforms = Tn())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                kW(
                  this.target,
                  this.relativeTarget,
                  this.relativeParent.target
                ))
              : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : pr(this.target, this.layout.layoutBox),
                XI(this.target, this.targetDelta))
              : pr(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1;
            const m = this.getClosestProjectingParent();
            m &&
            !!m.resumingFrom == !!this.resumingFrom &&
            !m.options.layoutScroll &&
            m.target &&
            this.animationProgress !== 1
              ? ((this.relativeParent = m),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = Tn()),
                (this.relativeTargetOrigin = Tn()),
                Bf(this.relativeTargetOrigin, this.target, m.target),
                pr(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0);
          }
          Da.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          rA(this.parent.latestValues) ||
          jI(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    calcProjection() {
      var o;
      const a = this.getLead(),
        l = !!this.resumingFrom || this !== a;
      let u = !0;
      if (
        ((this.isProjectionDirty ||
          (!((o = this.parent) === null || o === void 0) &&
            o.isProjectionDirty)) &&
          (u = !1),
        l &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (u = !1),
        this.resolvedRelativeTargetAt === nn.timestamp && (u = !1),
        u)
      )
        return;
      const { layout: h, layoutId: d } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(h || d))
      )
        return;
      pr(this.layoutCorrected, this.layout.layoutBox);
      const p = this.treeScale.x,
        m = this.treeScale.y;
      KW(this.layoutCorrected, this.treeScale, this.path, l),
        a.layout &&
          !a.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          (a.target = a.layout.layoutBox);
      const { target: y } = a;
      if (!y) {
        this.projectionTransform &&
          ((this.projectionDelta = Ec()),
          (this.projectionTransform = "none"),
          this.scheduleRender());
        return;
      }
      this.projectionDelta ||
        ((this.projectionDelta = Ec()),
        (this.projectionDeltaWithTransform = Ec()));
      const M = this.projectionTransform;
      Pf(this.projectionDelta, this.layoutCorrected, y, this.latestValues),
        (this.projectionTransform = vb(this.projectionDelta, this.treeScale)),
        (this.projectionTransform !== M ||
          this.treeScale.x !== p ||
          this.treeScale.y !== m) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", y)),
        Da.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      if ((this.options.scheduleRender && this.options.scheduleRender(), o)) {
        const a = this.getStack();
        a && a.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0);
    }
    setAnimationOrigin(o, a = !1) {
      const l = this.snapshot,
        u = l ? l.latestValues : {},
        h = { ...this.latestValues },
        d = Ec();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !a);
      const p = Tn(),
        m = l ? l.source : void 0,
        y = this.layout ? this.layout.source : void 0,
        M = m !== y,
        A = this.getStack(),
        g = !A || A.members.length <= 1,
        x = !!(M && !g && this.options.crossfade === !0 && !this.path.some(Dj));
      this.animationProgress = 0;
      let _;
      (this.mixTargetDelta = (E) => {
        const T = E / 1e3;
        Sb(d.x, o.x, T),
          Sb(d.y, o.y, T),
          this.setTargetDelta(d),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (Bf(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            Ij(this.relativeTarget, this.relativeTargetOrigin, p, T),
            _ && oA(this.relativeTarget, _) && (this.isProjectionDirty = !1),
            _ || (_ = Tn()),
            pr(_, this.relativeTarget)),
          M &&
            ((this.animationValues = h), lj(h, u, this.latestValues, T, x, g)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = T);
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(o) {
      this.notifyListeners("animationStart"),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (eo(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = ln.update(() => {
          (Am.hasAnimatedSinceResize = !0),
            (this.currentAnimation = _j(0, xb, {
              ...o,
              onUpdate: (a) => {
                this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a);
              },
              onComplete: () => {
                o.onComplete && o.onComplete(), this.completeAnimation();
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0);
        }));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const o = this.getStack();
      o && o.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(xb),
        this.currentAnimation.stop()),
        this.completeAnimation();
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let {
        targetWithTransforms: a,
        target: l,
        layout: u,
        latestValues: h,
      } = o;
      if (!(!a || !l || !u)) {
        if (
          this !== o &&
          this.layout &&
          u &&
          $I(this.options.animationType, this.layout.layoutBox, u.layoutBox)
        ) {
          l = this.target || Tn();
          const d = er(this.layout.layoutBox.x);
          (l.x.min = o.target.x.min), (l.x.max = l.x.min + d);
          const p = er(this.layout.layoutBox.y);
          (l.y.min = o.target.y.min), (l.y.max = l.y.min + p);
        }
        pr(a, l),
          wc(a, h),
          Pf(this.projectionDeltaWithTransform, this.layoutCorrected, a, h);
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new pj()),
        this.sharedNodes.get(o).add(a);
      const u = a.options.initialPromotionConfig;
      a.promote({
        transition: u ? u.transition : void 0,
        preserveFollowOpacity:
          u && u.shouldPreserveFollowOpacity
            ? u.shouldPreserveFollowOpacity(a)
            : void 0,
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var o;
      const { layoutId: a } = this.options;
      return a
        ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) ||
            this
        : this;
    }
    getPrevLead() {
      var o;
      const { layoutId: a } = this.options;
      return a
        ? (o = this.getStack()) === null || o === void 0
          ? void 0
          : o.prevLead
        : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o) return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) {
      const u = this.getStack();
      u && u.promote(this, l),
        o && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        a && this.setOptions({ transition: a });
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetRotation() {
      const { visualElement: o } = this.options;
      if (!o) return;
      let a = !1;
      const { latestValues: l } = o;
      if (((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (a = !0), !a))
        return;
      const u = {};
      for (let h = 0; h < yb.length; h++) {
        const d = "rotate" + yb[h];
        l[d] && ((u[d] = l[d]), o.setStaticValue(d, 0));
      }
      o.render();
      for (const h in u) o.setStaticValue(h, u[h]);
      o.scheduleRender();
    }
    getProjectionStyles(o = {}) {
      var a, l;
      const u = {};
      if (!this.instance || this.isSVG) return u;
      if (this.isVisible) u.visibility = "";
      else return { visibility: "hidden" };
      const h = this.getTransformTemplate();
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (u.opacity = ""),
          (u.pointerEvents = _m(o.pointerEvents) || ""),
          (u.transform = h ? h(this.latestValues, "") : "none"),
          u
        );
      const d = this.getLead();
      if (!this.projectionDelta || !this.layout || !d.target) {
        const M = {};
        return (
          this.options.layoutId &&
            ((M.opacity =
              this.latestValues.opacity !== void 0
                ? this.latestValues.opacity
                : 1),
            (M.pointerEvents = _m(o.pointerEvents) || "")),
          this.hasProjected &&
            !Ia(this.latestValues) &&
            ((M.transform = h ? h({}, "") : "none"), (this.hasProjected = !1)),
          M
        );
      }
      const p = d.animationValues || d.latestValues;
      this.applyTransformsToTarget(),
        (u.transform = vb(
          this.projectionDeltaWithTransform,
          this.treeScale,
          p
        )),
        h && (u.transform = h(p, u.transform));
      const { x: m, y } = this.projectionDelta;
      (u.transformOrigin = `${m.origin * 100}% ${y.origin * 100}% 0`),
        d.animationValues
          ? (u.opacity =
              d === this
                ? (l =
                    (a = p.opacity) !== null && a !== void 0
                      ? a
                      : this.latestValues.opacity) !== null && l !== void 0
                  ? l
                  : 1
                : this.preserveOpacity
                ? this.latestValues.opacity
                : p.opacityExit)
          : (u.opacity =
              d === this
                ? p.opacity !== void 0
                  ? p.opacity
                  : ""
                : p.opacityExit !== void 0
                ? p.opacityExit
                : 0);
      for (const M in tg) {
        if (p[M] === void 0) continue;
        const { correct: A, applyTo: g } = tg[M],
          x = u.transform === "none" ? p[M] : A(p[M], d);
        if (g) {
          const _ = g.length;
          for (let E = 0; E < _; E++) u[g[E]] = x;
        } else u[M] = x;
      }
      return (
        this.options.layoutId &&
          (u.pointerEvents = d === this ? _m(o.pointerEvents) || "" : "none"),
        u
      );
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) === null || a === void 0
          ? void 0
          : a.stop();
      }),
        this.root.nodes.forEach(_b),
        this.root.sharedNodes.clear();
    }
  };
}
function Sj(n) {
  n.updateLayout();
}
function Mj(n) {
  var e;
  const t =
    ((e = n.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) ||
    n.snapshot;
  if (n.isLead() && n.layout && t && n.hasListeners("didUpdate")) {
    const { layoutBox: i, measuredBox: r } = n.layout,
      { animationType: s } = n.options,
      o = t.source !== n.layout.source;
    s === "size"
      ? cs((d) => {
          const p = o ? t.measuredBox[d] : t.layoutBox[d],
            m = er(p);
          (p.min = i[d].min), (p.max = p.min + m);
        })
      : $I(s, t.layoutBox, i) &&
        cs((d) => {
          const p = o ? t.measuredBox[d] : t.layoutBox[d],
            m = er(i[d]);
          (p.max = p.min + m),
            n.relativeTarget &&
              !n.currentAnimation &&
              ((n.isProjectionDirty = !0),
              (n.relativeTarget[d].max = n.relativeTarget[d].min + m));
        });
    const a = Ec();
    Pf(a, i, t.layoutBox);
    const l = Ec();
    o ? Pf(l, n.applyTransform(r, !0), t.measuredBox) : Pf(l, i, t.layoutBox);
    const u = !qI(a);
    let h = !1;
    if (!n.resumeFrom) {
      const d = n.getClosestProjectingParent();
      if (d && !d.resumeFrom) {
        const { snapshot: p, layout: m } = d;
        if (p && m) {
          const y = Tn();
          Bf(y, t.layoutBox, p.layoutBox);
          const M = Tn();
          Bf(M, i, m.layoutBox),
            oA(y, M) || (h = !0),
            d.options.layoutRoot &&
              ((n.relativeTarget = M),
              (n.relativeTargetOrigin = y),
              (n.relativeParent = d));
        }
      }
    }
    n.notifyListeners("didUpdate", {
      layout: i,
      snapshot: t,
      delta: l,
      layoutDelta: a,
      hasLayoutChanged: u,
      hasRelativeTargetChanged: h,
    });
  } else if (n.isLead()) {
    const { onExitComplete: i } = n.options;
    i && i();
  }
  n.options.transition = void 0;
}
function Ej(n) {
  Da.totalNodes++,
    n.parent &&
      (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty),
      n.isSharedProjectionDirty ||
        (n.isSharedProjectionDirty = !!(
          n.isProjectionDirty ||
          n.parent.isProjectionDirty ||
          n.parent.isSharedProjectionDirty
        )),
      n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty));
}
function wj(n) {
  n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1;
}
function Tj(n) {
  n.clearSnapshot();
}
function _b(n) {
  n.clearMeasurements();
}
function Cj(n) {
  n.isLayoutDirty = !1;
}
function bj(n) {
  const { visualElement: e } = n.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    n.resetTransform();
}
function Ab(n) {
  n.finishAnimation(),
    (n.targetDelta = n.relativeTarget = n.target = void 0),
    (n.isProjectionDirty = !0);
}
function Rj(n) {
  n.resolveTargetDelta();
}
function Pj(n) {
  n.calcProjection();
}
function Bj(n) {
  n.resetRotation();
}
function Lj(n) {
  n.removeLeadSnapshot();
}
function Sb(n, e, t) {
  (n.translate = an(e.translate, 0, t)),
    (n.scale = an(e.scale, 1, t)),
    (n.origin = e.origin),
    (n.originPoint = e.originPoint);
}
function Mb(n, e, t, i) {
  (n.min = an(e.min, t.min, i)), (n.max = an(e.max, t.max, i));
}
function Ij(n, e, t, i) {
  Mb(n.x, e.x, t.x, i), Mb(n.y, e.y, t.y, i);
}
function Dj(n) {
  return n.animationValues && n.animationValues.opacityExit !== void 0;
}
const Fj = { duration: 0.45, ease: [0.4, 0, 0.1, 1] };
function Eb(n) {
  (n.min = Math.round(n.min)), (n.max = Math.round(n.max));
}
function Nj(n) {
  Eb(n.x), Eb(n.y);
}
function $I(n, e, t) {
  return (
    n === "position" || (n === "preserve-aspect" && !nA(gb(e), gb(t), 0.2))
  );
}
const Uj = ZI({
    attachResizeListener: (n, e) => Ws(n, "resize", e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  ix = { current: void 0 },
  eD = ZI({
    measureScroll: (n) => ({ x: n.scrollLeft, y: n.scrollTop }),
    defaultParent: () => {
      if (!ix.current) {
        const n = new Uj({});
        n.mount(window), n.setOptions({ layoutScroll: !0 }), (ix.current = n);
      }
      return ix.current;
    },
    resetTransform: (n, e) => {
      n.style.transform = e !== void 0 ? e : "none";
    },
    checkIsScrollRoot: (n) => window.getComputedStyle(n).position === "fixed",
  }),
  Oj = {
    pan: { Feature: nj },
    drag: { Feature: tj, ProjectionNode: eD, MeasureLayout: KI },
  },
  kj = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function Hj(n) {
  const e = kj.exec(n);
  if (!e) return [,];
  const [, t, i] = e;
  return [t, i];
}
function aA(n, e, t = 1) {
  const [i, r] = Hj(n);
  if (!i) return;
  const s = window.getComputedStyle(e).getPropertyValue(i);
  return s ? s.trim() : K_(r) ? aA(r, e, t + 1) : r;
}
function zj(n, { ...e }, t) {
  const i = n.current;
  if (!(i instanceof Element)) return { target: e, transitionEnd: t };
  t && (t = { ...t }),
    n.values.forEach((r) => {
      const s = r.get();
      if (!K_(s)) return;
      const o = aA(s, i);
      o && r.set(o);
    });
  for (const r in e) {
    const s = e[r];
    if (!K_(s)) continue;
    const o = aA(s, i);
    o && ((e[r] = o), t || (t = {}), t[r] === void 0 && (t[r] = s));
  }
  return { target: e, transitionEnd: t };
}
const Gj = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y",
    "translateX",
    "translateY",
  ]),
  tD = (n) => Gj.has(n),
  Vj = (n) => Object.keys(n).some(tD),
  wb = (n) => n === vl || n === it,
  Tb = (n, e) => parseFloat(n.split(", ")[e]),
  Cb =
    (n, e) =>
    (t, { transform: i }) => {
      if (i === "none" || !i) return 0;
      const r = i.match(/^matrix3d\((.+)\)$/);
      if (r) return Tb(r[1], e);
      {
        const s = i.match(/^matrix\((.+)\)$/);
        return s ? Tb(s[1], n) : 0;
      }
    },
  Wj = new Set(["x", "y", "z"]),
  jj = Oh.filter((n) => !Wj.has(n));
function Xj(n) {
  const e = [];
  return (
    jj.forEach((t) => {
      const i = n.getValue(t);
      i !== void 0 &&
        (e.push([t, i.get()]), i.set(t.startsWith("scale") ? 1 : 0));
    }),
    e.length && n.render(),
    e
  );
}
const nu = {
  width: ({ x: n }, { paddingLeft: e = "0", paddingRight: t = "0" }) =>
    n.max - n.min - parseFloat(e) - parseFloat(t),
  height: ({ y: n }, { paddingTop: e = "0", paddingBottom: t = "0" }) =>
    n.max - n.min - parseFloat(e) - parseFloat(t),
  top: (n, { top: e }) => parseFloat(e),
  left: (n, { left: e }) => parseFloat(e),
  bottom: ({ y: n }, { top: e }) => parseFloat(e) + (n.max - n.min),
  right: ({ x: n }, { left: e }) => parseFloat(e) + (n.max - n.min),
  x: Cb(4, 13),
  y: Cb(5, 14),
};
nu.translateX = nu.x;
nu.translateY = nu.y;
const Jj = (n, e, t) => {
    const i = e.measureViewportBox(),
      r = e.current,
      s = getComputedStyle(r),
      { display: o } = s,
      a = {};
    o === "none" && e.setStaticValue("display", n.display || "block"),
      t.forEach((u) => {
        a[u] = nu[u](i, s);
      }),
      e.render();
    const l = e.measureViewportBox();
    return (
      t.forEach((u) => {
        const h = e.getValue(u);
        h && h.jump(a[u]), (n[u] = nu[u](l, s));
      }),
      n
    );
  },
  Kj = (n, e, t = {}, i = {}) => {
    (e = { ...e }), (i = { ...i });
    const r = Object.keys(e).filter(tD);
    let s = [],
      o = !1;
    const a = [];
    if (
      (r.forEach((l) => {
        const u = n.getValue(l);
        if (!n.hasValue(l)) return;
        let h = t[l],
          d = nf(h);
        const p = e[l];
        let m;
        if (ig(p)) {
          const y = p.length,
            M = p[0] === null ? 1 : 0;
          (h = p[M]), (d = nf(h));
          for (let A = M; A < y && p[A] !== null; A++)
            m ? AS(nf(p[A]) === m) : (m = nf(p[A]));
        } else m = nf(p);
        if (d !== m)
          if (wb(d) && wb(m)) {
            const y = u.get();
            typeof y == "string" && u.set(parseFloat(y)),
              typeof p == "string"
                ? (e[l] = parseFloat(p))
                : Array.isArray(p) && m === it && (e[l] = p.map(parseFloat));
          } else
            d != null &&
            d.transform &&
            m != null &&
            m.transform &&
            (h === 0 || p === 0)
              ? h === 0
                ? u.set(m.transform(h))
                : (e[l] = d.transform(p))
              : (o || ((s = Xj(n)), (o = !0)),
                a.push(l),
                (i[l] = i[l] !== void 0 ? i[l] : e[l]),
                u.jump(p));
      }),
      a.length)
    ) {
      const l = a.indexOf("height") >= 0 ? window.pageYOffset : null,
        u = Jj(e, n, a);
      return (
        s.length &&
          s.forEach(([h, d]) => {
            n.getValue(h).set(d);
          }),
        n.render(),
        l0 && l !== null && window.scrollTo({ top: l }),
        { target: u, transitionEnd: i }
      );
    } else return { target: e, transitionEnd: i };
  };
function Yj(n, e, t, i) {
  return Vj(e) ? Kj(n, e, t, i) : { target: e, transitionEnd: i };
}
const Qj = (n, e, t, i) => {
    const r = zj(n, e, i);
    return (e = r.target), (i = r.transitionEnd), Yj(n, e, t, i);
  },
  lA = { current: null },
  nD = { current: !1 };
function qj() {
  if (((nD.current = !0), !!l0))
    if (window.matchMedia) {
      const n = window.matchMedia("(prefers-reduced-motion)"),
        e = () => (lA.current = n.matches);
      n.addListener(e), e();
    } else lA.current = !1;
}
function Zj(n, e, t) {
  const { willChange: i } = e;
  for (const r in e) {
    const s = e[r],
      o = t[r];
    if (Ii(s)) n.addValue(r, s), ag(i) && i.add(r);
    else if (Ii(o)) n.addValue(r, tu(s, { owner: n })), ag(i) && i.remove(r);
    else if (o !== s)
      if (n.hasValue(r)) {
        const a = n.getValue(r);
        !a.hasAnimated && a.set(s);
      } else {
        const a = n.getStaticValue(r);
        n.addValue(r, tu(a !== void 0 ? a : s, { owner: n }));
      }
  }
  for (const r in t) e[r] === void 0 && n.removeValue(r);
  return e;
}
const bb = new WeakMap(),
  iD = Object.keys(uh),
  $j = iD.length,
  Rb = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete",
  ],
  e7 = hS.length;
class t7 {
  constructor(
    {
      parent: e,
      props: t,
      presenceContext: i,
      reducedMotionConfig: r,
      visualState: s,
    },
    o = {}
  ) {
    (this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection
          ));
      }),
      (this.scheduleRender = () => ln.render(this.render, !1, !0));
    const { latestValues: a, renderState: l } = s;
    (this.latestValues = a),
      (this.baseTarget = { ...a }),
      (this.initialValues = t.initial ? { ...a } : {}),
      (this.renderState = l),
      (this.parent = e),
      (this.props = t),
      (this.presenceContext = i),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = r),
      (this.options = o),
      (this.isControllingVariants = u0(t)),
      (this.isVariantNode = zL(t)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current));
    const { willChange: u, ...h } = this.scrapeMotionValuesFromProps(t, {});
    for (const d in h) {
      const p = h[d];
      a[d] !== void 0 && Ii(p) && (p.set(a[d], !1), ag(u) && u.add(d));
    }
  }
  scrapeMotionValuesFromProps(e, t) {
    return {};
  }
  mount(e) {
    (this.current = e),
      bb.set(e, this),
      this.projection && !this.projection.instance && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((t, i) => this.bindToMotionValue(i, t)),
      nD.current || qj(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === "never"
          ? !1
          : this.reducedMotionConfig === "always"
          ? !0
          : lA.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext);
  }
  unmount() {
    bb.delete(this.current),
      this.projection && this.projection.unmount(),
      eo(this.notifyUpdate),
      eo(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this);
    for (const e in this.events) this.events[e].clear();
    for (const e in this.features) this.features[e].unmount();
    this.current = null;
  }
  bindToMotionValue(e, t) {
    const i = gl.has(e),
      r = t.on("change", (o) => {
        (this.latestValues[e] = o),
          this.props.onUpdate && ln.update(this.notifyUpdate, !1, !0),
          i && this.projection && (this.projection.isTransformDirty = !0);
      }),
      s = t.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(e, () => {
      r(), s();
    });
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current);
  }
  loadFeatures({ children: e, ...t }, i, r, s) {
    let o, a;
    for (let l = 0; l < $j; l++) {
      const u = iD[l],
        {
          isEnabled: h,
          Feature: d,
          ProjectionNode: p,
          MeasureLayout: m,
        } = uh[u];
      p && (o = p),
        h(t) &&
          (!this.features[u] && d && (this.features[u] = new d(this)),
          m && (a = m));
    }
    if (!this.projection && o) {
      this.projection = new o(
        this.latestValues,
        this.parent && this.parent.projection
      );
      const {
        layoutId: l,
        layout: u,
        drag: h,
        dragConstraints: d,
        layoutScroll: p,
        layoutRoot: m,
      } = t;
      this.projection.setOptions({
        layoutId: l,
        layout: u,
        alwaysMeasureLayout: !!h || (d && Sc(d)),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        animationType: typeof u == "string" ? u : "both",
        initialPromotionConfig: s,
        layoutScroll: p,
        layoutRoot: m,
      });
    }
    return a;
  }
  updateFeatures() {
    for (const e in this.features) {
      const t = this.features[e];
      t.isMounted ? t.update() : (t.mount(), (t.isMounted = !0));
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : Tn();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, t) {
    this.latestValues[e] = t;
  }
  makeTargetAnimatable(e, t = !0) {
    return this.makeTargetAnimatableFromInstance(e, this.props, t);
  }
  update(e, t) {
    (e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = t);
    for (let i = 0; i < Rb.length; i++) {
      const r = Rb[i];
      this.propEventSubscriptions[r] &&
        (this.propEventSubscriptions[r](),
        delete this.propEventSubscriptions[r]);
      const s = e["on" + r];
      s && (this.propEventSubscriptions[r] = this.on(r, s));
    }
    (this.prevMotionValues = Zj(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
      ? this.parent.getClosestVariantNode()
      : void 0;
  }
  getVariantContext(e = !1) {
    if (e) return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const i = this.parent ? this.parent.getVariantContext() || {} : {};
      return (
        this.props.initial !== void 0 && (i.initial = this.props.initial), i
      );
    }
    const t = {};
    for (let i = 0; i < e7; i++) {
      const r = hS[i],
        s = this.props[r];
      (ch(s) || s === !1) && (t[r] = s);
    }
    return t;
  }
  addVariantChild(e) {
    const t = this.getClosestVariantNode();
    if (t)
      return (
        t.variantChildren && t.variantChildren.add(e),
        () => t.variantChildren.delete(e)
      );
  }
  addValue(e, t) {
    t !== this.values.get(e) &&
      (this.removeValue(e), this.bindToMotionValue(e, t)),
      this.values.set(e, t),
      (this.latestValues[e] = t.get());
  }
  removeValue(e) {
    this.values.delete(e);
    const t = this.valueSubscriptions.get(e);
    t && (t(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState);
  }
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, t) {
    if (this.props.values && this.props.values[e]) return this.props.values[e];
    let i = this.values.get(e);
    return (
      i === void 0 &&
        t !== void 0 &&
        ((i = tu(t, { owner: this })), this.addValue(e, i)),
      i
    );
  }
  readValue(e) {
    var t;
    return this.latestValues[e] !== void 0 || !this.current
      ? this.latestValues[e]
      : (t = this.getBaseTargetFromProps(this.props, e)) !== null &&
        t !== void 0
      ? t
      : this.readValueFromInstance(this.current, e, this.options);
  }
  setBaseTarget(e, t) {
    this.baseTarget[e] = t;
  }
  getBaseTarget(e) {
    var t;
    const { initial: i } = this.props,
      r =
        typeof i == "string" || typeof i == "object"
          ? (t = _S(this.props, i)) === null || t === void 0
            ? void 0
            : t[e]
          : void 0;
    if (i && r !== void 0) return r;
    const s = this.getBaseTargetFromProps(this.props, e);
    return s !== void 0 && !Ii(s)
      ? s
      : this.initialValues[e] !== void 0 && r === void 0
      ? void 0
      : this.baseTarget[e];
  }
  on(e, t) {
    return this.events[e] || (this.events[e] = new RS()), this.events[e].add(t);
  }
  notify(e, ...t) {
    this.events[e] && this.events[e].notify(...t);
  }
}
class rD extends t7 {
  sortInstanceNodePosition(e, t) {
    return e.compareDocumentPosition(t) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, t) {
    return e.style ? e.style[t] : void 0;
  }
  removeValueFromRenderState(e, { vars: t, style: i }) {
    delete t[e], delete i[e];
  }
  makeTargetAnimatableFromInstance(
    { transition: e, transitionEnd: t, ...i },
    { transformValues: r },
    s
  ) {
    let o = AW(i, e || {}, this);
    if ((r && (t && (t = r(t)), i && (i = r(i)), o && (o = r(o))), s)) {
      xW(this, i, o);
      const a = Qj(this, i, o, t);
      (t = a.transitionEnd), (i = a.target);
    }
    return { transition: e, transitionEnd: t, ...i };
  }
}
function n7(n) {
  return window.getComputedStyle(n);
}
class i7 extends rD {
  readValueFromInstance(e, t) {
    if (gl.has(t)) {
      const i = wS(t);
      return (i && i.default) || 0;
    } else {
      const i = n7(e),
        r = (XL(t) ? i.getPropertyValue(t) : i[t]) || 0;
      return typeof r == "string" ? r.trim() : r;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: t }) {
    return JI(e, t);
  }
  build(e, t, i, r) {
    pS(e, t, i, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, t) {
    return xS(e, t);
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Ii(e) &&
      (this.childSubscription = e.on("change", (t) => {
        this.current && (this.current.textContent = `${t}`);
      }));
  }
  renderInstance(e, t, i, r) {
    ZL(e, t, i, r);
  }
}
class r7 extends rD {
  constructor() {
    super(...arguments), (this.isSVGTag = !1);
  }
  getBaseTargetFromProps(e, t) {
    return e[t];
  }
  readValueFromInstance(e, t) {
    if (gl.has(t)) {
      const i = wS(t);
      return (i && i.default) || 0;
    }
    return (t = $L.has(t) ? t : yS(t)), e.getAttribute(t);
  }
  measureInstanceViewportBox() {
    return Tn();
  }
  scrapeMotionValuesFromProps(e, t) {
    return tI(e, t);
  }
  build(e, t, i, r) {
    gS(e, t, i, this.isSVGTag, r.transformTemplate);
  }
  renderInstance(e, t, i, r) {
    eI(e, t, i, r);
  }
  mount(e) {
    (this.isSVGTag = vS(e.tagName)), super.mount(e);
  }
}
const s7 = (n, e) =>
    dS(n)
      ? new r7(e, { enableHardwareAcceleration: !1 })
      : new i7(e, { enableHardwareAcceleration: !0 }),
  o7 = { layout: { ProjectionNode: eD, MeasureLayout: KI } },
  a7 = { ...FW, ...n6, ...Oj, ...o7 },
  tr = c8((n, e) => k8(n, e, a7, s7)),
  Ki = {
    paddingX: "sm:px-16 px-6",
    paddingY: "sm:py-16 py-6",
    padding: "sm:px-16 px-6 sm:py-16 py-10",
    heroHeadText:
      "font-black text-white lg:text-[70px] sm:text-[60px] xs:text-[50px] text-[40px] lg:leading-[98px] mt-2",
    heroSubText:
      "text-[#dfd9ff] font-medium lg:text-[30px] sm:text-[26px] xs:text-[20px] text-[16px] lg:leading-[40px]",
    sectionHeadText:
      "flex items-center justify-center text-white font-black md:text-[30px] sm:text-[50px] xs:text-[40px] text-[30px]",
    sectionSubText:
      "h3-R-line flex items-center justify-center sm:text-[18px] text-[20px] text-secondary uppercase tracking-wider",
  },
  sD = "./assets/altotech-minilogo-5baf6cc6.svg",
  l7 = "./assets/menu-242d80a8.svg",
  c7 = "./assets/close-ad0e0ca6.svg",
  u7 = "./assets/Trabalho1-eb88109f.png",
  f7 = "./assets/trabalho2-7d7a11d6.png",
  h7 = "./assets/trabalho3-f96df2b4.png",
  Sm = "./assets/AltoTech-54b53f2f.png",
  d7 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABKCAYAAAAsXNNQAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAA1pSURBVHgB7VwJkBTVGf7/7p7ZC3a5FBQNaiyigkaLioCQdXWXVVDBmGCZlAergiEEAxolHGbXmMOEkjJ4VUUOz0rVYlKKEA1KsUVVNKIpNSbRSmHiFcWNIlmWPWa635+/e64+3us5do6t0g96X/frN+/4+vvf/46eQRgm6FxIes1g7HU+PdG+xuThnGPynJx/i+c+XfVbGCbQYJigti+2gAimEJ9C8kidc3ziHKEONFr91HwaCcMEw4LAR1oP1JkIt5B9Qc5/z+FEU+ocT9eh/0IYJhgWBDZERl9CCNNtggQkyZIQmYpD1FfZJg/DABUncGsTVZuIS5gYTKstebjVmI5PREyrHYwtgGGAihM4sm5gNhPSRCxBpeooqUzXoRGtZI+CUGFUnEBCYy3TgAliFCQCBNQoEGftvGiwFSqMihLYeWF8JquoyWu6KHUk7j4weSDo2u1QYVSUQKFDu8xEhaPEcJNOXNPXtl/Sfy5UEBUj8PGLYtPYcM8LdRg+NWbi0yRqCNoKqCAqRiASrmYSomp1+dQIQUeSTNuyc368ESqEihD4eHP/SUR0Ubbxnnf4olTjCIuslR0dVJG2VKRQEdV/wnxUp4mgoInKHYmKRJx35r4jU6ACKDuBW+YOnsY8fFumOkFu0wXFjCTjYFwmHQVdvwUqgLITqKN2HROgyUzXRsFqJO3Kznm9E6DMKCuBm+bRJG7tjQmC5MMUG0oSpWpMnvNgPKJF74Qyo6wEoojfxGZnZDwqhi4cBEwawk2agwW81PUVKCPKRuCDzb3jecz2naC6EkunharRnQ979lFCxBdDGVE2AvVo1WqeOYxLqyjMHCGoRve1W43CnwfAtdtb6RQoE8pC4Kbz+ycJwsuzO4fcpnCqPGwwoaNjkdg3oUwoC4FkGItYfcc456k48KrLHZcxaezzxkPWgXfCoeCt9y3sHgFlQMkJvLe5Zywhtcm9aFBdbjXyn3Y+3pGZbiC9V6H1R/c1LIMyoOQE6kb1ZUzGJL/JAajVmFThkV5r4BE26YfkKpWrNx2HsKSz5WADlBglJXAz755poHXY5x7SFCQ6YfKeJay7l+4a2R1B4zG2yYHUgkIqrcqk03GEJ4mqEVdDiVFSAuOx+FXc9x0rVVy4SZNuRh+x017xDL4tNHw8EY/qsaEkLw3oVnvPBUqIkhG4YSbVkKXfSknWpOpJ/vETzCQ9dc1u/GcqLxL0GN8b9DoYSX6BeDyutja+BEqIkhFYNUJczc5jkmyQDCAhMZOGhYYPuvNaNMPYy/dfdDuYlEnL1OhWKSdte2UaRaBEKJ0Jo1huBy6PCio1uh2MINonDL3Lk1UHMj/inqCpZ1cjH2fuHx+/EkqEkhC4sXXwW9zsKV7FZaZs4IoH8BLA6tlyw47E+M+Nd2dEn+R7HwXJymEGg3Db9oupFkqAohPY0UQGktGuNNdQk8b/9h2OPCrN11Yh0q/kiwxZZzAnHDGtFigBik5gg2FdwFWeGm6uKHUeJKytN72I/aq8DT2yjdMedtJKTVdu0mR3KGj9AkqAohJov6+iA9zs7oec0JXGY9LkMelYVI8+EJb/NTvwP5zySZ+6Ag9HpnBAPO3Reb1FfympqAR++Kk5izk5zz73dOYUNFe/agSI59qexXeyFqJFNqZVCL6+Dnxe2hevU9Uqu4uBIqJoBDrvqRi4LnEu6eMUakw2eBBM7ZeQA677A77CpO8JPAySles1aQE06+Sa2KVQRBSNwHua4tPBgha/0jyhQo0c+fKeMcYLkCNMYW4KPCBJ/m4H4zgeBHs8eH0xt0CLlpFpaO3OS0IhziMFfxqLaMu2bWhBjjhwTtVOIehfoQ/KV356CIXYetJLA01QJBSFwLtaaAa7hDkecyWVubrS2CHi2321kScgD9hDGkSxESRm6yfR3zfywi6yEL8PRUKRFGgtZXNx3hgNmBRkMWkBnau242HIExY5L5of8D8sD2GkIpLmP9QamwZFwJAJ3NBCp3Ol5tvnQbMJqtGnlCMUH7wfCsDSXdhNKB5Ll0tZHpS3fN6exqK8GjdkAi0St3EFR0nNyBVKhzIofndjV+0HUCDIjNrzYzOdr1JxEFhk4P666eG5dBYMEUMi8K5GOh4c9aFUae7QOXc5D3sYHYvDRhgCbnge3+M8n07l6SFSUQ+XGusIrOUwRAyJQCsi1nJlqtJeTjJFc6vOiUtGsOfd+9K4yGswROiGkZ69eMhSkOjuG/nPlc7bEkNAwQT+lNXHjuOqYCXRv8EjN20y7s5n6KJCrM9ZJ3xRWpbEpN1puP4RnawfwRBQMIG6IVZC4ptEEnPFbKb0cWwAdkMRsKwLe4nERm/5uZs0rz+2bZ5z5FgoEAURuL6R7O+zLVIOH5wYtUkLIe5c9af8hy4qiFh0BxOxP1UGuMpLhwoHw6gCLXozFIiCCBzUhL3PMNrdnyg77aBJH+qpimyBIsJWIRL+PtvChUqNPLK+/sEmOg4KQN4E/qyZxqMOSwJPOoREt0kLEjtufwZ7oMigqHEnl+P0qdlWvVNqTF1zX1iv14groADkr0DLMd0xPjPwejdQmDRhnPvt9VACfG8nfsYFdare9pLVybNSQ2Ld1qZ/570FmheB61upjtd2V8oWDMBdSYUaScM9t+zGv0KJwMOqX9tBgiD5Rpa/Ti7LaRA1X7oJ8kReBA7ExHdZ7uOdciVKA3nFMvdMvAdKiE/qIq+yPT7j7n/9G1nSbobSzm3p5jy/i5wzgR2nUZSnPyvcFVGZLIDU873JW23PQgnRsQ1jHNiLDKbXbDFQ18y9TFuY7oliUOS1EZ/z8rY2zlrERRxnF4auCmCqcHRdu0Ib9jcJTbTu6+jSTX++G0+mqoNHQ8MIgBoTYyOMKNpffzA0jOicJ6/wmNzt8sd55svXpoGRXu5J+1kmve/y0dGFnjy7R+tPjDtktvOi1eR0+ZAg0XZl/rq62yGcwLp+axNtbuvCQ5ADcvq66KoWaqixxF5OfAZKPuj+bQPPdSaJySTeQUhHcdxk+0FwA0dxg8byvapM+oQMpHm7Q0w/IMHhZ0zK/9iUujnP9zl6P1M1k/vqJnU+3nKCIV67+I/GVsgBORH44/PNNk2gM3YLISnR46D3WpYmrPKpnktGZC75ePLEkHupsYEkDcv0Lfg0csYNf7FHDeHI2gd2TOMdfUtbrHqzQOqBs6SBbMMd3wwGIKSP9d33lEuK8sHrYPx5M6un6OPi10AOyEqgVQcXczAjU7h36UraMAgjyOeE/J+DTAOzz3Igt1VvUpSfLAckD5290A9y2QLNQqCzTdQB6P89A0w3MBUXaBjkoUbF53NYlEicE0jV6CGNFOUn2+NPw/3p1IlRK+sWaCiBHbOhmYNTlY3PwaT9FUuFAVMkxb0s64yBfGTlu+qhVmzQpC2g9my/yxBKYFyD290VI1UDCUPTUNbKu9JI7qUaWKhJZ1Oj0qQRpmyaA3MhBEoC182ON7HhTnc3Diik8cVUYyDvFHJUo6+u/vJk9fCmSZs0Wmi2Q4gKpQTanSfpur1GFtiqlJGYOcfsBAHkNrUib97kb2A2glx1JVWaUKtImjTA2Q+0mMpfB5ESOGCaszm4AEDRCF/B3sIxd3OVkB1IA6o03heI/HV055GTYgGUJs2LICv2KDxygEC709Q13Z7zSt8rDhDpigdXoYU4GOkDIcii6uKp0X3tO2/5hx6XboEGCFx7jvMLavMhBLIG5qpGf5p81SgnIdzB5KJGcNVDUkcDdG0tSBAgEA1YiZh9ihdQQ5HVKE0TQlCYgwnkScG8/UT6y2csuLeVpoMPHrte00RTSVBbThNkVwHpFRi7YuhdkYH0OZpEdFhDPMTXBznyIN85xDc+4wf2ESf5hLuPI4h6P5E1qCH1CxMGSbMfslGNZNXwakl1RNOrLRIjUYMJnM8EzncMJxjFeY3hPMYxifVIVE3oL98bpi6UaSizapNqIy8I/ZD/LgQVgZoQq52Xl/IEeUm0uPIf8vXfmM03bXKEBu8Ky/xAQ+N9QXDAvwRVLPy8mcZWGzDBjJsTmdjjuTYTQaMpGsEkXraZzHUbnUqbIil1kSbW3zBwEYla831z6Mxlz+Fr7nwc8NDlhLig1zmmHvIAV6qHK7ebDejPwl7FIGt/vx79cFQT9Dhv1g8D2MOyUfUw1uqFL/P8YjJr5CxuZwvX+VRILcigatUmGSZPmMj7l+8ylvnTwZpGazNnfC1kRzeb2vMEWpewYF+NAX8vlaJKjbt5h1GQ+VUmYSY7iW8woaeD83NSCSgI7eUNqMYbn4++mo5fxxvlAullvhirKOstAbQLTbEjUm+8VIptycqDcH3jwAmRaPRSRLqQlXY2On2rZM0RMyp04taca23gPmOlKzd7IfENVuQeNsKH79iLb8DnDBsWvl9jHDz6MqHhAgTt/JS4kiSah0XfhDW76z/FNV+nY1BzXouo5Zvv8ei+U9PhyY97YN9vcliR/TzAfo0vYljNPLG9nB1kM/f7URbW/ct3G8twbSPdwfK9jEDcFTX1HR0vYDd8ASlsZ3RUBKaaEF+BpM3SevQZ3P/1nwhfIG/cy0Mm2wn9H//R5n1naeJIAAAAAElFTkSuQmCC",
  PS = (n) => ({
    hidden: { y: -50, opacity: 0 },
    show: {
      y: 0,
      opacity: 1,
      transition: { type: "spring", duration: 1.25, delay: n },
    },
  }),
  Gh = (n, e, t, i) => ({
    hidden: {
      x: n === "left" ? 100 : n === "right" ? -100 : 0,
      y: n === "up" ? 100 : n === "down" ? -100 : 0,
      opacity: 0,
    },
    show: {
      x: 0,
      y: 0,
      opacity: 1,
      transition: { type: e, delay: t, duration: i, ease: "easeOut" },
    },
  }),
  cA = (n, e, t, i) => ({
    hidden: {
      x: n === "left" ? "-100%" : n === "right" ? "100%" : 0,
      y: n === "up" || n === "down" ? "100%" : 0,
    },
    show: {
      x: 0,
      y: 0,
      transition: { type: e, delay: t, duration: i, ease: "easeOut" },
    },
  }),
  p7 = (n, e) => ({
    hidden: {},
    show: { transition: { staggerChildren: n, delayChildren: e || 0 } },
  }),
  m7 = () =>
    q.jsxs("section", {
      className: "relative w-full h-screen mx-auto rounded-br-lg rounded-bl-lg",
      children: [
        q.jsx("div", {
          className:
            "absolute inset-0 top-[120px] max-w-7xl mx-auto ${styles.paddingX} px-1 flex flex-col gap-5",
          children: q.jsxs("div", {
            className:
              "mt-20 grid grid-cols-1 sm:grid-cols-[1fr,1fr] lg:grid-cols-[1fr,1fr] gap-14",
            children: [
              q.jsxs("div", {
                className: "flex flex-col gap-7 xs:gap-14",
                children: [
                  q.jsxs("h1", {
                    className: `${Ki.heroHeadText} font-semibold text-white`,
                    children: [
                      "A soluo em TI ",
                      q.jsx("br", {}),
                      " para voc!",
                      q.jsx("img", {
                        src: d7,
                        alt: "Logo",
                        className:
                          "inline-block ml-2 w-12 h-auto sm:w-14 sm:h-auto md:w-14 md:h-auto lg:w-14 lg:h-auto xl:w-16 xl:h-auto",
                      }),
                    ],
                  }),
                  q.jsxs("div", {
                    className: "mt-4 flex gap-4",
                    children: [
                      q.jsx("button", {
                        className:
                          "px-4 py-2 text-white rounded border border-[#F5F5F5] bg-transparent hover:border-transparent hover:bg-purpleclear transition duration-300",
                        children: "Website",
                      }),
                      q.jsx("button", {
                        className:
                          "px-4 py-2 text-white rounded border border-[#F5F5F5] bg-transparent hover:border-transparent hover:bg-purpleclear transition duration-300",
                        children: "Apps",
                      }),
                      q.jsx("button", {
                        className:
                          "px-4 py-2 text-white rounded border border-[#F5F5F5] bg-transparent hover:border-transparent hover:bg-purpleclear transition duration-300",
                        children: "Hubs",
                      }),
                    ],
                  }),
                ],
              }),
              q.jsx(tr.div, {
                variants: cA("right", "tween", 0.2, 1),
                className: "xl:flex-1 xl:h-600px md:h-[450px] h-[350px]",
                children: q.jsx(e8, {}),
              }),
            ],
          }),
        }),
        q.jsx("div", {
          className:
            "absolute xs:bottom-32 bottom-0 w-full flex justify-center items-center",
          children: q.jsx("a", {
            href: "#about",
            children: q.jsx("div", {
              className:
                "w-[35px] h-[64px] rounded-3xl border-4 border-secondary flex justify-center items-start p-2",
              children: q.jsx(tr.div, {
                animate: { y: [0, 24, 0] },
                transition: {
                  duration: 1.5,
                  repeat: 1 / 0,
                  repeatType: "loop",
                },
                className: "w-3 h-3 rounded-full bg-secondary mb-1",
              }),
            }),
          }),
        }),
      ],
    }),
  Pb = [
    { id: "Servicos", title: "Servios" },
    { id: "Depoimentos", title: "Depoimentos" },
    { id: "Projetos", title: "Projetos" },
    { id: "Contato", title: "Contato" },
  ],
  g7 = [
    {
      title: "Desenvolvimento de solues em TI baseadas em software",
      Subtitle: "Desenvolvimento de soluo",
      texto: "Em Desenvolvimento 1",
    },
    {
      title: "Informatizao de processos organizacionais",
      Subtitle: "Desenvolvimento de soluo 2",
      texto: "Em Desenvolvimento 2",
    },
    {
      title: "Capacitaes para empresas",
      Subtitle: "Desenvolvimento de soluo 3",
      texto: "Em Desenvolvimento 3",
    },
    {
      title: "Solues de Infraestrutura em Nuvem com AWS",
      Subtitle: "Desenvolvimento de soluo 4",
      texto: "Em Desenvolvimento 4",
    },
  ],
  v7 = [
    {
      testimonial:
        "Apesar de sua recente entrada no mercado, a AltoTech est se destacando. A empresa  responsvel pelo desenvolvimento e manuteno do site do ECOP, o que evidencia sua competncia e inovao.",
      empresa: "ecop.ufersa",
      name: "Francisco Carlos Gurgel da Silva Segundo",
      designation: "Docente Coordenador",
      company: "Ecop",
      image: Sm,
    },
    {
      testimonial:
        "A parceria com a Altotech foi crucial para a ACVL, permitindo criar um site oficial que apresenta nossa histria, aes e prestao de contas, essencial para participao em editais de fomento.",
      empresa: "voluntariosdaleitura",
      name: "Rafaella Pereira Chagas",
      designation: "Secretria na Diretoria e Coordenadora pedaggica",
      company: "ACVL",
      image: Sm,
    },
    {
      testimonial:
        "Minha experincia com a AltoTech foi satisfatria no desenvolvimento do site do seminrio internacional de ensino, garantindo divulgaes, inscries, e atualizaes em tempo real.",
      empresa: "Semite",
      name: "Glaydson Oliveria",
      designation: "Docente Coordenador",
      company: "Semite",
      image: Sm,
    },
  ],
  y7 = [
    {
      name: "Website ECOP",
      description: "",
      tags: [],
      image: u7,
      source_code_link: "https://ecopufersa.com.br/",
    },
    {
      name: "Voluntarios da Leitura",
      description: "",
      tags: [],
      image: f7,
      source_code_link: "",
    },
    {
      name: "Website Semite",
      description: "",
      tags: [],
      image: h7,
      source_code_link: "",
    },
  ],
  x7 = () => {
    const [n, e] = W.useState(""),
      [t, i] = W.useState(!1),
      [r, s] = W.useState(!1);
    return (
      W.useEffect(() => {
        const o = () => {
          window.scrollY > 100 ? s(!0) : s(!1);
        };
        return (
          window.addEventListener("scroll", o),
          () => window.removeEventListener("scroll", o)
        );
      }, []),
      q.jsx("nav", {
        className: `${Ki.paddingX} w-full flex items-center py-5 fixed top-0 z-20 bg-transparent`,
        children: q.jsxs("div", {
          className:
            "w-full flex justify-between items-center max-w-7xl mx-auto",
          children: [
            q.jsx(aU, {
              to: "/",
              className: "flex items-center gap-2",
              onClick: () => {
                e(""), window.scrollTo(0, 0);
              },
              children: q.jsx("img", {
                src: sD,
                alt: "logo",
                className: "w-9 h-9 object-contain",
              }),
            }),
            q.jsx("ul", {
              className: "list-none hidden sm:flex flex-row gap-10",
              children: Pb.map((o) =>
                q.jsx(
                  "li",
                  {
                    className: `${
                      n === o.title ? "text-white" : "text-secondary"
                    } hover:text-white text-[18px] font-medium cursor-pointer`,
                    onClick: () => e(o.title),
                    children: q.jsx("a", {
                      href: `#${o.id}`,
                      children: o.title,
                    }),
                  },
                  o.id
                )
              ),
            }),
            q.jsxs("div", {
              className: "sm:hidden flex flex-1 justify-end items-center",
              children: [
                q.jsx("img", {
                  src: t ? c7 : l7,
                  alt: "menu",
                  className: "w-[28px] h-[28px] object-contain cursor-pointer",
                  onClick: () => i(!t),
                }),
                q.jsx("div", {
                  className: `${
                    t ? "flex" : "hidden"
                  } p-6 bg-menuBg absolute top-20 right-0 mx-4 my-2 min-w-[140px] z-10 rounded-xl`,
                  children: q.jsx("ul", {
                    className:
                      "list-none flex justify-end items-start flex-1 flex-col gap-4",
                    children: Pb.map((o) =>
                      q.jsx(
                        "li",
                        {
                          className: `font-poppins font-medium cursor-pointer text-[16px] ${
                            n === o.title ? "text-white" : "text-secondary"
                          }`,
                          onClick: () => {
                            i(!t), e(o.title);
                          },
                          children: q.jsx("a", {
                            href: `#${o.id}`,
                            children: o.title,
                          }),
                        },
                        o.id
                      )
                    ),
                  }),
                }),
              ],
            }),
          ],
        }),
      })
    );
  };
var _7 = Object.defineProperty,
  A7 = Object.defineProperties,
  S7 = Object.getOwnPropertyDescriptors,
  Bb = Object.getOwnPropertySymbols,
  M7 = Object.prototype.hasOwnProperty,
  E7 = Object.prototype.propertyIsEnumerable,
  Lb = (n, e, t) =>
    e in n
      ? _7(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  sf = (n, e) => {
    for (var t in e || (e = {})) M7.call(e, t) && Lb(n, t, e[t]);
    if (Bb) for (var t of Bb(e)) E7.call(e, t) && Lb(n, t, e[t]);
    return n;
  },
  of = (n, e) => A7(n, S7(e)),
  oD = class extends W.Component {
    constructor(n) {
      super(n), (this.ref = Et.createRef()), (this.state = { style: {} });
      const e = {
        reverse: !1,
        max: 35,
        perspective: 1e3,
        easing: "cubic-bezier(.03,.98,.52,.99)",
        scale: "1.1",
        speed: "1000",
        transition: !0,
        axis: null,
        reset: !0,
      };
      (this.width = null),
        (this.height = null),
        (this.left = null),
        (this.top = null),
        (this.transitionTimeout = null),
        (this.updateCall = null),
        (this.element = null),
        (this.settings = Object.assign({}, e, this.props.options)),
        (this.reverse = this.settings.reverse ? -1 : 1),
        (this.onMouseEnter = this.onMouseEnter.bind(
          this,
          this.props.onMouseEnter
        )),
        (this.onMouseMove = this.onMouseMove.bind(
          this,
          this.props.onMouseMove
        )),
        (this.onMouseLeave = this.onMouseLeave.bind(
          this,
          this.props.onMouseLeave
        ));
    }
    componentDidMount() {
      (this.element = this.ref.current),
        setTimeout(() => {
          this.element.parentElement.querySelector(":hover") === this.element &&
            this.onMouseEnter();
        }, 0);
    }
    componentWillUnmount() {
      clearTimeout(this.transitionTimeout),
        cancelAnimationFrame(this.updateCall);
    }
    onMouseEnter(n = () => {}, e) {
      return (
        this.updateElementPosition(),
        this.setState(
          Object.assign({}, this.state, {
            style: of(sf({}, this.state.style), { willChange: "transform" }),
          })
        ),
        this.setTransition(),
        n(e)
      );
    }
    reset() {
      window.requestAnimationFrame(() => {
        this.setState(
          Object.assign({}, this.state, {
            style: of(sf({}, this.state.style), {
              transform: `perspective(${this.settings.perspective}px) rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)`,
            }),
          })
        );
      });
    }
    onMouseMove(n = () => {}, e) {
      return (
        e.persist(),
        this.updateCall !== null &&
          window.cancelAnimationFrame(this.updateCall),
        (this.event = e),
        (this.updateCall = requestAnimationFrame(this.update.bind(this, e))),
        n(e)
      );
    }
    setTransition() {
      clearTimeout(this.transitionTimeout),
        this.setState(
          Object.assign({}, this.state, {
            style: of(sf({}, this.state.style), {
              transition: `${this.settings.speed}ms ${this.settings.easing}`,
            }),
          })
        ),
        (this.transitionTimeout = setTimeout(() => {
          this.setState(
            Object.assign({}, this.state, {
              style: of(sf({}, this.state.style), { transition: "" }),
            })
          );
        }, this.settings.speed));
    }
    onMouseLeave(n = () => {}, e) {
      return this.setTransition(), this.settings.reset && this.reset(), n(e);
    }
    getValues(n) {
      const e = (n.nativeEvent.clientX - this.left) / this.width,
        t = (n.nativeEvent.clientY - this.top) / this.height,
        i = Math.min(Math.max(e, 0), 1),
        r = Math.min(Math.max(t, 0), 1),
        s = (
          this.reverse *
          (this.settings.max / 2 - i * this.settings.max)
        ).toFixed(2),
        o = (
          this.reverse *
          (r * this.settings.max - this.settings.max / 2)
        ).toFixed(2),
        a = i * 100,
        l = r * 100;
      return { tiltX: s, tiltY: o, percentageX: a, percentageY: l };
    }
    updateElementPosition() {
      const n = this.element.getBoundingClientRect();
      (this.width = this.element.offsetWidth),
        (this.height = this.element.offsetHeight),
        (this.left = n.left),
        (this.top = n.top);
    }
    update(n) {
      const e = this.getValues(n);
      this.setState(
        Object.assign({}, this.state, {
          style: of(sf({}, this.state.style), {
            transform: `perspective(${this.settings.perspective}px) rotateX(${
              this.settings.axis === "x" ? 0 : e.tiltY
            }deg) rotateY(${
              this.settings.axis === "y" ? 0 : e.tiltX
            }deg) scale3d(${this.settings.scale}, ${this.settings.scale}, ${
              this.settings.scale
            })`,
          }),
        })
      ),
        (this.updateCall = null);
    }
    render() {
      const n = Object.assign({}, this.props.style, this.state.style);
      return q.jsx("div", {
        style: n,
        ref: this.ref,
        className: this.props.className,
        onMouseEnter: this.onMouseEnter,
        onMouseMove: this.onMouseMove,
        onMouseLeave: this.onMouseLeave,
        children: this.props.children,
      });
    }
  };
const Vh = (n, e) =>
    function () {
      return q.jsxs(tr.section, {
        variants: p7(),
        initial: "hidden",
        whileInView: "show",
        viewport: { once: !0, amount: 0.25 },
        className: `${Ki.padding} max-w-7xl mx-auto relative z-0`,
        children: [
          q.jsx("span", { className: "hash-span", id: e, children: "" }),
          q.jsx(n, {}),
        ],
      });
    },
  aD = ({ index: n, title: e }) =>
    q.jsx(oD, {
      className: "xs:w-[250px] w-full",
      options: { max: 45, scale: 1, speed: 450 },
      children: q.jsx(tr.div, {
        variants: Gh("right", "spring", n * 0.5, 0.75),
        className: "w-full green-pink-gradient p-[1px] rounded-[20px]",
        children: q.jsxs("div", {
          className:
            "bg-tertiary rounded-[20px] py-5 px-12 min-h-[280px] flex justify-evenly items-center flex-col",
          children: [
            q.jsx("h3", {
              className:
                "text-white text-[16px] font-semibold text-left h3-with-line",
              children: e,
            }),
            q.jsx("div", {
              className:
                "green-pink-gradient flex justify-center items-center rounded-[10px]",
              style: { width: "100%", height: "6vh" },
              children: q.jsx("button", {
                onClick: () => (window.location.href = "#Contato"),
                className:
                  "bg-tertiary text-white w-full h-full flex justify-center items-center rounded-[10px]",
                style: { width: "99%", height: "95%" },
                children: "Saiba Mais",
              }),
            }),
          ],
        }),
      }),
    });
aD.propTypes = { index: Hn.number.isRequired, title: Hn.string.isRequired };
const w7 = () =>
    q.jsxs(q.Fragment, {
      children: [
        q.jsxs(tr.div, {
          variants: PS(),
          id: "about",
          children: [
            q.jsx("h2", {
              className: Ki.sectionHeadText,
              children: "Servios",
            }),
            q.jsx("div", {
              className: "flex items-center justify-center",
              children: q.jsx("p", {
                className: Ki.sectionSubText,
                children: "Como Podemos Ajudar?",
              }),
            }),
          ],
        }),
        q.jsx(tr.p, {
          variants: Gh("", "", 0.1, 1),
          className: "mt-4 text-secondary text-[17px] max-w-3xl leading-[30px]",
        }),
        q.jsx("div", {
          className: "mt-20 flex flex-wrap gap-10",
          children: g7.map((n, e) =>
            q.jsx(aD, { index: e, title: n.title }, n.title)
          ),
        }),
      ],
    }),
  T7 = Vh(w7, "Servicos"),
  lD = ({
    index: n,
    name: e,
    description: t,
    tags: i,
    image: r,
    source_code_link: s,
  }) =>
    q.jsx(tr.div, {
      variants: Gh("up", "spring", n * 0.5, 0.75),
      children: q.jsxs(oD, {
        options: { max: 45, scale: 1, speed: 450 },
        className: "work-gradient p-5 rounded-2xl sm:w-[360px] w-full",
        children: [
          q.jsxs("div", {
            className: "relative w-full h-[230px]",
            children: [
              q.jsx("img", {
                src: r,
                alt: "project_image",
                className: "w-full h-full object-cover rounded-2xl",
              }),
              q.jsx("div", {
                className:
                  "absolute inset-0 flex justify-end m-3 card-img_hover",
                children: q.jsx("div", {
                  onClick: () => window.open(s, "_blank"),
                  className:
                    "black-gradient w-10 h-10 rounded-full flex justify-center items-center cursor-pointer",
                  children: q.jsx("img", {
                    src: sD,
                    alt: "source code",
                    className: "w-1/2 h-1/2 object-contain",
                  }),
                }),
              }),
            ],
          }),
          q.jsxs("div", {
            className: "mt-5",
            children: [
              q.jsx("h3", {
                className: "text-white font-bold text-[24px]",
                children: e,
              }),
              q.jsx("p", {
                className: "mt-2 text-secondary text-[14px]",
                children: t,
              }),
            ],
          }),
          q.jsx("div", {
            className: "mt-4 flex flex-wrap gap-2",
            children: i.map((o) =>
              q.jsxs(
                "p",
                {
                  className: `text-[14px] ${o.color}`,
                  children: ["#", o.name],
                },
                `${e}-${o.name}`
              )
            ),
          }),
        ],
      }),
    });
lD.propTypes = {
  index: Hn.number.isRequired,
  name: Hn.string.isRequired,
  description: Hn.string.isRequired,
  tags: Hn.arrayOf(
    Hn.shape({ name: Hn.string.isRequired, color: Hn.string.isRequired })
  ).isRequired,
  image: Hn.string.isRequired,
  source_code_link: Hn.string.isRequired,
};
const C7 = () =>
    q.jsxs(q.Fragment, {
      children: [
        q.jsxs(tr.div, {
          variants: PS(),
          children: [
            q.jsx("h2", {
              className: `${Ki.sectionHeadText}`,
              children: "Projetos",
            }),
            q.jsx("div", {
              className: "flex items-center justify-center",
              children: q.jsx("p", {
                className: Ki.sectionSubText,
                children: "Alguns projetos nossos",
              }),
            }),
          ],
        }),
        q.jsx("div", {
          className: "w-full flex",
          children: q.jsx(tr.p, {
            variants: Gh("", "", 0.1, 1),
            className:
              "mt-3 text-secondary text-[17px] max-w-3xl leading-[30px]",
          }),
        }),
        q.jsx("div", {
          className: "mt-20 flex flex-wrap gap-7",
          children: y7.map((n, e) =>
            q.jsx(lD, { index: e, ...n }, `project-${e}`)
          ),
        }),
      ],
    }),
  b7 = Vh(C7, "Projetos"),
  cD = ({
    index: n,
    testimonial: e,
    name: t,
    designation: i,
    company: r,
    empresa: s,
  }) =>
    q.jsxs(tr.div, {
      variants: Gh("", "spring", n * 0.5, 0.75),
      className: "boxShadow Dep-gradient p-10 rounded-3xl xs:w-[320px] w-full",
      children: [
        q.jsx("p", {
          className: "text-white font-black text-[48px]",
          children: '"',
        }),
        q.jsxs("div", {
          className: "mt-1",
          children: [
            q.jsx("p", {
              className: "text-white text-start tracking-wider text-[18px]",
              children: e,
            }),
            q.jsx("div", {
              className: "mt-7 flex justify-between items-center gap-2",
              children: q.jsxs("div", {
                className: "flex-1 flex flex-col",
                children: [
                  q.jsxs("p", {
                    className: "text-white font-medium text-[16px]",
                    children: [
                      q.jsx("span", {
                        className: "blue-text-gradient",
                        children: "@",
                      }),
                      " ",
                      s,
                    ],
                  }),
                  q.jsxs("p", {
                    className: "mt-1 text-secondary text-[12px]",
                    children: [t, ": ", i, " do ", r],
                  }),
                ],
              }),
            }),
          ],
        }),
      ],
    });
cD.propTypes = {
  index: Hn.number.isRequired,
  testimonial: Hn.string.isRequired,
  name: Hn.string.isRequired,
  designation: Hn.string.isRequired,
  company: Hn.string.isRequired,
  empresa: Hn.string.isRequired,
  image: Hn.string.isRequired,
};
const R7 = () =>
    q.jsxs("div", {
      className: "mt-12 bg-transparent rounded-[20px]",
      children: [
        q.jsx("div", {
          className: `bg-transparent rounded-2xl ${Ki.padding} min-h-[300px]`,
          children: q.jsxs(tr.div, {
            variants: PS(),
            children: [
              q.jsx("h2", {
                className: Ki.sectionHeadText,
                children: "Depoimentos",
              }),
              q.jsx("div", {
                className: "flex items-center justify-center",
                children: q.jsx("p", {
                  className: Ki.sectionSubText,
                  children: "O que falam sobre ns",
                }),
              }),
            ],
          }),
        }),
        q.jsx("div", {
          className: `-mt-20 pb-14 ${Ki.paddingX} flex flex-wrap gap-7`,
          children: v7.map((n, e) => q.jsx(cD, { index: e, ...n }, n.name)),
        }),
      ],
    }),
  P7 = Vh(R7, "Depoimentos"),
  dh = { _origin: "https://api.emailjs.com" },
  B7 = (n, e = "https://api.emailjs.com") => {
    (dh._userID = n), (dh._origin = e);
  },
  uD = (n, e, t) => {
    if (!n)
      throw "The public key is required. Visit https://dashboard.emailjs.com/admin/account";
    if (!e)
      throw "The service ID is required. Visit https://dashboard.emailjs.com/admin";
    if (!t)
      throw "The template ID is required. Visit https://dashboard.emailjs.com/admin/templates";
    return !0;
  };
class Ib {
  constructor(e) {
    (this.status = e ? e.status : 0),
      (this.text = e ? e.responseText : "Network Error");
  }
}
const fD = (n, e, t = {}) =>
    new Promise((i, r) => {
      const s = new XMLHttpRequest();
      s.addEventListener("load", ({ target: o }) => {
        const a = new Ib(o);
        a.status === 200 || a.text === "OK" ? i(a) : r(a);
      }),
        s.addEventListener("error", ({ target: o }) => {
          r(new Ib(o));
        }),
        s.open("POST", dh._origin + n, !0),
        Object.keys(t).forEach((o) => {
          s.setRequestHeader(o, t[o]);
        }),
        s.send(e);
    }),
  L7 = (n, e, t, i) => {
    const r = i || dh._userID;
    return (
      uD(r, n, e),
      fD(
        "/api/v1.0/email/send",
        JSON.stringify({
          lib_version: "3.11.0",
          user_id: r,
          service_id: n,
          template_id: e,
          template_params: t,
        }),
        { "Content-type": "application/json" }
      )
    );
  },
  I7 = (n) => {
    let e;
    if (
      (typeof n == "string" ? (e = document.querySelector(n)) : (e = n),
      !e || e.nodeName !== "FORM")
    )
      throw "The 3rd parameter is expected to be the HTML form element or the style selector of form";
    return e;
  },
  D7 = (n, e, t, i) => {
    const r = i || dh._userID,
      s = I7(t);
    uD(r, n, e);
    const o = new FormData(s);
    return (
      o.append("lib_version", "3.11.0"),
      o.append("service_id", n),
      o.append("template_id", e),
      o.append("user_id", r),
      fD("/api/v1.0/email/send-form", o)
    );
  },
  F7 = { init: B7, send: L7, sendForm: D7 };
function hD(n) {
  var e,
    t,
    i = "";
  if (typeof n == "string" || typeof n == "number") i += n;
  else if (typeof n == "object")
    if (Array.isArray(n)) {
      var r = n.length;
      for (e = 0; e < r; e++)
        n[e] && (t = hD(n[e])) && (i && (i += " "), (i += t));
    } else for (t in n) n[t] && (i && (i += " "), (i += t));
  return i;
}
function Po() {
  for (var n, e, t = 0, i = "", r = arguments.length; t < r; t++)
    (n = arguments[t]) && (e = hD(n)) && (i && (i += " "), (i += e));
  return i;
}
const ph = (n) => typeof n == "number" && !isNaN(n),
  el = (n) => typeof n == "string",
  Yi = (n) => typeof n == "function",
  Mm = (n) => (el(n) || Yi(n) ? n : null),
  uA = (n) => W.isValidElement(n) || el(n) || Yi(n) || ph(n);
function N7(n, e, t) {
  t === void 0 && (t = 300);
  const { scrollHeight: i, style: r } = n;
  requestAnimationFrame(() => {
    (r.minHeight = "initial"),
      (r.height = i + "px"),
      (r.transition = `all ${t}ms`),
      requestAnimationFrame(() => {
        (r.height = "0"), (r.padding = "0"), (r.margin = "0"), setTimeout(e, t);
      });
  });
}
function m0(n) {
  let {
    enter: e,
    exit: t,
    appendPosition: i = !1,
    collapse: r = !0,
    collapseDuration: s = 300,
  } = n;
  return function (o) {
    let {
      children: a,
      position: l,
      preventExitTransition: u,
      done: h,
      nodeRef: d,
      isIn: p,
      playToast: m,
    } = o;
    const y = i ? `${e}--${l}` : e,
      M = i ? `${t}--${l}` : t,
      A = W.useRef(0);
    return (
      W.useLayoutEffect(() => {
        const g = d.current,
          x = y.split(" "),
          _ = (E) => {
            E.target === d.current &&
              (m(),
              g.removeEventListener("animationend", _),
              g.removeEventListener("animationcancel", _),
              A.current === 0 &&
                E.type !== "animationcancel" &&
                g.classList.remove(...x));
          };
        g.classList.add(...x),
          g.addEventListener("animationend", _),
          g.addEventListener("animationcancel", _);
      }, []),
      W.useEffect(() => {
        const g = d.current,
          x = () => {
            g.removeEventListener("animationend", x), r ? N7(g, h, s) : h();
          };
        p ||
          (u
            ? x()
            : ((A.current = 1),
              (g.className += ` ${M}`),
              g.addEventListener("animationend", x)));
      }, [p]),
      Et.createElement(Et.Fragment, null, a)
    );
  };
}
function Db(n, e) {
  return n != null
    ? {
        content: n.content,
        containerId: n.props.containerId,
        id: n.props.toastId,
        theme: n.props.theme,
        type: n.props.type,
        data: n.props.data || {},
        isLoading: n.props.isLoading,
        icon: n.props.icon,
        status: e,
      }
    : {};
}
const vi = new Map();
let mh = [];
const fA = new Set(),
  U7 = (n) => fA.forEach((e) => e(n)),
  dD = () => vi.size > 0;
function pD(n, e) {
  var t;
  if (e) return !((t = vi.get(e)) == null || !t.isToastActive(n));
  let i = !1;
  return (
    vi.forEach((r) => {
      r.isToastActive(n) && (i = !0);
    }),
    i
  );
}
function mD(n, e) {
  uA(n) &&
    (dD() || mh.push({ content: n, options: e }),
    vi.forEach((t) => {
      t.buildToast(n, e);
    }));
}
function Fb(n, e) {
  vi.forEach((t) => {
    e != null && e != null && e.containerId
      ? (e == null ? void 0 : e.containerId) === t.id &&
        t.toggle(n, e == null ? void 0 : e.id)
      : t.toggle(n, e == null ? void 0 : e.id);
  });
}
function O7(n) {
  const {
    subscribe: e,
    getSnapshot: t,
    setProps: i,
  } = W.useRef(
    (function (s) {
      const o = s.containerId || 1;
      return {
        subscribe(a) {
          const l = (function (h, d, p) {
            let m = 1,
              y = 0,
              M = [],
              A = [],
              g = [],
              x = d;
            const _ = new Map(),
              E = new Set(),
              T = () => {
                (g = Array.from(_.values())), E.forEach((B) => B());
              },
              R = (B) => {
                (A = B == null ? [] : A.filter((b) => b !== B)), T();
              },
              P = (B) => {
                const {
                    toastId: b,
                    onOpen: L,
                    updateId: z,
                    children: $,
                  } = B.props,
                  X = z == null;
                B.staleId && _.delete(B.staleId),
                  _.set(b, B),
                  (A = [...A, B.props.toastId].filter((Y) => Y !== B.staleId)),
                  T(),
                  p(Db(B, X ? "added" : "updated")),
                  X && Yi(L) && L(W.isValidElement($) && $.props);
              };
            return {
              id: h,
              props: x,
              observe: (B) => (E.add(B), () => E.delete(B)),
              toggle: (B, b) => {
                _.forEach((L) => {
                  (b != null && b !== L.props.toastId) ||
                    (Yi(L.toggle) && L.toggle(B));
                });
              },
              removeToast: R,
              toasts: _,
              clearQueue: () => {
                (y -= M.length), (M = []);
              },
              buildToast: (B, b) => {
                if (
                  ((j) => {
                    let { containerId: he, toastId: ae, updateId: xe } = j;
                    const Ae = he ? he !== h : h !== 1,
                      Le = _.has(ae) && xe == null;
                    return Ae || Le;
                  })(b)
                )
                  return;
                const {
                    toastId: L,
                    updateId: z,
                    data: $,
                    staleId: X,
                    delay: Y,
                  } = b,
                  K = () => {
                    R(L);
                  },
                  ie = z == null;
                ie && y++;
                const ee = {
                  ...x,
                  style: x.toastStyle,
                  key: m++,
                  ...Object.fromEntries(
                    Object.entries(b).filter((j) => {
                      let [he, ae] = j;
                      return ae != null;
                    })
                  ),
                  toastId: L,
                  updateId: z,
                  data: $,
                  closeToast: K,
                  isIn: !1,
                  className: Mm(b.className || x.toastClassName),
                  bodyClassName: Mm(b.bodyClassName || x.bodyClassName),
                  progressClassName: Mm(
                    b.progressClassName || x.progressClassName
                  ),
                  autoClose:
                    !b.isLoading &&
                    ((I = b.autoClose),
                    (G = x.autoClose),
                    I === !1 || (ph(I) && I > 0) ? I : G),
                  deleteToast() {
                    const j = _.get(L),
                      { onClose: he, children: ae } = j.props;
                    Yi(he) && he(W.isValidElement(ae) && ae.props),
                      p(Db(j, "removed")),
                      _.delete(L),
                      y--,
                      y < 0 && (y = 0),
                      M.length > 0 ? P(M.shift()) : T();
                  },
                };
                var I, G;
                (ee.closeButton = x.closeButton),
                  b.closeButton === !1 || uA(b.closeButton)
                    ? (ee.closeButton = b.closeButton)
                    : b.closeButton === !0 &&
                      (ee.closeButton = !uA(x.closeButton) || x.closeButton);
                let k = B;
                W.isValidElement(B) && !el(B.type)
                  ? (k = W.cloneElement(B, {
                      closeToast: K,
                      toastProps: ee,
                      data: $,
                    }))
                  : Yi(B) &&
                    (k = B({ closeToast: K, toastProps: ee, data: $ }));
                const U = { content: k, props: ee, staleId: X };
                x.limit && x.limit > 0 && y > x.limit && ie
                  ? M.push(U)
                  : ph(Y)
                  ? setTimeout(() => {
                      P(U);
                    }, Y)
                  : P(U);
              },
              setProps(B) {
                x = B;
              },
              setToggle: (B, b) => {
                _.get(B).toggle = b;
              },
              isToastActive: (B) => A.some((b) => b === B),
              getSnapshot: () => (x.newestOnTop ? g.reverse() : g),
            };
          })(o, s, U7);
          vi.set(o, l);
          const u = l.observe(a);
          return (
            mh.forEach((h) => mD(h.content, h.options)),
            (mh = []),
            () => {
              u(), vi.delete(o);
            }
          );
        },
        setProps(a) {
          var l;
          (l = vi.get(o)) == null || l.setProps(a);
        },
        getSnapshot() {
          var a;
          return (a = vi.get(o)) == null ? void 0 : a.getSnapshot();
        },
      };
    })(n)
  ).current;
  i(n);
  const r = W.useSyncExternalStore(e, t, t);
  return {
    getToastToRender: function (s) {
      if (!r) return [];
      const o = new Map();
      return (
        r.forEach((a) => {
          const { position: l } = a.props;
          o.has(l) || o.set(l, []), o.get(l).push(a);
        }),
        Array.from(o, (a) => s(a[0], a[1]))
      );
    },
    isToastActive: pD,
    count: r == null ? void 0 : r.length,
  };
}
function k7(n) {
  const [e, t] = W.useState(!1),
    [i, r] = W.useState(!1),
    s = W.useRef(null),
    o = W.useRef({
      start: 0,
      delta: 0,
      removalDistance: 0,
      canCloseOnClick: !0,
      canDrag: !1,
      didMove: !1,
    }).current,
    {
      autoClose: a,
      pauseOnHover: l,
      closeToast: u,
      onClick: h,
      closeOnClick: d,
    } = n;
  var p, m;
  function y() {
    t(!0);
  }
  function M() {
    t(!1);
  }
  function A(_) {
    const E = s.current;
    o.canDrag &&
      E &&
      ((o.didMove = !0),
      e && M(),
      (o.delta =
        n.draggableDirection === "x"
          ? _.clientX - o.start
          : _.clientY - o.start),
      o.start !== _.clientX && (o.canCloseOnClick = !1),
      (E.style.transform = `translate3d(${
        n.draggableDirection === "x"
          ? `${o.delta}px, var(--y)`
          : `0, calc(${o.delta}px + var(--y))`
      },0)`),
      (E.style.opacity = "" + (1 - Math.abs(o.delta / o.removalDistance))));
  }
  function g() {
    document.removeEventListener("pointermove", A),
      document.removeEventListener("pointerup", g);
    const _ = s.current;
    if (o.canDrag && o.didMove && _) {
      if (((o.canDrag = !1), Math.abs(o.delta) > o.removalDistance))
        return r(!0), n.closeToast(), void n.collapseAll();
      (_.style.transition = "transform 0.2s, opacity 0.2s"),
        _.style.removeProperty("transform"),
        _.style.removeProperty("opacity");
    }
  }
  (m = vi.get(
    (p = { id: n.toastId, containerId: n.containerId, fn: t }).containerId || 1
  )) == null || m.setToggle(p.id, p.fn),
    W.useEffect(() => {
      if (n.pauseOnFocusLoss)
        return (
          document.hasFocus() || M(),
          window.addEventListener("focus", y),
          window.addEventListener("blur", M),
          () => {
            window.removeEventListener("focus", y),
              window.removeEventListener("blur", M);
          }
        );
    }, [n.pauseOnFocusLoss]);
  const x = {
    onPointerDown: function (_) {
      if (n.draggable === !0 || n.draggable === _.pointerType) {
        (o.didMove = !1),
          document.addEventListener("pointermove", A),
          document.addEventListener("pointerup", g);
        const E = s.current;
        (o.canCloseOnClick = !0),
          (o.canDrag = !0),
          (E.style.transition = "none"),
          n.draggableDirection === "x"
            ? ((o.start = _.clientX),
              (o.removalDistance = E.offsetWidth * (n.draggablePercent / 100)))
            : ((o.start = _.clientY),
              (o.removalDistance =
                (E.offsetHeight *
                  (n.draggablePercent === 80
                    ? 1.5 * n.draggablePercent
                    : n.draggablePercent)) /
                100));
      }
    },
    onPointerUp: function (_) {
      const {
        top: E,
        bottom: T,
        left: R,
        right: P,
      } = s.current.getBoundingClientRect();
      _.nativeEvent.type !== "touchend" &&
      n.pauseOnHover &&
      _.clientX >= R &&
      _.clientX <= P &&
      _.clientY >= E &&
      _.clientY <= T
        ? M()
        : y();
    },
  };
  return (
    a && l && ((x.onMouseEnter = M), n.stacked || (x.onMouseLeave = y)),
    d &&
      (x.onClick = (_) => {
        h && h(_), o.canCloseOnClick && u();
      }),
    {
      playToast: y,
      pauseToast: M,
      isRunning: e,
      preventExitTransition: i,
      toastRef: s,
      eventHandlers: x,
    }
  );
}
function H7(n) {
  let {
    delay: e,
    isRunning: t,
    closeToast: i,
    type: r = "default",
    hide: s,
    className: o,
    style: a,
    controlledProgress: l,
    progress: u,
    rtl: h,
    isIn: d,
    theme: p,
  } = n;
  const m = s || (l && u === 0),
    y = {
      ...a,
      animationDuration: `${e}ms`,
      animationPlayState: t ? "running" : "paused",
    };
  l && (y.transform = `scaleX(${u})`);
  const M = Po(
      "Toastify__progress-bar",
      l
        ? "Toastify__progress-bar--controlled"
        : "Toastify__progress-bar--animated",
      `Toastify__progress-bar-theme--${p}`,
      `Toastify__progress-bar--${r}`,
      { "Toastify__progress-bar--rtl": h }
    ),
    A = Yi(o) ? o({ rtl: h, type: r, defaultClassName: M }) : Po(M, o),
    g = {
      [l && u >= 1 ? "onTransitionEnd" : "onAnimationEnd"]:
        l && u < 1
          ? null
          : () => {
              d && i();
            },
    };
  return Et.createElement(
    "div",
    { className: "Toastify__progress-bar--wrp", "data-hidden": m },
    Et.createElement("div", {
      className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${p} Toastify__progress-bar--${r}`,
    }),
    Et.createElement("div", {
      role: "progressbar",
      "aria-hidden": m ? "true" : "false",
      "aria-label": "notification timer",
      className: A,
      style: y,
      ...g,
    })
  );
}
let z7 = 1;
const gD = () => "" + z7++;
function G7(n) {
  return n && (el(n.toastId) || ph(n.toastId)) ? n.toastId : gD();
}
function Lf(n, e) {
  return mD(n, e), e.toastId;
}
function cg(n, e) {
  return { ...e, type: (e && e.type) || n, toastId: G7(e) };
}
function Zp(n) {
  return (e, t) => Lf(e, cg(n, t));
}
function Ht(n, e) {
  return Lf(n, cg("default", e));
}
(Ht.loading = (n, e) =>
  Lf(
    n,
    cg("default", {
      isLoading: !0,
      autoClose: !1,
      closeOnClick: !1,
      closeButton: !1,
      draggable: !1,
      ...e,
    })
  )),
  (Ht.promise = function (n, e, t) {
    let i,
      { pending: r, error: s, success: o } = e;
    r && (i = el(r) ? Ht.loading(r, t) : Ht.loading(r.render, { ...t, ...r }));
    const a = {
        isLoading: null,
        autoClose: null,
        closeOnClick: null,
        closeButton: null,
        draggable: null,
      },
      l = (h, d, p) => {
        if (d == null) return void Ht.dismiss(i);
        const m = { type: h, ...a, ...t, data: p },
          y = el(d) ? { render: d } : d;
        return (
          i ? Ht.update(i, { ...m, ...y }) : Ht(y.render, { ...m, ...y }), p
        );
      },
      u = Yi(n) ? n() : n;
    return u.then((h) => l("success", o, h)).catch((h) => l("error", s, h)), u;
  }),
  (Ht.success = Zp("success")),
  (Ht.info = Zp("info")),
  (Ht.error = Zp("error")),
  (Ht.warning = Zp("warning")),
  (Ht.warn = Ht.warning),
  (Ht.dark = (n, e) => Lf(n, cg("default", { theme: "dark", ...e }))),
  (Ht.dismiss = function (n) {
    (function (e) {
      var t;
      if (dD()) {
        if (e == null || el((t = e)) || ph(t))
          vi.forEach((i) => {
            i.removeToast(e);
          });
        else if (e && ("containerId" in e || "id" in e)) {
          const i = vi.get(e.containerId);
          i
            ? i.removeToast(e.id)
            : vi.forEach((r) => {
                r.removeToast(e.id);
              });
        }
      } else mh = mh.filter((i) => e != null && i.options.toastId !== e);
    })(n);
  }),
  (Ht.clearWaitingQueue = function (n) {
    n === void 0 && (n = {}),
      vi.forEach((e) => {
        !e.props.limit ||
          (n.containerId && e.id !== n.containerId) ||
          e.clearQueue();
      });
  }),
  (Ht.isActive = pD),
  (Ht.update = function (n, e) {
    e === void 0 && (e = {});
    const t = ((i, r) => {
      var s;
      let { containerId: o } = r;
      return (s = vi.get(o || 1)) == null ? void 0 : s.toasts.get(i);
    })(n, e);
    if (t) {
      const { props: i, content: r } = t,
        s = { delay: 100, ...i, ...e, toastId: e.toastId || n, updateId: gD() };
      s.toastId !== n && (s.staleId = n);
      const o = s.render || r;
      delete s.render, Lf(o, s);
    }
  }),
  (Ht.done = (n) => {
    Ht.update(n, { progress: 1 });
  }),
  (Ht.onChange = function (n) {
    return (
      fA.add(n),
      () => {
        fA.delete(n);
      }
    );
  }),
  (Ht.play = (n) => Fb(!0, n)),
  (Ht.pause = (n) => Fb(!1, n));
const V7 = typeof window < "u" ? W.useLayoutEffect : W.useEffect,
  $p = (n) => {
    let { theme: e, type: t, isLoading: i, ...r } = n;
    return Et.createElement("svg", {
      viewBox: "0 0 24 24",
      width: "100%",
      height: "100%",
      fill:
        e === "colored" ? "currentColor" : `var(--toastify-icon-color-${t})`,
      ...r,
    });
  },
  rx = {
    info: function (n) {
      return Et.createElement(
        $p,
        { ...n },
        Et.createElement("path", {
          d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z",
        })
      );
    },
    warning: function (n) {
      return Et.createElement(
        $p,
        { ...n },
        Et.createElement("path", {
          d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z",
        })
      );
    },
    success: function (n) {
      return Et.createElement(
        $p,
        { ...n },
        Et.createElement("path", {
          d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z",
        })
      );
    },
    error: function (n) {
      return Et.createElement(
        $p,
        { ...n },
        Et.createElement("path", {
          d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z",
        })
      );
    },
    spinner: function () {
      return Et.createElement("div", { className: "Toastify__spinner" });
    },
  },
  W7 = (n) => {
    const {
        isRunning: e,
        preventExitTransition: t,
        toastRef: i,
        eventHandlers: r,
        playToast: s,
      } = k7(n),
      {
        closeButton: o,
        children: a,
        autoClose: l,
        onClick: u,
        type: h,
        hideProgressBar: d,
        closeToast: p,
        transition: m,
        position: y,
        className: M,
        style: A,
        bodyClassName: g,
        bodyStyle: x,
        progressClassName: _,
        progressStyle: E,
        updateId: T,
        role: R,
        progress: P,
        rtl: B,
        toastId: b,
        deleteToast: L,
        isIn: z,
        isLoading: $,
        closeOnClick: X,
        theme: Y,
      } = n,
      K = Po(
        "Toastify__toast",
        `Toastify__toast-theme--${Y}`,
        `Toastify__toast--${h}`,
        { "Toastify__toast--rtl": B },
        { "Toastify__toast--close-on-click": X }
      ),
      ie = Yi(M)
        ? M({ rtl: B, position: y, type: h, defaultClassName: K })
        : Po(K, M),
      ee = (function (U) {
        let { theme: j, type: he, isLoading: ae, icon: xe } = U,
          Ae = null;
        const Le = { theme: j, type: he };
        return (
          xe === !1 ||
            (Yi(xe)
              ? (Ae = xe({ ...Le, isLoading: ae }))
              : W.isValidElement(xe)
              ? (Ae = W.cloneElement(xe, Le))
              : ae
              ? (Ae = rx.spinner())
              : ((Ve) => Ve in rx)(he) && (Ae = rx[he](Le))),
          Ae
        );
      })(n),
      I = !!P || !l,
      G = { closeToast: p, type: h, theme: Y };
    let k = null;
    return (
      o === !1 ||
        (k = Yi(o)
          ? o(G)
          : W.isValidElement(o)
          ? W.cloneElement(o, G)
          : (function (U) {
              let { closeToast: j, theme: he, ariaLabel: ae = "close" } = U;
              return Et.createElement(
                "button",
                {
                  className: `Toastify__close-button Toastify__close-button--${he}`,
                  type: "button",
                  onClick: (xe) => {
                    xe.stopPropagation(), j(xe);
                  },
                  "aria-label": ae,
                },
                Et.createElement(
                  "svg",
                  { "aria-hidden": "true", viewBox: "0 0 14 16" },
                  Et.createElement("path", {
                    fillRule: "evenodd",
                    d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z",
                  })
                )
              );
            })(G)),
      Et.createElement(
        m,
        {
          isIn: z,
          done: L,
          position: y,
          preventExitTransition: t,
          nodeRef: i,
          playToast: s,
        },
        Et.createElement(
          "div",
          {
            id: b,
            onClick: u,
            "data-in": z,
            className: ie,
            ...r,
            style: A,
            ref: i,
          },
          Et.createElement(
            "div",
            {
              ...(z && { role: R }),
              className: Yi(g) ? g({ type: h }) : Po("Toastify__toast-body", g),
              style: x,
            },
            ee != null &&
              Et.createElement(
                "div",
                {
                  className: Po("Toastify__toast-icon", {
                    "Toastify--animate-icon Toastify__zoom-enter": !$,
                  }),
                },
                ee
              ),
            Et.createElement("div", null, a)
          ),
          k,
          Et.createElement(H7, {
            ...(T && !I ? { key: `pb-${T}` } : {}),
            rtl: B,
            theme: Y,
            delay: l,
            isRunning: e,
            isIn: z,
            closeToast: p,
            hide: d,
            type: h,
            style: E,
            className: _,
            controlledProgress: I,
            progress: P || 0,
          })
        )
      )
    );
  },
  g0 = function (n, e) {
    return (
      e === void 0 && (e = !1),
      {
        enter: `Toastify--animate Toastify__${n}-enter`,
        exit: `Toastify--animate Toastify__${n}-exit`,
        appendPosition: e,
      }
    );
  },
  j7 = m0(g0("bounce", !0));
m0(g0("slide", !0));
m0(g0("zoom"));
m0(g0("flip"));
const X7 = {
  position: "top-right",
  transition: j7,
  autoClose: 5e3,
  closeButton: !0,
  pauseOnHover: !0,
  pauseOnFocusLoss: !0,
  draggable: "touch",
  draggablePercent: 80,
  draggableDirection: "x",
  role: "alert",
  theme: "light",
};
function J7(n) {
  let e = { ...X7, ...n };
  const t = n.stacked,
    [i, r] = W.useState(!0),
    s = W.useRef(null),
    { getToastToRender: o, isToastActive: a, count: l } = O7(e),
    { className: u, style: h, rtl: d, containerId: p } = e;
  function m(M) {
    const A = Po(
      "Toastify__toast-container",
      `Toastify__toast-container--${M}`,
      { "Toastify__toast-container--rtl": d }
    );
    return Yi(u)
      ? u({ position: M, rtl: d, defaultClassName: A })
      : Po(A, Mm(u));
  }
  function y() {
    t && (r(!0), Ht.play());
  }
  return (
    V7(() => {
      if (t) {
        var M;
        const A = s.current.querySelectorAll('[data-in="true"]'),
          g = 12,
          x = (M = e.position) == null ? void 0 : M.includes("top");
        let _ = 0,
          E = 0;
        Array.from(A)
          .reverse()
          .forEach((T, R) => {
            const P = T;
            P.classList.add("Toastify__toast--stacked"),
              R > 0 && (P.dataset.collapsed = `${i}`),
              P.dataset.pos || (P.dataset.pos = x ? "top" : "bot");
            const B = _ * (i ? 0.2 : 1) + (i ? 0 : g * R);
            P.style.setProperty("--y", `${x ? B : -1 * B}px`),
              P.style.setProperty("--g", `${g}`),
              P.style.setProperty("--s", "" + (1 - (i ? E : 0))),
              (_ += P.offsetHeight),
              (E += 0.025);
          });
      }
    }, [i, l, t]),
    Et.createElement(
      "div",
      {
        ref: s,
        className: "Toastify",
        id: p,
        onMouseEnter: () => {
          t && (r(!1), Ht.pause());
        },
        onMouseLeave: y,
      },
      o((M, A) => {
        const g = A.length ? { ...h } : { ...h, pointerEvents: "none" };
        return Et.createElement(
          "div",
          { className: m(M), style: g, key: `container-${M}` },
          A.map((x) => {
            let { content: _, props: E } = x;
            return Et.createElement(
              W7,
              {
                ...E,
                stacked: t,
                collapseAll: y,
                isIn: a(E.toastId, E.containerId),
                style: E.style,
                key: `toast-${E.key}`,
              },
              _
            );
          })
        );
      })
    )
  );
}
const K7 = () => {
    const n = W.useRef(),
      [e, t] = W.useState({ name: "", email: "", message: "" }),
      [i, r] = W.useState(!1),
      s = (a) => {
        const { target: l } = a,
          { name: u, value: h } = l;
        t({ ...e, [u]: h });
      },
      o = (a) => {
        if ((a.preventDefault(), !e.name || !e.email || !e.message)) {
          Ht.error("Por favor, preencha todos os campos.");
          return;
        }
        r(!0),
          F7.send(
            "service_psyfmp7",
            "template_l1fjeni",
            {
              from_name: e.name,
              to_name: "AltoTech",
              from_email: e.email,
              to_email: "projetos.altotech4@gmail.com",
              message: e.message,
            },
            "lLBzwvsiaQGANNc_H"
          ).then(
            () => {
              r(!1),
                Ht.success(
                  "Obrigado. Entraremos em contato com voc o mais rpido possvel."
                ),
                t({ name: "", email: "", message: "" });
            },
            (l) => {
              r(!1),
                console.error(l),
                Ht.error("Ah, algo deu errado. Por favor, tente novamente.");
            }
          );
      };
    return q.jsxs("div", {
      className:
        "xl:mt-12 flex xl:flex-row flex-col-reverse gap-10 overflow-hidden",
      children: [
        q.jsx(J7, { position: "bottom-right" }),
        q.jsxs(tr.div, {
          variants: cA("left", "tween", 0.2, 1),
          className: "flex-[0.75] cont-gradient p-8 rounded-2xl",
          children: [
            q.jsx("p", {
              className: Ki.sectionSubText,
              children: "Entre em contato",
            }),
            q.jsx("h3", { className: Ki.sectionHeadText, children: "Contato" }),
            q.jsxs("form", {
              ref: n,
              onSubmit: o,
              className: "mt-12 flex flex-col gap-8",
              children: [
                q.jsxs("label", {
                  className: "flex flex-col",
                  children: [
                    q.jsx("span", {
                      className: "text-white font-medium mb-4",
                      children: "Nome",
                    }),
                    q.jsx("input", {
                      type: "text",
                      name: "name",
                      value: e.name,
                      onChange: s,
                      placeholder: "Qual  o seu nome?",
                      className:
                        "imput-bg py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                    }),
                  ],
                }),
                q.jsxs("label", {
                  className: "flex flex-col",
                  children: [
                    q.jsx("span", {
                      className: "text-white font-medium mb-4",
                      children: "Email",
                    }),
                    q.jsx("input", {
                      type: "email",
                      name: "email",
                      value: e.email,
                      onChange: s,
                      placeholder: "Qual  o seu email?",
                      className:
                        "imput-bg py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                    }),
                  ],
                }),
                q.jsxs("label", {
                  className: "flex flex-col",
                  children: [
                    q.jsx("span", {
                      className: "text-white font-medium mb-4",
                      children: "Mensagem",
                    }),
                    q.jsx("textarea", {
                      rows: 7,
                      name: "message",
                      value: e.message,
                      onChange: s,
                      placeholder: "Escreva sua mensagem",
                      className:
                        "imput-bg py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                    }),
                  ],
                }),
                q.jsx("button", {
                  type: "submit",
                  className:
                    "bg-tertiary py-3 px-8 rounded-xl outline-none w-fit text-white font-bold shadow-md shadow-primary",
                  children: i ? "Enviando..." : "Enviar",
                }),
              ],
            }),
          ],
        }),
        q.jsx(tr.div, {
          variants: cA("right", "tween", 0.2, 1),
          className: "xl:flex-1 xl:h-auto md:h-[550px] h-[350px]",
          children: q.jsx(W9, {}),
        }),
      ],
    });
  },
  Y7 = Vh(K7, "Contato");
var vD = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0,
  },
  Nb = Et.createContext && Et.createContext(vD),
  Q7 = ["attr", "size", "title"];
function q7(n, e) {
  if (n == null) return {};
  var t = Z7(n, e),
    i,
    r;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    for (r = 0; r < s.length; r++)
      (i = s[r]),
        !(e.indexOf(i) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(n, i) &&
          (t[i] = n[i]);
  }
  return t;
}
function Z7(n, e) {
  if (n == null) return {};
  var t = {};
  for (var i in n)
    if (Object.prototype.hasOwnProperty.call(n, i)) {
      if (e.indexOf(i) >= 0) continue;
      t[i] = n[i];
    }
  return t;
}
function ug() {
  return (
    (ug = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    ug.apply(this, arguments)
  );
}
function Ub(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n);
    e &&
      (i = i.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, i);
  }
  return t;
}
function fg(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? Ub(Object(t), !0).forEach(function (i) {
          $7(n, i, t[i]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : Ub(Object(t)).forEach(function (i) {
          Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
        });
  }
  return n;
}
function $7(n, e, t) {
  return (
    (e = eX(e)),
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function eX(n) {
  var e = tX(n, "string");
  return typeof e == "symbol" ? e : e + "";
}
function tX(n, e) {
  if (typeof n != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var i = t.call(n, e || "default");
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function yD(n) {
  return (
    n &&
    n.map((e, t) =>
      Et.createElement(e.tag, fg({ key: t }, e.attr), yD(e.child))
    )
  );
}
function v0(n) {
  return (e) =>
    Et.createElement(nX, ug({ attr: fg({}, n.attr) }, e), yD(n.child));
}
function nX(n) {
  var e = (t) => {
    var { attr: i, size: r, title: s } = n,
      o = q7(n, Q7),
      a = r || t.size || "1em",
      l;
    return (
      t.className && (l = t.className),
      n.className && (l = (l ? l + " " : "") + n.className),
      Et.createElement(
        "svg",
        ug(
          { stroke: "currentColor", fill: "currentColor", strokeWidth: "0" },
          t.attr,
          i,
          o,
          {
            className: l,
            style: fg(fg({ color: n.color || t.color }, t.style), n.style),
            height: a,
            width: a,
            xmlns: "http://www.w3.org/2000/svg",
          }
        ),
        s && Et.createElement("title", null, s),
        n.children
      )
    );
  };
  return Nb !== void 0
    ? Et.createElement(Nb.Consumer, null, (t) => e(t))
    : e(vD);
}
function iX(n) {
  return v0({
    tag: "svg",
    attr: { viewBox: "0 0 512 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z",
        },
        child: [],
      },
    ],
  })(n);
}
function rX(n) {
  return v0({
    tag: "svg",
    attr: { viewBox: "0 0 448 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z",
        },
        child: [],
      },
    ],
  })(n);
}
function sX(n) {
  return v0({
    tag: "svg",
    attr: { viewBox: "0 0 448 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z",
        },
        child: [],
      },
    ],
  })(n);
}
function oX(n) {
  return v0({
    tag: "svg",
    attr: { viewBox: "0 0 512 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M256 8C119.033 8 8 119.033 8 256s111.033 248 248 248 248-111.033 248-248S392.967 8 256 8zm117.134 346.753c-1.592 1.867-39.776 45.731-109.851 45.731-84.692 0-144.484-63.26-144.484-145.567 0-81.303 62.004-143.401 143.762-143.401 66.957 0 101.965 37.315 103.422 38.904a12 12 0 0 1 1.238 14.623l-22.38 34.655c-4.049 6.267-12.774 7.351-18.234 2.295-.233-.214-26.529-23.88-61.88-23.88-46.116 0-73.916 33.575-73.916 76.082 0 39.602 25.514 79.692 74.277 79.692 38.697 0 65.28-28.338 65.544-28.625 5.132-5.565 14.059-5.033 18.508 1.053l24.547 33.572a12.001 12.001 0 0 1-.553 14.866z",
        },
        child: [],
      },
    ],
  })(n);
}
const aX = () =>
    q.jsx(q.Fragment, {
      children: q.jsxs("footer", {
        className: "sm:pl-12",
        children: [
          q.jsxs("div", {
            className:
              "flex flex-col lg:flex-row xl:justify-between justify-normal gap-12",
            children: [
              q.jsx("div", {
                children: q.jsx("img", {
                  src: Sm,
                  alt: "Logo da Altotech",
                  className: "w-28",
                }),
              }),
              q.jsxs("div", {
                children: [
                  q.jsx("h2", {
                    className: "font-bold text-3xl",
                    children: "Contato",
                  }),
                  q.jsxs("div", {
                    className: "space-y-3 mt-8",
                    children: [
                      q.jsx("p", {
                        className: "font-semibold",
                        children: "(84) 3317-8512",
                      }),
                      q.jsx("p", {
                        className: "font-semibold",
                        children: "cmpf@ufersa.edu.br",
                      }),
                      q.jsx("p", {
                        className: "font-semibold",
                        children: "https://paudosferros.ufersa.edu.br",
                      }),
                    ],
                  }),
                ],
              }),
              q.jsxs("div", {
                children: [
                  q.jsx("h2", {
                    className: "font-bold text-3xl",
                    children: "Localizao",
                  }),
                  q.jsxs("div", {
                    className: "space-y-3 mt-8",
                    children: [
                      q.jsx("p", {
                        className: "font-semibold",
                        children: "Endereo: BR-226, s/n - Bairro: So Geraldo",
                      }),
                      q.jsx("p", {
                        className: "font-semibold",
                        children: "Pau dos Ferros - RN",
                      }),
                      q.jsx("p", {
                        className: "font-semibold",
                        children: "CEP: 59900-000",
                      }),
                    ],
                  }),
                ],
              }),
              q.jsxs("div", {
                children: [
                  q.jsx("h2", {
                    className: "font-bold text-3xl",
                    children: "Redes sociais",
                  }),
                  q.jsxs("div", {
                    className: "mt-6 flex gap-5 ml-2",
                    children: [
                      q.jsx("a", {
                        href: "https://www.instagram.com/altotech_juniors/",
                        target: "_blank",
                        className: "hover:scale-125 transition-all",
                        children: q.jsx(rX, { size: 25 }),
                      }),
                      q.jsx("a", {
                        href: "#",
                        className: "hover:scale-125 transition-all",
                        children: q.jsx(iX, { size: 25 }),
                      }),
                      q.jsx("a", {
                        href: "https://www.linkedin.com/in/altotech-solu%C3%A7%C3%B5es-em-ti-60116a281/",
                        target: "_blank",
                        className: "hover:scale-125 transition-all",
                        children: q.jsx(sX, { size: 25 }),
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
          q.jsxs("div", {
            className: "mt-32 flex items-center gap-2",
            children: [
              q.jsx(oX, {}),
              q.jsx("p", {
                className: "font-semibold text-lg",
                children: "2023 AltoTech Todos os direitos reservados",
              }),
            ],
          }),
        ],
      }),
    }),
  lX = Vh(aX, "rodape"),
  cX = () =>
    q.jsx(rU, {
      children: q.jsxs("div", {
        className:
          "relative z-0 bg-primary h-screen overflow-y-auto custom-scrollbar",
        children: [
          q.jsxs("div", {
            className: "bg-transparent bg-cover bg-no-repeat bg-center",
            children: [q.jsx(x7, {}), q.jsx(m7, {}), q.jsx(tf, {})],
          }),
          q.jsxs("div", {
            className: "relative z-0",
            children: [q.jsx(T7, {}), q.jsx(tf, {})],
          }),
          q.jsxs("div", {
            className: "relative z-0",
            children: [q.jsx(P7, {}), q.jsx(tf, {})],
          }),
          q.jsxs("div", {
            className: "relative z-0",
            children: [q.jsx(b7, {}), q.jsx(tf, {})],
          }),
          q.jsxs("div", {
            className: "relative z-0",
            children: [q.jsx(Y7, {}), q.jsx(lX, {}), q.jsx(tf, {})],
          }),
        ],
      }),
    });
sx.createRoot(document.getElementById("root")).render(
  q.jsx(Et.StrictMode, { children: q.jsx(cX, {}) })
);
